; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\inv_mpu.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\inv_mpu.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP\GPS -I..\BSP\Sim900A -I..\BSP -I..\BSP\IWDG -I..\BSP\BlueTooth -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\BSP\Adxl345 -I..\BSP\TL718 -I..\BSP\PAM8403 -I..\BSP\W25X16 -I..\BSP\USB -I..\App\Debug -I..\App\SelfCheck -I..\App\GPSTask -I..\App\OBD -I..\App\Mems -I..\App\Voltage -I..\App\LKClient -I..\App\Paramlist -I..\App\ATC30 -I..\App -I..\BSP\mpu6050 -I..\App\mid-proc -I..\App\mpu6050Task -I..\BSP\dmp -I..\BSP\Bluetooth -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\inv_mpu.crf ..\BSP\dmp\inv_mpu.c]
                          THUMB

                          AREA ||i.accel_self_test||, CODE, READONLY, ALIGN=2

                  accel_self_test PROC
;;;1402   
;;;1403   static int accel_self_test(long *bias_regular, long *bias_st)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1404   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1405       int jj, result = 0;
000008  2500              MOVS     r5,#0
;;;1406       float st_shift[3], st_shift_cust, st_shift_var;
;;;1407   
;;;1408       get_accel_prod_shift(st_shift);
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       get_accel_prod_shift
;;;1409       for(jj = 0; jj < 3; jj++) {
000010  2400              MOVS     r4,#0
000012  e040              B        |L1.150|
                  |L1.20|
;;;1410           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
000014  f8560024          LDR      r0,[r6,r4,LSL #2]
000018  f8571024          LDR      r1,[r7,r4,LSL #2]
00001c  ebb00a01          SUBS     r10,r0,r1
000020  d401              BMI      |L1.38|
000022  4651              MOV      r1,r10
000024  e001              B        |L1.42|
                  |L1.38|
000026  f1ca0100          RSB      r1,r10,#0
                  |L1.42|
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       __aeabi_i2f
000030  4683              MOV      r11,r0
000032  f04f418f          MOV      r1,#0x47800000
000036  f7fffffe          BL       __aeabi_fdiv
00003a  4680              MOV      r8,r0
;;;1411           if (st_shift[jj]) {
00003c  f85d0024          LDR      r0,[sp,r4,LSL #2]
000040  2100              MOVS     r1,#0
000042  f7fffffe          BL       __aeabi_cfcmpeq
000046  d016              BEQ      |L1.118|
;;;1412               st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
000048  f85d1024          LDR      r1,[sp,r4,LSL #2]
00004c  4640              MOV      r0,r8
00004e  f7fffffe          BL       __aeabi_fdiv
000052  4682              MOV      r10,r0
000054  f04f517e          MOV      r1,#0x3f800000
000058  f7fffffe          BL       __aeabi_fsub
00005c  4681              MOV      r9,r0
;;;1413               if (fabs(st_shift_var) > test.max_accel_var)
00005e  f0294a00          BIC      r10,r9,#0x80000000
000062  480f              LDR      r0,|L1.160|
000064  6a41              LDR      r1,[r0,#0x24]  ; test
000066  4650              MOV      r0,r10
000068  f7fffffe          BL       __aeabi_cfrcmple
00006c  d212              BCS      |L1.148|
;;;1414                   result |= 1 << jj;
00006e  2001              MOVS     r0,#1
000070  40a0              LSLS     r0,r0,r4
000072  4305              ORRS     r5,r5,r0
000074  e00e              B        |L1.148|
                  |L1.118|
;;;1415           } else if ((st_shift_cust < test.min_g) ||
000076  480a              LDR      r0,|L1.160|
000078  69c1              LDR      r1,[r0,#0x1c]  ; test
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       __aeabi_cfcmple
000080  d305              BCC      |L1.142|
;;;1416               (st_shift_cust > test.max_g))
000082  4807              LDR      r0,|L1.160|
000084  6a01              LDR      r1,[r0,#0x20]  ; test
000086  4640              MOV      r0,r8
000088  f7fffffe          BL       __aeabi_cfrcmple
00008c  d202              BCS      |L1.148|
                  |L1.142|
;;;1417               result |= 1 << jj;
00008e  2001              MOVS     r0,#1
000090  40a0              LSLS     r0,r0,r4
000092  4305              ORRS     r5,r5,r0
                  |L1.148|
000094  1c64              ADDS     r4,r4,#1              ;1409
                  |L1.150|
000096  2c03              CMP      r4,#3                 ;1409
000098  dbbc              BLT      |L1.20|
;;;1418       }
;;;1419   
;;;1420       return result;
00009a  4628              MOV      r0,r5
;;;1421   }
00009c  e8bd8ffe          POP      {r1-r11,pc}
;;;1422   
                          ENDP

                  |L1.160|
                          DCD      test

                          AREA ||i.get_accel_prod_shift||, CODE, READONLY, ALIGN=2

                  get_accel_prod_shift PROC
;;;1377   #ifdef MPU6050
;;;1378   static int get_accel_prod_shift(float *st_shift)
000000  b57c              PUSH     {r2-r6,lr}
;;;1379   {
000002  4605              MOV      r5,r0
;;;1380       unsigned char tmp[4], shift_code[3], ii;
;;;1381   
;;;1382       if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
000004  4928              LDR      r1,|L2.168|
000006  6849              LDR      r1,[r1,#4]  ; st
000008  7808              LDRB     r0,[r1,#0]
00000a  ab01              ADD      r3,sp,#4
00000c  2204              MOVS     r2,#4
00000e  210d              MOVS     r1,#0xd
000010  f7fffffe          BL       i2c_read
000014  b108              CBZ      r0,|L2.26|
;;;1383           return 0x07;
000016  2007              MOVS     r0,#7
                  |L2.24|
;;;1384   
;;;1385       shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
;;;1386       shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
;;;1387       shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
;;;1388       for (ii = 0; ii < 3; ii++) {
;;;1389           if (!shift_code[ii]) {
;;;1390               st_shift[ii] = 0.f;
;;;1391               continue;
;;;1392           }
;;;1393           /* Equivalent to..
;;;1394            * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
;;;1395            */
;;;1396           st_shift[ii] = 0.34f;
;;;1397           while (--shift_code[ii])
;;;1398               st_shift[ii] *= 1.034f;
;;;1399       }
;;;1400       return 0;
;;;1401   }
000018  bd7c              POP      {r2-r6,pc}
                  |L2.26|
00001a  f89d0007          LDRB     r0,[sp,#7]            ;1385
00001e  f3c01001          UBFX     r0,r0,#4,#2           ;1385
000022  f89d1004          LDRB     r1,[sp,#4]            ;1385
000026  f00101e0          AND      r1,r1,#0xe0           ;1385
00002a  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1385
00002e  f88d0000          STRB     r0,[sp,#0]            ;1385
000032  f89d0007          LDRB     r0,[sp,#7]            ;1386
000036  f3c00081          UBFX     r0,r0,#2,#2           ;1386
00003a  f89d1005          LDRB     r1,[sp,#5]            ;1386
00003e  f00101e0          AND      r1,r1,#0xe0           ;1386
000042  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1386
000046  f88d0001          STRB     r0,[sp,#1]            ;1386
00004a  f89d0007          LDRB     r0,[sp,#7]            ;1387
00004e  f0000003          AND      r0,r0,#3              ;1387
000052  f89d1006          LDRB     r1,[sp,#6]            ;1387
000056  f00101e0          AND      r1,r1,#0xe0           ;1387
00005a  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1387
00005e  f88d0002          STRB     r0,[sp,#2]            ;1387
000062  2400              MOVS     r4,#0                 ;1388
000064  e01c              B        |L2.160|
                  |L2.102|
000066  f81d0004          LDRB     r0,[sp,r4]            ;1389
00006a  b918              CBNZ     r0,|L2.116|
00006c  2000              MOVS     r0,#0                 ;1390
00006e  f8450024          STR      r0,[r5,r4,LSL #2]     ;1390
000072  e013              B        |L2.156|
                  |L2.116|
000074  480d              LDR      r0,|L2.172|
000076  f8450024          STR      r0,[r5,r4,LSL #2]     ;1396
00007a  e006              B        |L2.138|
                  |L2.124|
00007c  f8550024          LDR      r0,[r5,r4,LSL #2]     ;1398
000080  490b              LDR      r1,|L2.176|
000082  f7fffffe          BL       __aeabi_fmul
000086  f8450024          STR      r0,[r5,r4,LSL #2]     ;1398
                  |L2.138|
00008a  f81d0004          LDRB     r0,[sp,r4]            ;1397
00008e  1e40              SUBS     r0,r0,#1              ;1397
000090  f01000ff          ANDS     r0,r0,#0xff           ;1397
000094  f80d0004          STRB     r0,[sp,r4]            ;1397
000098  d1f0              BNE      |L2.124|
00009a  bf00              NOP                            ;1391
                  |L2.156|
00009c  1c60              ADDS     r0,r4,#1              ;1388
00009e  b2c4              UXTB     r4,r0                 ;1388
                  |L2.160|
0000a0  2c03              CMP      r4,#3                 ;1388
0000a2  dbe0              BLT      |L2.102|
0000a4  2000              MOVS     r0,#0                 ;1400
0000a6  e7b7              B        |L2.24|
;;;1402   
                          ENDP

                  |L2.168|
                          DCD      ||st||
                  |L2.172|
                          DCD      0x3eae147b
                  |L2.176|
                          DCD      0x3f845a1d

                          AREA ||i.get_st_biases||, CODE, READONLY, ALIGN=2

                  get_st_biases PROC
;;;1454   
;;;1455   static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1456   {
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4691              MOV      r9,r2
;;;1457       unsigned char data[MAX_PACKET_LENGTH];
;;;1458       unsigned char packet_count, ii;
;;;1459       unsigned short fifo_count;
;;;1460   
;;;1461       data[0] = 0x01;
00000c  2001              MOVS     r0,#1
00000e  f88d0010          STRB     r0,[sp,#0x10]
;;;1462       data[1] = 0;
000012  2000              MOVS     r0,#0
000014  f88d0011          STRB     r0,[sp,#0x11]
;;;1463       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
000018  4afe              LDR      r2,|L3.1044|
00001a  6812              LDR      r2,[r2,#0]  ; st
00001c  7c91              LDRB     r1,[r2,#0x12]
00001e  4afd              LDR      r2,|L3.1044|
000020  6852              LDR      r2,[r2,#4]  ; st
000022  7810              LDRB     r0,[r2,#0]
000024  ab04              ADD      r3,sp,#0x10
000026  2202              MOVS     r2,#2
000028  f7fffffe          BL       i2c_write
00002c  b120              CBZ      r0,|L3.56|
;;;1464           return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L3.50|
;;;1465       Timer_Delayms(200);
;;;1466       data[0] = 0;
;;;1467       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;1468           return -1;
;;;1469       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;1470           return -1;
;;;1471       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;1472           return -1;
;;;1473       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
;;;1474           return -1;
;;;1475       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;1476           return -1;
;;;1477       data[0] = BIT_FIFO_RST | BIT_DMP_RST;
;;;1478       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;1479           return -1;
;;;1480       Timer_Delayms(15);
;;;1481       data[0] = st.test->reg_lpf;
;;;1482       if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;1483           return -1;
;;;1484       data[0] = st.test->reg_rate_div;
;;;1485       if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
;;;1486           return -1;
;;;1487       if (hw_test)
;;;1488           data[0] = st.test->reg_gyro_fsr | 0xE0;
;;;1489       else
;;;1490           data[0] = st.test->reg_gyro_fsr;
;;;1491       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
;;;1492           return -1;
;;;1493   
;;;1494       if (hw_test)
;;;1495           data[0] = st.test->reg_accel_fsr | 0xE0;
;;;1496       else
;;;1497           data[0] = test.reg_accel_fsr;
;;;1498       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;1499           return -1;
;;;1500       if (hw_test)
;;;1501           Timer_Delayms(200);
;;;1502   
;;;1503       /* Fill FIFO for test.wait_ms milliseconds. */
;;;1504       data[0] = BIT_FIFO_EN;
;;;1505       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;1506           return -1;
;;;1507   
;;;1508       data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
;;;1509       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;1510           return -1;
;;;1511       Timer_Delayms(test.wait_ms);
;;;1512       data[0] = 0;
;;;1513       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;1514           return -1;
;;;1515   
;;;1516       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;1517           return -1;
;;;1518   
;;;1519       fifo_count = (data[0] << 8) | data[1];
;;;1520       packet_count = fifo_count / MAX_PACKET_LENGTH;
;;;1521       gyro[0] = gyro[1] = gyro[2] = 0;
;;;1522       accel[0] = accel[1] = accel[2] = 0;
;;;1523   
;;;1524       for (ii = 0; ii < packet_count; ii++) {
;;;1525           short accel_cur[3], gyro_cur[3];
;;;1526           if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
;;;1527               return -1;
;;;1528           accel_cur[0] = ((short)data[0] << 8) | data[1];
;;;1529           accel_cur[1] = ((short)data[2] << 8) | data[3];
;;;1530           accel_cur[2] = ((short)data[4] << 8) | data[5];
;;;1531           accel[0] += (long)accel_cur[0];
;;;1532           accel[1] += (long)accel_cur[1];
;;;1533           accel[2] += (long)accel_cur[2];
;;;1534           gyro_cur[0] = (((short)data[6] << 8) | data[7]);
;;;1535           gyro_cur[1] = (((short)data[8] << 8) | data[9]);
;;;1536           gyro_cur[2] = (((short)data[10] << 8) | data[11]);
;;;1537           gyro[0] += (long)gyro_cur[0];
;;;1538           gyro[1] += (long)gyro_cur[1];
;;;1539           gyro[2] += (long)gyro_cur[2];
;;;1540       }
;;;1541   #ifdef EMPL_NO_64BIT
;;;1542       gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
;;;1543       gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
;;;1544       gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
;;;1545       if (has_accel) {
;;;1546           accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
;;;1547               packet_count);
;;;1548           accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
;;;1549               packet_count);
;;;1550           accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
;;;1551               packet_count);
;;;1552           /* Don't remove gravity! */
;;;1553           accel[2] -= 65536L;
;;;1554       }
;;;1555   #else
;;;1556       gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
;;;1557       gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
;;;1558       gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
;;;1559       accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
;;;1560           packet_count);
;;;1561       accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
;;;1562           packet_count);
;;;1563       accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
;;;1564           packet_count);
;;;1565       /* Don't remove gravity! */
;;;1566       if (accel[2] > 0L)
;;;1567           accel[2] -= 65536L;
;;;1568       else
;;;1569           accel[2] += 65536L;
;;;1570   #endif
;;;1571   
;;;1572       return 0;
;;;1573   }
000032  b007              ADD      sp,sp,#0x1c
000034  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.56|
000038  20c8              MOVS     r0,#0xc8              ;1465
00003a  f7fffffe          BL       Timer_Delayms
00003e  2000              MOVS     r0,#0                 ;1466
000040  f88d0010          STRB     r0,[sp,#0x10]         ;1466
000044  4af3              LDR      r2,|L3.1044|
000046  6812              LDR      r2,[r2,#0]            ;1467  ; st
000048  7bd1              LDRB     r1,[r2,#0xf]          ;1467
00004a  4af2              LDR      r2,|L3.1044|
00004c  6852              LDR      r2,[r2,#4]            ;1467  ; st
00004e  7810              LDRB     r0,[r2,#0]            ;1467
000050  ab04              ADD      r3,sp,#0x10           ;1467
000052  2201              MOVS     r2,#1                 ;1467
000054  f7fffffe          BL       i2c_write
000058  b110              CBZ      r0,|L3.96|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;1468
00005e  e7e8              B        |L3.50|
                  |L3.96|
000060  4aec              LDR      r2,|L3.1044|
000062  6812              LDR      r2,[r2,#0]            ;1469  ; st
000064  7951              LDRB     r1,[r2,#5]            ;1469
000066  4aeb              LDR      r2,|L3.1044|
000068  6852              LDR      r2,[r2,#4]            ;1469  ; st
00006a  7810              LDRB     r0,[r2,#0]            ;1469
00006c  ab04              ADD      r3,sp,#0x10           ;1469
00006e  2201              MOVS     r2,#1                 ;1469
000070  f7fffffe          BL       i2c_write
000074  b110              CBZ      r0,|L3.124|
000076  f04f30ff          MOV      r0,#0xffffffff        ;1470
00007a  e7da              B        |L3.50|
                  |L3.124|
00007c  4ae5              LDR      r2,|L3.1044|
00007e  6812              LDR      r2,[r2,#0]            ;1471  ; st
000080  7c91              LDRB     r1,[r2,#0x12]         ;1471
000082  4ae4              LDR      r2,|L3.1044|
000084  6852              LDR      r2,[r2,#4]            ;1471  ; st
000086  7810              LDRB     r0,[r2,#0]            ;1471
000088  ab04              ADD      r3,sp,#0x10           ;1471
00008a  2201              MOVS     r2,#1                 ;1471
00008c  f7fffffe          BL       i2c_write
000090  b110              CBZ      r0,|L3.152|
000092  f04f30ff          MOV      r0,#0xffffffff        ;1472
000096  e7cc              B        |L3.50|
                  |L3.152|
000098  4ade              LDR      r2,|L3.1044|
00009a  6812              LDR      r2,[r2,#0]            ;1473  ; st
00009c  7dd1              LDRB     r1,[r2,#0x17]         ;1473
00009e  4add              LDR      r2,|L3.1044|
0000a0  6852              LDR      r2,[r2,#4]            ;1473  ; st
0000a2  7810              LDRB     r0,[r2,#0]            ;1473
0000a4  ab04              ADD      r3,sp,#0x10           ;1473
0000a6  2201              MOVS     r2,#1                 ;1473
0000a8  f7fffffe          BL       i2c_write
0000ac  b110              CBZ      r0,|L3.180|
0000ae  f04f30ff          MOV      r0,#0xffffffff        ;1474
0000b2  e7be              B        |L3.50|
                  |L3.180|
0000b4  4ad7              LDR      r2,|L3.1044|
0000b6  6812              LDR      r2,[r2,#0]            ;1475  ; st
0000b8  7911              LDRB     r1,[r2,#4]            ;1475
0000ba  4ad6              LDR      r2,|L3.1044|
0000bc  6852              LDR      r2,[r2,#4]            ;1475  ; st
0000be  7810              LDRB     r0,[r2,#0]            ;1475
0000c0  ab04              ADD      r3,sp,#0x10           ;1475
0000c2  2201              MOVS     r2,#1                 ;1475
0000c4  f7fffffe          BL       i2c_write
0000c8  b110              CBZ      r0,|L3.208|
0000ca  f04f30ff          MOV      r0,#0xffffffff        ;1476
0000ce  e7b0              B        |L3.50|
                  |L3.208|
0000d0  200c              MOVS     r0,#0xc               ;1477
0000d2  f88d0010          STRB     r0,[sp,#0x10]         ;1477
0000d6  4acf              LDR      r2,|L3.1044|
0000d8  6812              LDR      r2,[r2,#0]            ;1478  ; st
0000da  7911              LDRB     r1,[r2,#4]            ;1478
0000dc  4acd              LDR      r2,|L3.1044|
0000de  6852              LDR      r2,[r2,#4]            ;1478  ; st
0000e0  7810              LDRB     r0,[r2,#0]            ;1478
0000e2  ab04              ADD      r3,sp,#0x10           ;1478
0000e4  2201              MOVS     r2,#1                 ;1478
0000e6  f7fffffe          BL       i2c_write
0000ea  b110              CBZ      r0,|L3.242|
0000ec  f04f30ff          MOV      r0,#0xffffffff        ;1479
0000f0  e79f              B        |L3.50|
                  |L3.242|
0000f2  200f              MOVS     r0,#0xf               ;1480
0000f4  f7fffffe          BL       Timer_Delayms
0000f8  48c6              LDR      r0,|L3.1044|
0000fa  6a80              LDR      r0,[r0,#0x28]         ;1481  ; st
0000fc  7a40              LDRB     r0,[r0,#9]            ;1481
0000fe  f88d0010          STRB     r0,[sp,#0x10]         ;1481
000102  4ac4              LDR      r2,|L3.1044|
000104  6812              LDR      r2,[r2,#0]            ;1482  ; st
000106  7891              LDRB     r1,[r2,#2]            ;1482
000108  4ac2              LDR      r2,|L3.1044|
00010a  6852              LDR      r2,[r2,#4]            ;1482  ; st
00010c  7810              LDRB     r0,[r2,#0]            ;1482
00010e  ab04              ADD      r3,sp,#0x10           ;1482
000110  2201              MOVS     r2,#1                 ;1482
000112  f7fffffe          BL       i2c_write
000116  b110              CBZ      r0,|L3.286|
000118  f04f30ff          MOV      r0,#0xffffffff        ;1483
00011c  e789              B        |L3.50|
                  |L3.286|
00011e  48bd              LDR      r0,|L3.1044|
000120  6a80              LDR      r0,[r0,#0x28]         ;1484  ; st
000122  7a00              LDRB     r0,[r0,#8]            ;1484
000124  f88d0010          STRB     r0,[sp,#0x10]         ;1484
000128  4aba              LDR      r2,|L3.1044|
00012a  6812              LDR      r2,[r2,#0]            ;1485  ; st
00012c  7851              LDRB     r1,[r2,#1]            ;1485
00012e  4ab9              LDR      r2,|L3.1044|
000130  6852              LDR      r2,[r2,#4]            ;1485  ; st
000132  7810              LDRB     r0,[r2,#0]            ;1485
000134  ab04              ADD      r3,sp,#0x10           ;1485
000136  2201              MOVS     r2,#1                 ;1485
000138  f7fffffe          BL       i2c_write
00013c  b110              CBZ      r0,|L3.324|
00013e  f04f30ff          MOV      r0,#0xffffffff        ;1486
000142  e776              B        |L3.50|
                  |L3.324|
000144  f1b90f00          CMP      r9,#0                 ;1487
000148  d007              BEQ      |L3.346|
00014a  48b2              LDR      r0,|L3.1044|
00014c  6a80              LDR      r0,[r0,#0x28]         ;1488  ; st
00014e  7a80              LDRB     r0,[r0,#0xa]          ;1488
000150  f04000e0          ORR      r0,r0,#0xe0           ;1488
000154  f88d0010          STRB     r0,[sp,#0x10]         ;1488
000158  e004              B        |L3.356|
                  |L3.346|
00015a  48ae              LDR      r0,|L3.1044|
00015c  6a80              LDR      r0,[r0,#0x28]         ;1490  ; st
00015e  7a80              LDRB     r0,[r0,#0xa]          ;1490
000160  f88d0010          STRB     r0,[sp,#0x10]         ;1490
                  |L3.356|
000164  4aab              LDR      r2,|L3.1044|
000166  6812              LDR      r2,[r2,#0]            ;1491  ; st
000168  7991              LDRB     r1,[r2,#6]            ;1491
00016a  4aaa              LDR      r2,|L3.1044|
00016c  6852              LDR      r2,[r2,#4]            ;1491  ; st
00016e  7810              LDRB     r0,[r2,#0]            ;1491
000170  ab04              ADD      r3,sp,#0x10           ;1491
000172  2201              MOVS     r2,#1                 ;1491
000174  f7fffffe          BL       i2c_write
000178  b110              CBZ      r0,|L3.384|
00017a  f04f30ff          MOV      r0,#0xffffffff        ;1492
00017e  e758              B        |L3.50|
                  |L3.384|
000180  f1b90f00          CMP      r9,#0                 ;1494
000184  d007              BEQ      |L3.406|
000186  48a3              LDR      r0,|L3.1044|
000188  6a80              LDR      r0,[r0,#0x28]         ;1495  ; st
00018a  7ac0              LDRB     r0,[r0,#0xb]          ;1495
00018c  f04000e0          ORR      r0,r0,#0xe0           ;1495
000190  f88d0010          STRB     r0,[sp,#0x10]         ;1495
000194  e003              B        |L3.414|
                  |L3.406|
000196  48a0              LDR      r0,|L3.1048|
000198  7ac0              LDRB     r0,[r0,#0xb]          ;1497  ; test
00019a  f88d0010          STRB     r0,[sp,#0x10]         ;1497
                  |L3.414|
00019e  4a9d              LDR      r2,|L3.1044|
0001a0  6812              LDR      r2,[r2,#0]            ;1498  ; st
0001a2  79d1              LDRB     r1,[r2,#7]            ;1498
0001a4  4a9b              LDR      r2,|L3.1044|
0001a6  6852              LDR      r2,[r2,#4]            ;1498  ; st
0001a8  7810              LDRB     r0,[r2,#0]            ;1498
0001aa  ab04              ADD      r3,sp,#0x10           ;1498
0001ac  2201              MOVS     r2,#1                 ;1498
0001ae  f7fffffe          BL       i2c_write
0001b2  b110              CBZ      r0,|L3.442|
0001b4  f04f30ff          MOV      r0,#0xffffffff        ;1499
0001b8  e73b              B        |L3.50|
                  |L3.442|
0001ba  f1b90f00          CMP      r9,#0                 ;1500
0001be  d002              BEQ      |L3.454|
0001c0  20c8              MOVS     r0,#0xc8              ;1501
0001c2  f7fffffe          BL       Timer_Delayms
                  |L3.454|
0001c6  2040              MOVS     r0,#0x40              ;1504
0001c8  f88d0010          STRB     r0,[sp,#0x10]         ;1504
0001cc  4a91              LDR      r2,|L3.1044|
0001ce  6812              LDR      r2,[r2,#0]            ;1505  ; st
0001d0  7911              LDRB     r1,[r2,#4]            ;1505
0001d2  4a90              LDR      r2,|L3.1044|
0001d4  6852              LDR      r2,[r2,#4]            ;1505  ; st
0001d6  7810              LDRB     r0,[r2,#0]            ;1505
0001d8  ab04              ADD      r3,sp,#0x10           ;1505
0001da  2201              MOVS     r2,#1                 ;1505
0001dc  f7fffffe          BL       i2c_write
0001e0  b110              CBZ      r0,|L3.488|
0001e2  f04f30ff          MOV      r0,#0xffffffff        ;1506
0001e6  e724              B        |L3.50|
                  |L3.488|
0001e8  2078              MOVS     r0,#0x78              ;1508
0001ea  f88d0010          STRB     r0,[sp,#0x10]         ;1508
0001ee  4a89              LDR      r2,|L3.1044|
0001f0  6812              LDR      r2,[r2,#0]            ;1509  ; st
0001f2  7951              LDRB     r1,[r2,#5]            ;1509
0001f4  4a87              LDR      r2,|L3.1044|
0001f6  6852              LDR      r2,[r2,#4]            ;1509  ; st
0001f8  7810              LDRB     r0,[r2,#0]            ;1509
0001fa  ab04              ADD      r3,sp,#0x10           ;1509
0001fc  2201              MOVS     r2,#1                 ;1509
0001fe  f7fffffe          BL       i2c_write
000202  b110              CBZ      r0,|L3.522|
000204  f04f30ff          MOV      r0,#0xffffffff        ;1510
000208  e713              B        |L3.50|
                  |L3.522|
00020a  4983              LDR      r1,|L3.1048|
00020c  8988              LDRH     r0,[r1,#0xc]          ;1511  ; test
00020e  f7fffffe          BL       Timer_Delayms
000212  2000              MOVS     r0,#0                 ;1512
000214  f88d0010          STRB     r0,[sp,#0x10]         ;1512
000218  4a7e              LDR      r2,|L3.1044|
00021a  6812              LDR      r2,[r2,#0]            ;1513  ; st
00021c  7951              LDRB     r1,[r2,#5]            ;1513
00021e  4a7d              LDR      r2,|L3.1044|
000220  6852              LDR      r2,[r2,#4]            ;1513  ; st
000222  7810              LDRB     r0,[r2,#0]            ;1513
000224  ab04              ADD      r3,sp,#0x10           ;1513
000226  2201              MOVS     r2,#1                 ;1513
000228  f7fffffe          BL       i2c_write
00022c  b110              CBZ      r0,|L3.564|
00022e  f04f30ff          MOV      r0,#0xffffffff        ;1514
000232  e6fe              B        |L3.50|
                  |L3.564|
000234  4a77              LDR      r2,|L3.1044|
000236  6812              LDR      r2,[r2,#0]            ;1516  ; st
000238  7a91              LDRB     r1,[r2,#0xa]          ;1516
00023a  4a76              LDR      r2,|L3.1044|
00023c  6852              LDR      r2,[r2,#4]            ;1516  ; st
00023e  7810              LDRB     r0,[r2,#0]            ;1516
000240  ab04              ADD      r3,sp,#0x10           ;1516
000242  2202              MOVS     r2,#2                 ;1516
000244  f7fffffe          BL       i2c_read
000248  b110              CBZ      r0,|L3.592|
00024a  f04f30ff          MOV      r0,#0xffffffff        ;1517
00024e  e6f0              B        |L3.50|
                  |L3.592|
000250  f89d0011          LDRB     r0,[sp,#0x11]         ;1519
000254  f89d1010          LDRB     r1,[sp,#0x10]         ;1519
000258  ea402b01          ORR      r11,r0,r1,LSL #8      ;1519
00025c  200c              MOVS     r0,#0xc               ;1520
00025e  fb9bf0f0          SDIV     r0,r11,r0             ;1520
000262  b2c6              UXTB     r6,r0                 ;1520
000264  2000              MOVS     r0,#0                 ;1521
000266  60a8              STR      r0,[r5,#8]            ;1521
000268  6068              STR      r0,[r5,#4]            ;1521
00026a  6028              STR      r0,[r5,#0]            ;1521
00026c  60a0              STR      r0,[r4,#8]            ;1522
00026e  6060              STR      r0,[r4,#4]            ;1522
000270  6020              STR      r0,[r4,#0]            ;1522
000272  4682              MOV      r10,r0                ;1524
000274  e065              B        |L3.834|
                  |L3.630|
000276  4a67              LDR      r2,|L3.1044|
000278  6812              LDR      r2,[r2,#0]            ;1526  ; st
00027a  7ad1              LDRB     r1,[r2,#0xb]          ;1526
00027c  4a65              LDR      r2,|L3.1044|
00027e  6852              LDR      r2,[r2,#4]            ;1526  ; st
000280  7810              LDRB     r0,[r2,#0]            ;1526
000282  ab04              ADD      r3,sp,#0x10           ;1526
000284  220c              MOVS     r2,#0xc               ;1526
000286  f7fffffe          BL       i2c_read
00028a  b110              CBZ      r0,|L3.658|
00028c  f04f30ff          MOV      r0,#0xffffffff        ;1527
000290  e6cf              B        |L3.50|
                  |L3.658|
000292  f89d0011          LDRB     r0,[sp,#0x11]         ;1528
000296  f89d1010          LDRB     r1,[sp,#0x10]         ;1528
00029a  ea402001          ORR      r0,r0,r1,LSL #8       ;1528
00029e  b200              SXTH     r0,r0                 ;1528
0002a0  f8ad0008          STRH     r0,[sp,#8]            ;1528
0002a4  f89d0013          LDRB     r0,[sp,#0x13]         ;1529
0002a8  f89d1012          LDRB     r1,[sp,#0x12]         ;1529
0002ac  ea402001          ORR      r0,r0,r1,LSL #8       ;1529
0002b0  b200              SXTH     r0,r0                 ;1529
0002b2  f8ad000a          STRH     r0,[sp,#0xa]          ;1529
0002b6  f89d0015          LDRB     r0,[sp,#0x15]         ;1530
0002ba  f89d1014          LDRB     r1,[sp,#0x14]         ;1530
0002be  ea402001          ORR      r0,r0,r1,LSL #8       ;1530
0002c2  b200              SXTH     r0,r0                 ;1530
0002c4  f8ad000c          STRH     r0,[sp,#0xc]          ;1530
0002c8  f9bd1008          LDRSH    r1,[sp,#8]            ;1531
0002cc  6820              LDR      r0,[r4,#0]            ;1531
0002ce  4408              ADD      r0,r0,r1              ;1531
0002d0  6020              STR      r0,[r4,#0]            ;1531
0002d2  f9bd100a          LDRSH    r1,[sp,#0xa]          ;1532
0002d6  6860              LDR      r0,[r4,#4]            ;1532
0002d8  4408              ADD      r0,r0,r1              ;1532
0002da  6060              STR      r0,[r4,#4]            ;1532
0002dc  f9bd100c          LDRSH    r1,[sp,#0xc]          ;1533
0002e0  68a0              LDR      r0,[r4,#8]            ;1533
0002e2  4408              ADD      r0,r0,r1              ;1533
0002e4  60a0              STR      r0,[r4,#8]            ;1533
0002e6  f89d0017          LDRB     r0,[sp,#0x17]         ;1534
0002ea  f89d1016          LDRB     r1,[sp,#0x16]         ;1534
0002ee  ea402001          ORR      r0,r0,r1,LSL #8       ;1534
0002f2  b200              SXTH     r0,r0                 ;1534
0002f4  f8ad0000          STRH     r0,[sp,#0]            ;1534
0002f8  f89d0019          LDRB     r0,[sp,#0x19]         ;1535
0002fc  f89d1018          LDRB     r1,[sp,#0x18]         ;1535
000300  ea402001          ORR      r0,r0,r1,LSL #8       ;1535
000304  b200              SXTH     r0,r0                 ;1535
000306  f8ad0002          STRH     r0,[sp,#2]            ;1535
00030a  f89d001b          LDRB     r0,[sp,#0x1b]         ;1536
00030e  f89d101a          LDRB     r1,[sp,#0x1a]         ;1536
000312  ea402001          ORR      r0,r0,r1,LSL #8       ;1536
000316  b200              SXTH     r0,r0                 ;1536
000318  f8ad0004          STRH     r0,[sp,#4]            ;1536
00031c  f9bd1000          LDRSH    r1,[sp,#0]            ;1537
000320  6828              LDR      r0,[r5,#0]            ;1537
000322  4408              ADD      r0,r0,r1              ;1537
000324  6028              STR      r0,[r5,#0]            ;1537
000326  f9bd1002          LDRSH    r1,[sp,#2]            ;1538
00032a  6868              LDR      r0,[r5,#4]            ;1538
00032c  4408              ADD      r0,r0,r1              ;1538
00032e  6068              STR      r0,[r5,#4]            ;1538
000330  f9bd1004          LDRSH    r1,[sp,#4]            ;1539
000334  68a8              LDR      r0,[r5,#8]            ;1539
000336  4408              ADD      r0,r0,r1              ;1539
000338  60a8              STR      r0,[r5,#8]            ;1539
00033a  f10a0001          ADD      r0,r10,#1             ;1524
00033e  f0000aff          AND      r10,r0,#0xff          ;1524
                  |L3.834|
000342  45b2              CMP      r10,r6                ;1524
000344  db97              BLT      |L3.630|
000346  4834              LDR      r0,|L3.1048|
000348  f8d0c000          LDR      r12,[r0,#0]           ;1556  ; test
00034c  6828              LDR      r0,[r5,#0]            ;1556
00034e  17c1              ASRS     r1,r0,#31             ;1556
000350  0409              LSLS     r1,r1,#16             ;1556
000352  ea414110          ORR      r1,r1,r0,LSR #16      ;1556
000356  0407              LSLS     r7,r0,#16             ;1556
000358  4662              MOV      r2,r12                ;1556
00035a  2300              MOVS     r3,#0                 ;1556
00035c  4638              MOV      r0,r7                 ;1556
00035e  f7fffffe          BL       __aeabi_ldivmod
000362  4632              MOV      r2,r6                 ;1556
000364  2300              MOVS     r3,#0                 ;1556
000366  e9cd0102          STRD     r0,r1,[sp,#8]         ;1556
00036a  f7fffffe          BL       __aeabi_ldivmod
00036e  6028              STR      r0,[r5,#0]            ;1556
000370  4829              LDR      r0,|L3.1048|
000372  f8d0c000          LDR      r12,[r0,#0]           ;1557  ; test
000376  6868              LDR      r0,[r5,#4]            ;1557
000378  17c1              ASRS     r1,r0,#31             ;1557
00037a  0409              LSLS     r1,r1,#16             ;1557
00037c  ea414110          ORR      r1,r1,r0,LSR #16      ;1557
000380  0407              LSLS     r7,r0,#16             ;1557
000382  4662              MOV      r2,r12                ;1557
000384  2300              MOVS     r3,#0                 ;1557
000386  4638              MOV      r0,r7                 ;1557
000388  f7fffffe          BL       __aeabi_ldivmod
00038c  4632              MOV      r2,r6                 ;1557
00038e  2300              MOVS     r3,#0                 ;1557
000390  e9cd0102          STRD     r0,r1,[sp,#8]         ;1557
000394  f7fffffe          BL       __aeabi_ldivmod
000398  6068              STR      r0,[r5,#4]            ;1557
00039a  481f              LDR      r0,|L3.1048|
00039c  f8d0c000          LDR      r12,[r0,#0]           ;1558  ; test
0003a0  68a8              LDR      r0,[r5,#8]            ;1558
0003a2  17c1              ASRS     r1,r0,#31             ;1558
0003a4  0409              LSLS     r1,r1,#16             ;1558
0003a6  ea414110          ORR      r1,r1,r0,LSR #16      ;1558
0003aa  0407              LSLS     r7,r0,#16             ;1558
0003ac  4662              MOV      r2,r12                ;1558
0003ae  2300              MOVS     r3,#0                 ;1558
0003b0  4638              MOV      r0,r7                 ;1558
0003b2  f7fffffe          BL       __aeabi_ldivmod
0003b6  4632              MOV      r2,r6                 ;1558
0003b8  2300              MOVS     r3,#0                 ;1558
0003ba  e9cd0102          STRD     r0,r1,[sp,#8]         ;1558
0003be  f7fffffe          BL       __aeabi_ldivmod
0003c2  60a8              STR      r0,[r5,#8]            ;1558
0003c4  4814              LDR      r0,|L3.1048|
0003c6  f8d0c004          LDR      r12,[r0,#4]           ;1559  ; test
0003ca  6821              LDR      r1,[r4,#0]            ;1559
0003cc  17c8              ASRS     r0,r1,#31             ;1559
0003ce  0400              LSLS     r0,r0,#16             ;1559
0003d0  ea404811          ORR      r8,r0,r1,LSR #16      ;1559
0003d4  040f              LSLS     r7,r1,#16             ;1559
0003d6  4662              MOV      r2,r12                ;1559
0003d8  2300              MOVS     r3,#0                 ;1559
0003da  4638              MOV      r0,r7                 ;1559
0003dc  4641              MOV      r1,r8                 ;1559
0003de  f7fffffe          BL       __aeabi_ldivmod
0003e2  4632              MOV      r2,r6                 ;1559
0003e4  2300              MOVS     r3,#0                 ;1559
0003e6  e9cd0102          STRD     r0,r1,[sp,#8]         ;1559
0003ea  f7fffffe          BL       __aeabi_ldivmod
0003ee  6020              STR      r0,[r4,#0]            ;1559
0003f0  4809              LDR      r0,|L3.1048|
0003f2  f8d0c004          LDR      r12,[r0,#4]           ;1561  ; test
0003f6  6860              LDR      r0,[r4,#4]            ;1561
0003f8  17c1              ASRS     r1,r0,#31             ;1561
0003fa  0409              LSLS     r1,r1,#16             ;1561
0003fc  ea414110          ORR      r1,r1,r0,LSR #16      ;1561
000400  0407              LSLS     r7,r0,#16             ;1561
000402  4662              MOV      r2,r12                ;1561
000404  2300              MOVS     r3,#0                 ;1561
000406  4638              MOV      r0,r7                 ;1561
000408  f7fffffe          BL       __aeabi_ldivmod
00040c  4632              MOV      r2,r6                 ;1561
00040e  2300              MOVS     r3,#0                 ;1561
000410  e004              B        |L3.1052|
000412  0000              DCW      0x0000
                  |L3.1044|
                          DCD      ||st||
                  |L3.1048|
                          DCD      test
                  |L3.1052|
00041c  e9cd0102          STRD     r0,r1,[sp,#8]         ;1561
000420  f7fffffe          BL       __aeabi_ldivmod
000424  6060              STR      r0,[r4,#4]            ;1561
000426  4811              LDR      r0,|L3.1132|
000428  f8d0c004          LDR      r12,[r0,#4]           ;1563  ; test
00042c  68a0              LDR      r0,[r4,#8]            ;1563
00042e  17c1              ASRS     r1,r0,#31             ;1563
000430  0409              LSLS     r1,r1,#16             ;1563
000432  ea414110          ORR      r1,r1,r0,LSR #16      ;1563
000436  0407              LSLS     r7,r0,#16             ;1563
000438  4662              MOV      r2,r12                ;1563
00043a  2300              MOVS     r3,#0                 ;1563
00043c  4638              MOV      r0,r7                 ;1563
00043e  f7fffffe          BL       __aeabi_ldivmod
000442  4632              MOV      r2,r6                 ;1563
000444  2300              MOVS     r3,#0                 ;1563
000446  e9cd0102          STRD     r0,r1,[sp,#8]         ;1563
00044a  f7fffffe          BL       __aeabi_ldivmod
00044e  60a0              STR      r0,[r4,#8]            ;1563
000450  68a0              LDR      r0,[r4,#8]            ;1566
000452  2800              CMP      r0,#0                 ;1566
000454  dd04              BLE      |L3.1120|
000456  68a0              LDR      r0,[r4,#8]            ;1567
000458  f5a03080          SUB      r0,r0,#0x10000        ;1567
00045c  60a0              STR      r0,[r4,#8]            ;1567
00045e  e003              B        |L3.1128|
                  |L3.1120|
000460  68a0              LDR      r0,[r4,#8]            ;1569
000462  f5003080          ADD      r0,r0,#0x10000        ;1569
000466  60a0              STR      r0,[r4,#8]            ;1569
                  |L3.1128|
000468  2000              MOVS     r0,#0                 ;1572
00046a  e5e2              B        |L3.50|
;;;1574   
                          ENDP

                  |L3.1132|
                          DCD      test

                          AREA ||i.gyro_self_test||, CODE, READONLY, ALIGN=2

                  gyro_self_test PROC
;;;1422   
;;;1423   static int gyro_self_test(long *bias_regular, long *bias_st)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1424   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1425       int jj, result = 0;
000008  2500              MOVS     r5,#0
;;;1426       unsigned char tmp[3];
;;;1427       float st_shift, st_shift_cust, st_shift_var;
;;;1428   
;;;1429       if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
00000a  493c              LDR      r1,|L4.252|
00000c  6849              LDR      r1,[r1,#4]  ; st
00000e  7808              LDRB     r0,[r1,#0]
000010  ab01              ADD      r3,sp,#4
000012  2203              MOVS     r2,#3
000014  210d              MOVS     r1,#0xd
000016  f7fffffe          BL       i2c_read
00001a  b110              CBZ      r0,|L4.34|
;;;1430           return 0x07;
00001c  2007              MOVS     r0,#7
                  |L4.30|
;;;1431   
;;;1432       tmp[0] &= 0x1F;
;;;1433       tmp[1] &= 0x1F;
;;;1434       tmp[2] &= 0x1F;
;;;1435   
;;;1436       for (jj = 0; jj < 3; jj++) {
;;;1437           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
;;;1438           if (tmp[jj]) {
;;;1439               st_shift = 3275.f / test.gyro_sens;
;;;1440               while (--tmp[jj])
;;;1441                   st_shift *= 1.046f;
;;;1442               st_shift_var = st_shift_cust / st_shift - 1.f;
;;;1443               if (fabs(st_shift_var) > test.max_gyro_var)
;;;1444                   result |= 1 << jj;
;;;1445           } else if ((st_shift_cust < test.min_dps) ||
;;;1446               (st_shift_cust > test.max_dps))
;;;1447               result |= 1 << jj;
;;;1448       }
;;;1449       return result;
;;;1450   }
00001e  e8bd9ffc          POP      {r2-r12,pc}
                  |L4.34|
000022  f89d0004          LDRB     r0,[sp,#4]            ;1432
000026  f000001f          AND      r0,r0,#0x1f           ;1432
00002a  f88d0004          STRB     r0,[sp,#4]            ;1432
00002e  f89d0005          LDRB     r0,[sp,#5]            ;1433
000032  f000001f          AND      r0,r0,#0x1f           ;1433
000036  f88d0005          STRB     r0,[sp,#5]            ;1433
00003a  f89d0006          LDRB     r0,[sp,#6]            ;1434
00003e  f000001f          AND      r0,r0,#0x1f           ;1434
000042  f88d0006          STRB     r0,[sp,#6]            ;1434
000046  2400              MOVS     r4,#0                 ;1436
000048  e054              B        |L4.244|
                  |L4.74|
00004a  f8560024          LDR      r0,[r6,r4,LSL #2]     ;1437
00004e  f8571024          LDR      r1,[r7,r4,LSL #2]     ;1437
000052  ebb00b01          SUBS     r11,r0,r1             ;1437
000056  d401              BMI      |L4.92|
000058  4659              MOV      r1,r11                ;1437
00005a  e001              B        |L4.96|
                  |L4.92|
00005c  f1cb0100          RSB      r1,r11,#0             ;1437
                  |L4.96|
000060  4608              MOV      r0,r1                 ;1437
000062  f7fffffe          BL       __aeabi_i2f
000066  f04f418f          MOV      r1,#0x47800000        ;1437
00006a  9000              STR      r0,[sp,#0]            ;1437
00006c  f7fffffe          BL       __aeabi_fdiv
000070  4681              MOV      r9,r0                 ;1437
000072  a801              ADD      r0,sp,#4              ;1438
000074  5d00              LDRB     r0,[r0,r4]            ;1438
000076  b368              CBZ      r0,|L4.212|
000078  4921              LDR      r1,|L4.256|
00007a  6808              LDR      r0,[r1,#0]            ;1439  ; test
00007c  f7fffffe          BL       __aeabi_ui2f
000080  4683              MOV      r11,r0                ;1439
000082  4659              MOV      r1,r11                ;1439
000084  481f              LDR      r0,|L4.260|
000086  f7fffffe          BL       __aeabi_fdiv
00008a  4680              MOV      r8,r0                 ;1439
00008c  e004              B        |L4.152|
                  |L4.142|
00008e  491e              LDR      r1,|L4.264|
000090  4640              MOV      r0,r8                 ;1441
000092  f7fffffe          BL       __aeabi_fmul
000096  4680              MOV      r8,r0                 ;1441
                  |L4.152|
000098  a801              ADD      r0,sp,#4              ;1440
00009a  5d00              LDRB     r0,[r0,r4]            ;1440
00009c  1e40              SUBS     r0,r0,#1              ;1440
00009e  f01000ff          ANDS     r0,r0,#0xff           ;1440
0000a2  a901              ADD      r1,sp,#4              ;1440
0000a4  5508              STRB     r0,[r1,r4]            ;1440
0000a6  d1f2              BNE      |L4.142|
0000a8  4641              MOV      r1,r8                 ;1442
0000aa  4648              MOV      r0,r9                 ;1442
0000ac  f7fffffe          BL       __aeabi_fdiv
0000b0  4683              MOV      r11,r0                ;1442
0000b2  f04f517e          MOV      r1,#0x3f800000        ;1442
0000b6  f7fffffe          BL       __aeabi_fsub
0000ba  4682              MOV      r10,r0                ;1442
0000bc  f02a4b00          BIC      r11,r10,#0x80000000   ;1443
0000c0  480f              LDR      r0,|L4.256|
0000c2  6981              LDR      r1,[r0,#0x18]         ;1443  ; test
0000c4  4658              MOV      r0,r11                ;1443
0000c6  f7fffffe          BL       __aeabi_cfrcmple
0000ca  d212              BCS      |L4.242|
0000cc  2001              MOVS     r0,#1                 ;1444
0000ce  40a0              LSLS     r0,r0,r4              ;1444
0000d0  4305              ORRS     r5,r5,r0              ;1444
0000d2  e00e              B        |L4.242|
                  |L4.212|
0000d4  480a              LDR      r0,|L4.256|
0000d6  6901              LDR      r1,[r0,#0x10]         ;1445  ; test
0000d8  4648              MOV      r0,r9                 ;1445
0000da  f7fffffe          BL       __aeabi_cfcmple
0000de  d305              BCC      |L4.236|
0000e0  4807              LDR      r0,|L4.256|
0000e2  6941              LDR      r1,[r0,#0x14]         ;1446  ; test
0000e4  4648              MOV      r0,r9                 ;1446
0000e6  f7fffffe          BL       __aeabi_cfrcmple
0000ea  d202              BCS      |L4.242|
                  |L4.236|
0000ec  2001              MOVS     r0,#1                 ;1447
0000ee  40a0              LSLS     r0,r0,r4              ;1447
0000f0  4305              ORRS     r5,r5,r0              ;1447
                  |L4.242|
0000f2  1c64              ADDS     r4,r4,#1              ;1436
                  |L4.244|
0000f4  2c03              CMP      r4,#3                 ;1436
0000f6  dba8              BLT      |L4.74|
0000f8  4628              MOV      r0,r5                 ;1449
0000fa  e790              B        |L4.30|
;;;1451   
                          ENDP

                  |L4.252|
                          DCD      ||st||
                  |L4.256|
                          DCD      test
                  |L4.260|
                          DCD      0x454cb000
                  |L4.264|
                          DCD      0x3f85e354

                          AREA ||i.mpu_configure_fifo||, CODE, READONLY, ALIGN=2

                  mpu_configure_fifo PROC
;;;1065    */
;;;1066   int mpu_configure_fifo(unsigned char sensors)
000000  b570              PUSH     {r4-r6,lr}
;;;1067   {
000002  4604              MOV      r4,r0
;;;1068       unsigned char prev;
;;;1069       int result = 0;
000004  2600              MOVS     r6,#0
;;;1070   
;;;1071       /* Compass data isn't going into the FIFO. Stop trying. */
;;;1072       sensors &= ~INV_XYZ_COMPASS;
000006  f0240401          BIC      r4,r4,#1
;;;1073   
;;;1074       if (st.chip_cfg.dmp_on)
00000a  4818              LDR      r0,|L5.108|
00000c  f8900024          LDRB     r0,[r0,#0x24]
000010  b108              CBZ      r0,|L5.22|
;;;1075           return 0;
000012  2000              MOVS     r0,#0
                  |L5.20|
;;;1076       else {
;;;1077           if (!(st.chip_cfg.sensors))
;;;1078               return -1;
;;;1079           prev = st.chip_cfg.fifo_enable;
;;;1080           st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
;;;1081           if (st.chip_cfg.fifo_enable != sensors)
;;;1082               /* You're not getting what you asked for. Some sensors are
;;;1083                * asleep.
;;;1084                */
;;;1085               result = -1;
;;;1086           else
;;;1087               result = 0;
;;;1088           if (sensors || st.chip_cfg.lp_accel_mode)
;;;1089               set_int_enable(1);
;;;1090           else
;;;1091               set_int_enable(0);
;;;1092           if (sensors) {
;;;1093               if (mpu_reset_fifo()) {
;;;1094                   st.chip_cfg.fifo_enable = prev;
;;;1095                   return -1;
;;;1096               }
;;;1097           }
;;;1098       }
;;;1099   
;;;1100       return result;
;;;1101   }
000014  bd70              POP      {r4-r6,pc}
                  |L5.22|
000016  4815              LDR      r0,|L5.108|
000018  7a80              LDRB     r0,[r0,#0xa]          ;1077
00001a  b910              CBNZ     r0,|L5.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1078
000020  e7f8              B        |L5.20|
                  |L5.34|
000022  4812              LDR      r0,|L5.108|
000024  7c05              LDRB     r5,[r0,#0x10]         ;1079
000026  7a80              LDRB     r0,[r0,#0xa]          ;1080
000028  4020              ANDS     r0,r0,r4              ;1080
00002a  4910              LDR      r1,|L5.108|
00002c  7408              STRB     r0,[r1,#0x10]         ;1080
00002e  4608              MOV      r0,r1                 ;1081
000030  7c00              LDRB     r0,[r0,#0x10]         ;1081
000032  42a0              CMP      r0,r4                 ;1081
000034  d002              BEQ      |L5.60|
000036  f04f36ff          MOV      r6,#0xffffffff        ;1085
00003a  e000              B        |L5.62|
                  |L5.60|
00003c  2600              MOVS     r6,#0                 ;1087
                  |L5.62|
00003e  b914              CBNZ     r4,|L5.70|
000040  480a              LDR      r0,|L5.108|
000042  7d00              LDRB     r0,[r0,#0x14]         ;1088
000044  b118              CBZ      r0,|L5.78|
                  |L5.70|
000046  2001              MOVS     r0,#1                 ;1089
000048  f7fffffe          BL       set_int_enable
00004c  e002              B        |L5.84|
                  |L5.78|
00004e  2000              MOVS     r0,#0                 ;1091
000050  f7fffffe          BL       set_int_enable
                  |L5.84|
000054  b13c              CBZ      r4,|L5.102|
000056  f7fffffe          BL       mpu_reset_fifo
00005a  b120              CBZ      r0,|L5.102|
00005c  4803              LDR      r0,|L5.108|
00005e  7405              STRB     r5,[r0,#0x10]         ;1094
000060  f04f30ff          MOV      r0,#0xffffffff        ;1095
000064  e7d6              B        |L5.20|
                  |L5.102|
000066  4630              MOV      r0,r6                 ;1100
000068  e7d4              B        |L5.20|
;;;1102   
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      ||st||

                          AREA ||i.mpu_get_accel_fsr||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_fsr PROC
;;;824     */
;;;825    int mpu_get_accel_fsr(unsigned char *fsr)
000000  4601              MOV      r1,r0
;;;826    {
;;;827        switch (st.chip_cfg.accel_fsr) {
000002  4811              LDR      r0,|L6.72|
000004  7a40              LDRB     r0,[r0,#9]
000006  b130              CBZ      r0,|L6.22|
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L6.28|
00000c  2802              CMP      r0,#2
00000e  d008              BEQ      |L6.34|
000010  2803              CMP      r0,#3
000012  d10c              BNE      |L6.46|
000014  e008              B        |L6.40|
                  |L6.22|
;;;828        case INV_FSR_2G:
;;;829            fsr[0] = 2;
000016  2002              MOVS     r0,#2
000018  7008              STRB     r0,[r1,#0]
;;;830            break;
00001a  e00b              B        |L6.52|
                  |L6.28|
;;;831        case INV_FSR_4G:
;;;832            fsr[0] = 4;
00001c  2004              MOVS     r0,#4
00001e  7008              STRB     r0,[r1,#0]
;;;833            break;
000020  e008              B        |L6.52|
                  |L6.34|
;;;834        case INV_FSR_8G:
;;;835            fsr[0] = 8;
000022  2008              MOVS     r0,#8
000024  7008              STRB     r0,[r1,#0]
;;;836            break;
000026  e005              B        |L6.52|
                  |L6.40|
;;;837        case INV_FSR_16G:
;;;838            fsr[0] = 16;
000028  2010              MOVS     r0,#0x10
00002a  7008              STRB     r0,[r1,#0]
;;;839            break;
00002c  e002              B        |L6.52|
                  |L6.46|
;;;840        default:
;;;841            return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L6.50|
;;;842        }
;;;843        if (st.chip_cfg.accel_half)
;;;844            fsr[0] <<= 1;
;;;845        return 0;
;;;846    }
000032  4770              BX       lr
                  |L6.52|
000034  bf00              NOP                            ;830
000036  4804              LDR      r0,|L6.72|
000038  7cc0              LDRB     r0,[r0,#0x13]         ;843
00003a  b118              CBZ      r0,|L6.68|
00003c  7808              LDRB     r0,[r1,#0]            ;844
00003e  0640              LSLS     r0,r0,#25             ;844
000040  0e00              LSRS     r0,r0,#24             ;844
000042  7008              STRB     r0,[r1,#0]            ;844
                  |L6.68|
000044  2000              MOVS     r0,#0                 ;845
000046  e7f4              B        |L6.50|
;;;847    
                          ENDP

                  |L6.72|
                          DCD      ||st||

                          AREA ||i.mpu_get_accel_reg||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_reg PROC
;;;614     */
;;;615    int mpu_get_accel_reg(short *data, unsigned long *timestamp)
000000  b57c              PUSH     {r2-r6,lr}
;;;616    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;617        unsigned char tmp[6];
;;;618    
;;;619        if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
000006  4818              LDR      r0,|L7.104|
000008  7a80              LDRB     r0,[r0,#0xa]
00000a  f0100f08          TST      r0,#8
00000e  d102              BNE      |L7.22|
;;;620            return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L7.20|
;;;621    
;;;622        if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
;;;623            return -1;
;;;624        data[0] = (tmp[0] << 8) | tmp[1];
;;;625        data[1] = (tmp[2] << 8) | tmp[3];
;;;626        data[2] = (tmp[4] << 8) | tmp[5];
;;;627        return 0;
;;;628    }
000014  bd7c              POP      {r2-r6,pc}
                  |L7.22|
000016  4a14              LDR      r2,|L7.104|
000018  6812              LDR      r2,[r2,#0]            ;622  ; st
00001a  7b51              LDRB     r1,[r2,#0xd]          ;622
00001c  4a12              LDR      r2,|L7.104|
00001e  6852              LDR      r2,[r2,#4]            ;622  ; st
000020  7810              LDRB     r0,[r2,#0]            ;622
000022  466b              MOV      r3,sp                 ;622
000024  2206              MOVS     r2,#6                 ;622
000026  f7fffffe          BL       i2c_read
00002a  b110              CBZ      r0,|L7.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;623
000030  e7f0              B        |L7.20|
                  |L7.50|
000032  f89d0001          LDRB     r0,[sp,#1]            ;624
000036  f89d1000          LDRB     r1,[sp,#0]            ;624
00003a  ea402001          ORR      r0,r0,r1,LSL #8       ;624
00003e  b200              SXTH     r0,r0                 ;624
000040  8020              STRH     r0,[r4,#0]            ;624
000042  f89d0003          LDRB     r0,[sp,#3]            ;625
000046  f89d1002          LDRB     r1,[sp,#2]            ;625
00004a  ea402001          ORR      r0,r0,r1,LSL #8       ;625
00004e  b200              SXTH     r0,r0                 ;625
000050  8060              STRH     r0,[r4,#2]            ;625
000052  f89d0005          LDRB     r0,[sp,#5]            ;626
000056  f89d1004          LDRB     r1,[sp,#4]            ;626
00005a  ea402001          ORR      r0,r0,r1,LSL #8       ;626
00005e  b200              SXTH     r0,r0                 ;626
000060  80a0              STRH     r0,[r4,#4]            ;626
000062  2000              MOVS     r0,#0                 ;627
000064  e7d6              B        |L7.20|
;;;629    
                          ENDP

000066  0000              DCW      0x0000
                  |L7.104|
                          DCD      ||st||

                          AREA ||i.mpu_get_accel_sens||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_sens PROC
;;;1030    */
;;;1031   int mpu_get_accel_sens(unsigned short *sens)
000000  4601              MOV      r1,r0
;;;1032   {
;;;1033       switch (st.chip_cfg.accel_fsr) {
000002  4813              LDR      r0,|L8.80|
000004  7a40              LDRB     r0,[r0,#9]
000006  b130              CBZ      r0,|L8.22|
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L8.30|
00000c  2802              CMP      r0,#2
00000e  d00a              BEQ      |L8.38|
000010  2803              CMP      r0,#3
000012  d110              BNE      |L8.54|
000014  e00b              B        |L8.46|
                  |L8.22|
;;;1034       case INV_FSR_2G:
;;;1035           sens[0] = 16384;
000016  f44f4080          MOV      r0,#0x4000
00001a  8008              STRH     r0,[r1,#0]
;;;1036           break;
00001c  e00e              B        |L8.60|
                  |L8.30|
;;;1037       case INV_FSR_4G:
;;;1038           sens[0] = 8092;
00001e  f641709c          MOV      r0,#0x1f9c
000022  8008              STRH     r0,[r1,#0]
;;;1039           break;
000024  e00a              B        |L8.60|
                  |L8.38|
;;;1040       case INV_FSR_8G:
;;;1041           sens[0] = 4096;
000026  f44f5080          MOV      r0,#0x1000
00002a  8008              STRH     r0,[r1,#0]
;;;1042           break;
00002c  e006              B        |L8.60|
                  |L8.46|
;;;1043       case INV_FSR_16G:
;;;1044           sens[0] = 2048;
00002e  f44f6000          MOV      r0,#0x800
000032  8008              STRH     r0,[r1,#0]
;;;1045           break;
000034  e002              B        |L8.60|
                  |L8.54|
;;;1046       default:
;;;1047           return -1;
000036  f04f30ff          MOV      r0,#0xffffffff
                  |L8.58|
;;;1048       }
;;;1049       if (st.chip_cfg.accel_half)
;;;1050           sens[0] >>= 1;
;;;1051       return 0;
;;;1052   }
00003a  4770              BX       lr
                  |L8.60|
00003c  bf00              NOP                            ;1036
00003e  4804              LDR      r0,|L8.80|
000040  7cc0              LDRB     r0,[r0,#0x13]         ;1049
000042  b110              CBZ      r0,|L8.74|
000044  8808              LDRH     r0,[r1,#0]            ;1050
000046  1040              ASRS     r0,r0,#1              ;1050
000048  8008              STRH     r0,[r1,#0]            ;1050
                  |L8.74|
00004a  2000              MOVS     r0,#0                 ;1051
00004c  e7f5              B        |L8.58|
;;;1053   
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      ||st||

                          AREA ||i.mpu_get_dmp_state||, CODE, READONLY, ALIGN=2

                  mpu_get_dmp_state PROC
;;;1809    */
;;;1810   int mpu_get_dmp_state(unsigned char *enabled)
000000  4601              MOV      r1,r0
;;;1811   {
;;;1812       enabled[0] = st.chip_cfg.dmp_on;
000002  4803              LDR      r0,|L9.16|
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  7008              STRB     r0,[r1,#0]
;;;1813       return 0;
00000a  2000              MOVS     r0,#0
;;;1814   }
00000c  4770              BX       lr
;;;1815   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ||st||

                          AREA ||i.mpu_get_fifo_config||, CODE, READONLY, ALIGN=2

                  mpu_get_fifo_config PROC
;;;1056    */
;;;1057   int mpu_get_fifo_config(unsigned char *sensors)
000000  4601              MOV      r1,r0
;;;1058   {
;;;1059       sensors[0] = st.chip_cfg.fifo_enable;
000002  4802              LDR      r0,|L10.12|
000004  7c00              LDRB     r0,[r0,#0x10]
000006  7008              STRB     r0,[r1,#0]
;;;1060       return 0;
000008  2000              MOVS     r0,#0
;;;1061   }
00000a  4770              BX       lr
;;;1062   
                          ENDP

                  |L10.12|
                          DCD      ||st||

                          AREA ||i.mpu_get_gyro_fsr||, CODE, READONLY, ALIGN=2

                  mpu_get_gyro_fsr PROC
;;;762     */
;;;763    int mpu_get_gyro_fsr(unsigned short *fsr)
000000  4601              MOV      r1,r0
;;;764    {
;;;765        switch (st.chip_cfg.gyro_fsr) {
000002  480f              LDR      r0,|L11.64|
000004  7a00              LDRB     r0,[r0,#8]  ; st
000006  b130              CBZ      r0,|L11.22|
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L11.28|
00000c  2802              CMP      r0,#2
00000e  d009              BEQ      |L11.36|
000010  2803              CMP      r0,#3
000012  d10f              BNE      |L11.52|
000014  e00a              B        |L11.44|
                  |L11.22|
;;;766        case INV_FSR_250DPS:
;;;767            fsr[0] = 250;
000016  20fa              MOVS     r0,#0xfa
000018  8008              STRH     r0,[r1,#0]
;;;768            break;
00001a  e00e              B        |L11.58|
                  |L11.28|
;;;769        case INV_FSR_500DPS:
;;;770            fsr[0] = 500;
00001c  f44f70fa          MOV      r0,#0x1f4
000020  8008              STRH     r0,[r1,#0]
;;;771            break;
000022  e00a              B        |L11.58|
                  |L11.36|
;;;772        case INV_FSR_1000DPS:
;;;773            fsr[0] = 1000;
000024  f44f707a          MOV      r0,#0x3e8
000028  8008              STRH     r0,[r1,#0]
;;;774            break;
00002a  e006              B        |L11.58|
                  |L11.44|
;;;775        case INV_FSR_2000DPS:
;;;776            fsr[0] = 2000;
00002c  f44f60fa          MOV      r0,#0x7d0
000030  8008              STRH     r0,[r1,#0]
;;;777            break;
000032  e002              B        |L11.58|
                  |L11.52|
;;;778        default:
;;;779            fsr[0] = 0;
000034  2000              MOVS     r0,#0
000036  8008              STRH     r0,[r1,#0]
;;;780            break;
000038  bf00              NOP      
                  |L11.58|
00003a  bf00              NOP                            ;768
;;;781        }
;;;782        return 0;
00003c  2000              MOVS     r0,#0
;;;783    }
00003e  4770              BX       lr
;;;784    
                          ENDP

                  |L11.64|
                          DCD      ||st||

                          AREA ||i.mpu_get_gyro_reg||, CODE, READONLY, ALIGN=2

                  mpu_get_gyro_reg PROC
;;;596     */
;;;597    int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
000000  b57c              PUSH     {r2-r6,lr}
;;;598    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;599        unsigned char tmp[6];
;;;600    
;;;601        if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
000006  4818              LDR      r0,|L12.104|
000008  7a80              LDRB     r0,[r0,#0xa]
00000a  f0100f70          TST      r0,#0x70
00000e  d102              BNE      |L12.22|
;;;602            return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L12.20|
;;;603    
;;;604        if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
;;;605            return -1;
;;;606        data[0] = (tmp[0] << 8) | tmp[1];
;;;607        data[1] = (tmp[2] << 8) | tmp[3];
;;;608        data[2] = (tmp[4] << 8) | tmp[5];
;;;609        return 0;
;;;610    }
000014  bd7c              POP      {r2-r6,pc}
                  |L12.22|
000016  4a14              LDR      r2,|L12.104|
000018  6812              LDR      r2,[r2,#0]            ;604  ; st
00001a  7b11              LDRB     r1,[r2,#0xc]          ;604
00001c  4a12              LDR      r2,|L12.104|
00001e  6852              LDR      r2,[r2,#4]            ;604  ; st
000020  7810              LDRB     r0,[r2,#0]            ;604
000022  466b              MOV      r3,sp                 ;604
000024  2206              MOVS     r2,#6                 ;604
000026  f7fffffe          BL       i2c_read
00002a  b110              CBZ      r0,|L12.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;605
000030  e7f0              B        |L12.20|
                  |L12.50|
000032  f89d0001          LDRB     r0,[sp,#1]            ;606
000036  f89d1000          LDRB     r1,[sp,#0]            ;606
00003a  ea402001          ORR      r0,r0,r1,LSL #8       ;606
00003e  b200              SXTH     r0,r0                 ;606
000040  8020              STRH     r0,[r4,#0]            ;606
000042  f89d0003          LDRB     r0,[sp,#3]            ;607
000046  f89d1002          LDRB     r1,[sp,#2]            ;607
00004a  ea402001          ORR      r0,r0,r1,LSL #8       ;607
00004e  b200              SXTH     r0,r0                 ;607
000050  8060              STRH     r0,[r4,#2]            ;607
000052  f89d0005          LDRB     r0,[sp,#5]            ;608
000056  f89d1004          LDRB     r1,[sp,#4]            ;608
00005a  ea402001          ORR      r0,r0,r1,LSL #8       ;608
00005e  b200              SXTH     r0,r0                 ;608
000060  80a0              STRH     r0,[r4,#4]            ;608
000062  2000              MOVS     r0,#0                 ;609
000064  e7d6              B        |L12.20|
;;;611    
                          ENDP

000066  0000              DCW      0x0000
                  |L12.104|
                          DCD      ||st||

                          AREA ||i.mpu_get_gyro_sens||, CODE, READONLY, ALIGN=2

                  mpu_get_gyro_sens PROC
;;;1006    */
;;;1007   int mpu_get_gyro_sens(float *sens)
000000  4601              MOV      r1,r0
;;;1008   {
;;;1009       switch (st.chip_cfg.gyro_fsr) {
000002  480e              LDR      r0,|L13.60|
000004  7a00              LDRB     r0,[r0,#8]  ; st
000006  b130              CBZ      r0,|L13.22|
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L13.28|
00000c  2802              CMP      r0,#2
00000e  d008              BEQ      |L13.34|
000010  2803              CMP      r0,#3
000012  d10c              BNE      |L13.46|
000014  e008              B        |L13.40|
                  |L13.22|
;;;1010       case INV_FSR_250DPS:
;;;1011           sens[0] = 131.f;
000016  480a              LDR      r0,|L13.64|
000018  6008              STR      r0,[r1,#0]
;;;1012           break;
00001a  e00b              B        |L13.52|
                  |L13.28|
;;;1013       case INV_FSR_500DPS:
;;;1014           sens[0] = 65.5f;
00001c  4809              LDR      r0,|L13.68|
00001e  6008              STR      r0,[r1,#0]
;;;1015           break;
000020  e008              B        |L13.52|
                  |L13.34|
;;;1016       case INV_FSR_1000DPS:
;;;1017           sens[0] = 32.8f;
000022  4809              LDR      r0,|L13.72|
000024  6008              STR      r0,[r1,#0]
;;;1018           break;
000026  e005              B        |L13.52|
                  |L13.40|
;;;1019       case INV_FSR_2000DPS:
;;;1020           sens[0] = 16.4f;
000028  4808              LDR      r0,|L13.76|
00002a  6008              STR      r0,[r1,#0]
;;;1021           break;
00002c  e002              B        |L13.52|
                  |L13.46|
;;;1022       default:
;;;1023           return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L13.50|
;;;1024       }
;;;1025       return 0;
;;;1026   }
000032  4770              BX       lr
                  |L13.52|
000034  bf00              NOP                            ;1012
000036  2000              MOVS     r0,#0                 ;1025
000038  e7fb              B        |L13.50|
;;;1027   
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
                          DCD      ||st||
                  |L13.64|
                          DCD      0x43030000
                  |L13.68|
                          DCD      0x42830000
                  |L13.72|
                          DCD      0x42033333
                  |L13.76|
                          DCD      0x41833333

                          AREA ||i.mpu_get_int_status||, CODE, READONLY, ALIGN=2

                  mpu_get_int_status PROC
;;;1162    */
;;;1163   int mpu_get_int_status(short *status)
000000  b538              PUSH     {r3-r5,lr}
;;;1164   {
000002  4604              MOV      r4,r0
;;;1165       unsigned char tmp[2];
;;;1166       if (!st.chip_cfg.sensors)
000004  480e              LDR      r0,|L14.64|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L14.16|
;;;1167           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L14.14|
;;;1168       if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
;;;1169           return -1;
;;;1170       status[0] = (tmp[0] << 8) | tmp[1];
;;;1171       return 0;
;;;1172   }
00000e  bd38              POP      {r3-r5,pc}
                  |L14.16|
000010  4a0b              LDR      r2,|L14.64|
000012  6812              LDR      r2,[r2,#0]            ;1168  ; st
000014  7c11              LDRB     r1,[r2,#0x10]         ;1168
000016  4a0a              LDR      r2,|L14.64|
000018  6852              LDR      r2,[r2,#4]            ;1168  ; st
00001a  7810              LDRB     r0,[r2,#0]            ;1168
00001c  466b              MOV      r3,sp                 ;1168
00001e  2202              MOVS     r2,#2                 ;1168
000020  f7fffffe          BL       i2c_read
000024  b110              CBZ      r0,|L14.44|
000026  f04f30ff          MOV      r0,#0xffffffff        ;1169
00002a  e7f0              B        |L14.14|
                  |L14.44|
00002c  f89d0001          LDRB     r0,[sp,#1]            ;1170
000030  f89d1000          LDRB     r1,[sp,#0]            ;1170
000034  ea402001          ORR      r0,r0,r1,LSL #8       ;1170
000038  b200              SXTH     r0,r0                 ;1170
00003a  8020              STRH     r0,[r4,#0]            ;1170
00003c  2000              MOVS     r0,#0                 ;1171
00003e  e7e6              B        |L14.14|
;;;1173   
                          ENDP

                  |L14.64|
                          DCD      ||st||

                          AREA ||i.mpu_get_lpf||, CODE, READONLY, ALIGN=2

                  mpu_get_lpf PROC
;;;885     */
;;;886    int mpu_get_lpf(unsigned short *lpf)
000000  4601              MOV      r1,r0
;;;887    {
;;;888        switch (st.chip_cfg.lpf) {
000002  4812              LDR      r0,|L15.76|
000004  7ac0              LDRB     r0,[r0,#0xb]
000006  2808              CMP      r0,#8
000008  d217              BCS      |L15.58|
00000a  e8dff000          TBB      [pc,r0]
00000e  1704              DCB      0x17,0x04
000010  070a0d10          DCB      0x07,0x0a,0x0d,0x10
000014  1318              DCB      0x13,0x18
;;;889        case INV_FILTER_188HZ:
;;;890            lpf[0] = 188;
000016  20bc              MOVS     r0,#0xbc
000018  8008              STRH     r0,[r1,#0]
;;;891            break;
00001a  e013              B        |L15.68|
;;;892        case INV_FILTER_98HZ:
;;;893            lpf[0] = 98;
00001c  2062              MOVS     r0,#0x62
00001e  8008              STRH     r0,[r1,#0]
;;;894            break;
000020  e010              B        |L15.68|
;;;895        case INV_FILTER_42HZ:
;;;896            lpf[0] = 42;
000022  202a              MOVS     r0,#0x2a
000024  8008              STRH     r0,[r1,#0]
;;;897            break;
000026  e00d              B        |L15.68|
;;;898        case INV_FILTER_20HZ:
;;;899            lpf[0] = 20;
000028  2014              MOVS     r0,#0x14
00002a  8008              STRH     r0,[r1,#0]
;;;900            break;
00002c  e00a              B        |L15.68|
;;;901        case INV_FILTER_10HZ:
;;;902            lpf[0] = 10;
00002e  200a              MOVS     r0,#0xa
000030  8008              STRH     r0,[r1,#0]
;;;903            break;
000032  e007              B        |L15.68|
;;;904        case INV_FILTER_5HZ:
;;;905            lpf[0] = 5;
000034  2005              MOVS     r0,#5
000036  8008              STRH     r0,[r1,#0]
;;;906            break;
000038  e004              B        |L15.68|
                  |L15.58|
;;;907        case INV_FILTER_256HZ_NOLPF2:
00003a  bf00              NOP      
;;;908        case INV_FILTER_2100HZ_NOLPF:
00003c  bf00              NOP      
;;;909        default:
;;;910            lpf[0] = 0;
00003e  2000              MOVS     r0,#0
000040  8008              STRH     r0,[r1,#0]
;;;911            break;
000042  bf00              NOP      
                  |L15.68|
000044  bf00              NOP                            ;891
;;;912        }
;;;913        return 0;
000046  2000              MOVS     r0,#0
;;;914    }
000048  4770              BX       lr
;;;915    
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      ||st||

                          AREA ||i.mpu_get_power_state||, CODE, READONLY, ALIGN=2

                  mpu_get_power_state PROC
;;;1105    */
;;;1106   int mpu_get_power_state(unsigned char *power_on)
000000  4601              MOV      r1,r0
;;;1107   {
;;;1108       if (st.chip_cfg.sensors)
000002  4805              LDR      r0,|L16.24|
000004  7a80              LDRB     r0,[r0,#0xa]
000006  b110              CBZ      r0,|L16.14|
;;;1109           power_on[0] = 1;
000008  2001              MOVS     r0,#1
00000a  7008              STRB     r0,[r1,#0]
00000c  e001              B        |L16.18|
                  |L16.14|
;;;1110       else
;;;1111           power_on[0] = 0;
00000e  2000              MOVS     r0,#0
000010  7008              STRB     r0,[r1,#0]
                  |L16.18|
;;;1112       return 0;
000012  2000              MOVS     r0,#0
;;;1113   }
000014  4770              BX       lr
;;;1114   
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      ||st||

                          AREA ||i.mpu_get_sample_rate||, CODE, READONLY, ALIGN=2

                  mpu_get_sample_rate PROC
;;;951     */
;;;952    int mpu_get_sample_rate(unsigned short *rate)
000000  4601              MOV      r1,r0
;;;953    {
;;;954        if (st.chip_cfg.dmp_on)
000002  4806              LDR      r0,|L17.28|
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  b110              CBZ      r0,|L17.16|
;;;955            return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L17.14|
;;;956        else
;;;957            rate[0] = st.chip_cfg.sample_rate;
;;;958        return 0;
;;;959    }
00000e  4770              BX       lr
                  |L17.16|
000010  4802              LDR      r0,|L17.28|
000012  89c0              LDRH     r0,[r0,#0xe]          ;957
000014  8008              STRH     r0,[r1,#0]            ;957
000016  2000              MOVS     r0,#0                 ;958
000018  e7f9              B        |L17.14|
;;;960    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||st||

                          AREA ||i.mpu_get_temperature||, CODE, READONLY, ALIGN=2

                  mpu_get_temperature PROC
;;;633     */
;;;634    int mpu_get_temperature(short *data, unsigned long *timestamp)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;635    {
000004  4682              MOV      r10,r0
;;;636        unsigned char tmp[2];
;;;637        short raw;
;;;638    
;;;639        if (!(st.chip_cfg.sensors))
000006  481a              LDR      r0,|L18.112|
000008  7a80              LDRB     r0,[r0,#0xa]
00000a  b918              CBNZ     r0,|L18.20|
;;;640            return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L18.16|
;;;641    
;;;642        if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
;;;643            return -1;
;;;644        raw = (tmp[0] << 8) | tmp[1];
;;;645    	*data = (((double) (raw + 13200)) / 280)-13;
;;;646    //    *data = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
;;;647    //	*Temperature = (((double) (tempData + 13200)) / 280)-13;
;;;648        return 0;
;;;649    }
000010  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.20|
000014  4a16              LDR      r2,|L18.112|
000016  6812              LDR      r2,[r2,#0]            ;642  ; st
000018  7b91              LDRB     r1,[r2,#0xe]          ;642
00001a  4a15              LDR      r2,|L18.112|
00001c  6852              LDR      r2,[r2,#4]            ;642  ; st
00001e  7810              LDRB     r0,[r2,#0]            ;642
000020  466b              MOV      r3,sp                 ;642
000022  2202              MOVS     r2,#2                 ;642
000024  f7fffffe          BL       i2c_read
000028  b110              CBZ      r0,|L18.48|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;643
00002e  e7ef              B        |L18.16|
                  |L18.48|
000030  f89d0001          LDRB     r0,[sp,#1]            ;644
000034  f89d1000          LDRB     r1,[sp,#0]            ;644
000038  ea402001          ORR      r0,r0,r1,LSL #8       ;644
00003c  fa0ffb80          SXTH     r11,r0                ;644
000040  f2433090          MOV      r0,#0x3390            ;645
000044  4458              ADD      r0,r0,r11             ;645
000046  f7fffffe          BL       __aeabi_i2d
00004a  4606              MOV      r6,r0                 ;645
00004c  2200              MOVS     r2,#0                 ;645
00004e  4b09              LDR      r3,|L18.116|
000050  f7fffffe          BL       __aeabi_ddiv
000054  4604              MOV      r4,r0                 ;645
000056  2200              MOVS     r2,#0                 ;645
000058  4b07              LDR      r3,|L18.120|
00005a  f7fffffe          BL       __aeabi_dsub
00005e  4680              MOV      r8,r0                 ;645
000060  f7fffffe          BL       __aeabi_d2iz
000064  b200              SXTH     r0,r0                 ;645
000066  f8aa0000          STRH     r0,[r10,#0]           ;645
00006a  2000              MOVS     r0,#0                 ;648
00006c  e7d0              B        |L18.16|
;;;650    
                          ENDP

00006e  0000              DCW      0x0000
                  |L18.112|
                          DCD      ||st||
                  |L18.116|
                          DCD      0x40718000
                  |L18.120|
                          DCD      0x402a0000

                          AREA ||i.mpu_init||, CODE, READONLY, ALIGN=2

                  mpu_init PROC
;;;394     ***/
;;;395    int mpu_init( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;396    {
;;;397        unsigned char data[6], rev;	
;;;398    
;;;399    		memset(data, 0, 6);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
;;;400        /* ********Reset device************* */
;;;401        data[0] = 0x80;
000008  2080              MOVS     r0,#0x80
00000a  f88d0000          STRB     r0,[sp,#0]
;;;402        if ( i2c_write( st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0]) ) )
00000e  4a63              LDR      r2,|L19.412|
000010  6812              LDR      r2,[r2,#0]  ; st
000012  7c91              LDRB     r1,[r2,#0x12]
000014  4a61              LDR      r2,|L19.412|
000016  6852              LDR      r2,[r2,#4]  ; st
000018  7810              LDRB     r0,[r2,#0]
00001a  466b              MOV      r3,sp
00001c  2201              MOVS     r2,#1
00001e  f7fffffe          BL       i2c_write
000022  b110              CBZ      r0,|L19.42|
;;;403            return -1;
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L19.40|
;;;404        Timer_Delayms(100);
;;;405    
;;;406        /******************Wake up chip*************/
;;;407        data[0] = 0x00;
;;;408        if ( i2c_write( st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0]) ) )
;;;409            return -1;
;;;410    
;;;411    #if defined MPU6050
;;;412        /* ******************************************************** */
;;;413        if ( i2c_read( st.hw->addr, st.reg->accel_offs, 6, data ) )
;;;414            return -1;
;;;415    
;;;416        rev = ( (data[5] & 0x01) << 2 ) | ( (data[3] & 0x01) << 1 ) |
;;;417            ( data[1] & 0x01 );
;;;418    
;;;419        if ( rev ) {
;;;420            /************************* Congrats, these parts are better******************/
;;;421            if (rev == 1)
;;;422                st.chip_cfg.accel_half = 1;
;;;423            else if (rev == 2)
;;;424                st.chip_cfg.accel_half = 0;
;;;425            else {
;;;426              //  DebugUart_Putstr( "Unsupported software product rev %d.\n" );
;;;427    					//dmpstatus12=2;
;;;428    					  dmpstatus13=1;
;;;429                return -1;
;;;430            }
;;;431        } else {
;;;432            if (i2c_read( st.hw->addr, st.reg->prod_id, 1, &(data[0]) ) )
;;;433                return -1;
;;;434            rev = data[0] & 0x0F;
;;;435            if ( !rev ) {
;;;436               // DebugUart_Putstr(" Product ID read as 0 indicates device is either "
;;;437                  //  "incompatible or an MPU3050.\n");
;;;438    					dmpstatus13=12;
;;;439                return -1;
;;;440            } else if ( rev == 4 ) {
;;;441              //  DebugUart_Putstr("Half sensitivity part found.\n");
;;;442                st.chip_cfg.accel_half = 1;
;;;443            } else
;;;444                st.chip_cfg.accel_half = 0;
;;;445        }
;;;446    
;;;447    #endif
;;;448    
;;;449        /* ********Set to invalid values to ensure no I2C writes are skipped********************** */
;;;450        st.chip_cfg.sensors = 0xFF;
;;;451        st.chip_cfg.gyro_fsr = 0xFF;
;;;452        st.chip_cfg.accel_fsr = 0xFF;
;;;453        st.chip_cfg.lpf = 0xFF;
;;;454        st.chip_cfg.sample_rate = 0xFFFF;
;;;455        st.chip_cfg.fifo_enable = 0xFF;
;;;456        st.chip_cfg.bypass_mode = 0xFF;
;;;457    
;;;458    
;;;459        /* *********mpu_set_sensors always preserves this setting*****************/
;;;460        st.chip_cfg.clk_src = INV_CLK_PLL;
;;;461    
;;;462        /************* Handled in next call to mpu_set_bypass**************** */
;;;463        st.chip_cfg.active_low_int = 1;
;;;464        st.chip_cfg.latched_int = 0;
;;;465        st.chip_cfg.int_motion_only = 0;
;;;466        st.chip_cfg.lp_accel_mode = 0;
;;;467        memset( &st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache) );
;;;468        st.chip_cfg.dmp_on = 0;
;;;469        st.chip_cfg.dmp_loaded = 0;
;;;470        st.chip_cfg.dmp_sample_rate = 0;
;;;471    
;;;472        if ( mpu_set_gyro_fsr(2000) )
;;;473            return -1;
;;;474        if ( mpu_set_accel_fsr(2) )
;;;475            return -1;
;;;476        if ( mpu_set_lpf(42) )
;;;477            return -1;
;;;478        if ( mpu_set_sample_rate(50) )
;;;479            return -1;
;;;480        if ( mpu_configure_fifo(0) )
;;;481            return -1;
;;;482    
;;;483    
;;;484        /************* Already disabled by setup_compass*********************/
;;;485        if ( mpu_set_bypass(0) )
;;;486            return -1;
;;;487    
;;;488        mpu_set_sensors(0);
;;;489        return 0;
;;;490    }
000028  bd1c              POP      {r2-r4,pc}
                  |L19.42|
00002a  2064              MOVS     r0,#0x64              ;404
00002c  f7fffffe          BL       Timer_Delayms
000030  2000              MOVS     r0,#0                 ;407
000032  f88d0000          STRB     r0,[sp,#0]            ;407
000036  4a59              LDR      r2,|L19.412|
000038  6812              LDR      r2,[r2,#0]            ;408  ; st
00003a  7c91              LDRB     r1,[r2,#0x12]         ;408
00003c  4a57              LDR      r2,|L19.412|
00003e  6852              LDR      r2,[r2,#4]            ;408  ; st
000040  7810              LDRB     r0,[r2,#0]            ;408
000042  466b              MOV      r3,sp                 ;408
000044  2201              MOVS     r2,#1                 ;408
000046  f7fffffe          BL       i2c_write
00004a  b110              CBZ      r0,|L19.82|
00004c  f04f30ff          MOV      r0,#0xffffffff        ;409
000050  e7ea              B        |L19.40|
                  |L19.82|
000052  4a52              LDR      r2,|L19.412|
000054  6812              LDR      r2,[r2,#0]            ;413  ; st
000056  7d91              LDRB     r1,[r2,#0x16]         ;413
000058  4a50              LDR      r2,|L19.412|
00005a  6852              LDR      r2,[r2,#4]            ;413  ; st
00005c  7810              LDRB     r0,[r2,#0]            ;413
00005e  466b              MOV      r3,sp                 ;413
000060  2206              MOVS     r2,#6                 ;413
000062  f7fffffe          BL       i2c_read
000066  b110              CBZ      r0,|L19.110|
000068  f04f30ff          MOV      r0,#0xffffffff        ;414
00006c  e7dc              B        |L19.40|
                  |L19.110|
00006e  f89d0005          LDRB     r0,[sp,#5]            ;416
000072  07c0              LSLS     r0,r0,#31             ;416
000074  0f40              LSRS     r0,r0,#29             ;416
000076  f89d1003          LDRB     r1,[sp,#3]            ;416
00007a  f0010101          AND      r1,r1,#1              ;416
00007e  ea400041          ORR      r0,r0,r1,LSL #1       ;416
000082  f89d1001          LDRB     r1,[sp,#1]            ;416
000086  f0010101          AND      r1,r1,#1              ;416
00008a  ea400401          ORR      r4,r0,r1              ;416
00008e  b184              CBZ      r4,|L19.178|
000090  2c01              CMP      r4,#1                 ;421
000092  d103              BNE      |L19.156|
000094  2101              MOVS     r1,#1                 ;422
000096  4841              LDR      r0,|L19.412|
000098  74c1              STRB     r1,[r0,#0x13]         ;422
00009a  e02c              B        |L19.246|
                  |L19.156|
00009c  2c02              CMP      r4,#2                 ;423
00009e  d103              BNE      |L19.168|
0000a0  2100              MOVS     r1,#0                 ;424
0000a2  483e              LDR      r0,|L19.412|
0000a4  74c1              STRB     r1,[r0,#0x13]         ;424
0000a6  e026              B        |L19.246|
                  |L19.168|
0000a8  2001              MOVS     r0,#1                 ;428
0000aa  493d              LDR      r1,|L19.416|
0000ac  7008              STRB     r0,[r1,#0]            ;428
0000ae  1e80              SUBS     r0,r0,#2              ;429
0000b0  e7ba              B        |L19.40|
                  |L19.178|
0000b2  4a3a              LDR      r2,|L19.412|
0000b4  6812              LDR      r2,[r2,#0]            ;432  ; st
0000b6  78d1              LDRB     r1,[r2,#3]            ;432
0000b8  4a38              LDR      r2,|L19.412|
0000ba  6852              LDR      r2,[r2,#4]            ;432  ; st
0000bc  7810              LDRB     r0,[r2,#0]            ;432
0000be  466b              MOV      r3,sp                 ;432
0000c0  2201              MOVS     r2,#1                 ;432
0000c2  f7fffffe          BL       i2c_read
0000c6  b110              CBZ      r0,|L19.206|
0000c8  f04f30ff          MOV      r0,#0xffffffff        ;433
0000cc  e7ac              B        |L19.40|
                  |L19.206|
0000ce  f89d0000          LDRB     r0,[sp,#0]            ;434
0000d2  f000040f          AND      r4,r0,#0xf            ;434
0000d6  b92c              CBNZ     r4,|L19.228|
0000d8  200c              MOVS     r0,#0xc               ;438
0000da  4931              LDR      r1,|L19.416|
0000dc  7008              STRB     r0,[r1,#0]            ;438
0000de  f04f30ff          MOV      r0,#0xffffffff        ;439
0000e2  e7a1              B        |L19.40|
                  |L19.228|
0000e4  2c04              CMP      r4,#4                 ;440
0000e6  d103              BNE      |L19.240|
0000e8  2101              MOVS     r1,#1                 ;442
0000ea  482c              LDR      r0,|L19.412|
0000ec  74c1              STRB     r1,[r0,#0x13]         ;442
0000ee  e002              B        |L19.246|
                  |L19.240|
0000f0  2100              MOVS     r1,#0                 ;444
0000f2  482a              LDR      r0,|L19.412|
0000f4  74c1              STRB     r1,[r0,#0x13]         ;444
                  |L19.246|
0000f6  21ff              MOVS     r1,#0xff              ;450
0000f8  4828              LDR      r0,|L19.412|
0000fa  7281              STRB     r1,[r0,#0xa]          ;450
0000fc  20ff              MOVS     r0,#0xff              ;451
0000fe  4927              LDR      r1,|L19.412|
000100  7208              STRB     r0,[r1,#8]            ;451
000102  21ff              MOVS     r1,#0xff              ;452
000104  4825              LDR      r0,|L19.412|
000106  7241              STRB     r1,[r0,#9]            ;452
000108  72c1              STRB     r1,[r0,#0xb]          ;453
00010a  f64f71ff          MOV      r1,#0xffff            ;454
00010e  81c1              STRH     r1,[r0,#0xe]          ;454
000110  21ff              MOVS     r1,#0xff              ;455
000112  7401              STRB     r1,[r0,#0x10]         ;455
000114  7481              STRB     r1,[r0,#0x12]         ;456
000116  2101              MOVS     r1,#1                 ;460
000118  7301              STRB     r1,[r0,#0xc]          ;460
00011a  f8801022          STRB     r1,[r0,#0x22]         ;463
00011e  2100              MOVS     r1,#0                 ;464
000120  f8801023          STRB     r1,[r0,#0x23]         ;464
000124  7541              STRB     r1,[r0,#0x15]         ;465
000126  7501              STRB     r1,[r0,#0x14]         ;466
000128  3016              ADDS     r0,r0,#0x16           ;467
00012a  6001              STR      r1,[r0,#0]            ;467
00012c  6041              STR      r1,[r0,#4]            ;467
00012e  6081              STR      r1,[r0,#8]            ;467
000130  3816              SUBS     r0,r0,#0x16           ;468
000132  f8801024          STRB     r1,[r0,#0x24]         ;468
000136  f8801025          STRB     r1,[r0,#0x25]         ;469
00013a  84c1              STRH     r1,[r0,#0x26]         ;470
00013c  f44f60fa          MOV      r0,#0x7d0             ;472
000140  f7fffffe          BL       mpu_set_gyro_fsr
000144  b110              CBZ      r0,|L19.332|
000146  f04f30ff          MOV      r0,#0xffffffff        ;473
00014a  e76d              B        |L19.40|
                  |L19.332|
00014c  2002              MOVS     r0,#2                 ;474
00014e  f7fffffe          BL       mpu_set_accel_fsr
000152  b110              CBZ      r0,|L19.346|
000154  f04f30ff          MOV      r0,#0xffffffff        ;475
000158  e766              B        |L19.40|
                  |L19.346|
00015a  202a              MOVS     r0,#0x2a              ;476
00015c  f7fffffe          BL       mpu_set_lpf
000160  b110              CBZ      r0,|L19.360|
000162  f04f30ff          MOV      r0,#0xffffffff        ;477
000166  e75f              B        |L19.40|
                  |L19.360|
000168  2032              MOVS     r0,#0x32              ;478
00016a  f7fffffe          BL       mpu_set_sample_rate
00016e  b110              CBZ      r0,|L19.374|
000170  f04f30ff          MOV      r0,#0xffffffff        ;479
000174  e758              B        |L19.40|
                  |L19.374|
000176  2000              MOVS     r0,#0                 ;480
000178  f7fffffe          BL       mpu_configure_fifo
00017c  b110              CBZ      r0,|L19.388|
00017e  f04f30ff          MOV      r0,#0xffffffff        ;481
000182  e751              B        |L19.40|
                  |L19.388|
000184  2000              MOVS     r0,#0                 ;485
000186  f7fffffe          BL       mpu_set_bypass
00018a  b110              CBZ      r0,|L19.402|
00018c  f04f30ff          MOV      r0,#0xffffffff        ;486
000190  e74a              B        |L19.40|
                  |L19.402|
000192  2000              MOVS     r0,#0                 ;488
000194  f7fffffe          BL       mpu_set_sensors
000198  2000              MOVS     r0,#0                 ;489
00019a  e745              B        |L19.40|
;;;491    
                          ENDP

                  |L19.412|
                          DCD      ||st||
                  |L19.416|
                          DCD      dmpstatus13

                          AREA ||i.mpu_load_firmware||, CODE, READONLY, ALIGN=2

                  mpu_load_firmware PROC
;;;1729    */
;;;1730   int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1731       unsigned short start_addr, unsigned short sample_rate)
;;;1732   {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4690              MOV      r8,r2
00000c  4699              MOV      r9,r3
;;;1733       unsigned short ii;
;;;1734       unsigned short this_write;
;;;1735       /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
;;;1736   #define LOAD_CHUNK  (16)
;;;1737       unsigned char cur[LOAD_CHUNK], tmp[2];
;;;1738   
;;;1739       if (st.chip_cfg.dmp_loaded)
00000e  4829              LDR      r0,|L20.180|
000010  f8900025          LDRB     r0,[r0,#0x25]
000014  b120              CBZ      r0,|L20.32|
;;;1740           /* DMP should only be loaded once. */
;;;1741           return -1;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L20.26|
;;;1742   
;;;1743       if (!firmware)
;;;1744           return -1;
;;;1745       for (ii = 0; ii < length; ii += this_write) {
;;;1746           this_write = min(LOAD_CHUNK, length - ii);
;;;1747           if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
;;;1748               return -1;
;;;1749           if (mpu_read_mem(ii, this_write, cur))
;;;1750               return -1;
;;;1751           if (memcmp(firmware+ii, cur, this_write))
;;;1752               return -2;
;;;1753       }
;;;1754   
;;;1755       /* Set program start address. */
;;;1756       tmp[0] = start_addr >> 8;
;;;1757       tmp[1] = start_addr & 0xFF;
;;;1758       if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
;;;1759           return -1;
;;;1760   
;;;1761       st.chip_cfg.dmp_loaded = 1;
;;;1762       st.chip_cfg.dmp_sample_rate = sample_rate;
;;;1763       return 0;
;;;1764   }
00001a  b005              ADD      sp,sp,#0x14
00001c  e8bd83f0          POP      {r4-r9,pc}
                  |L20.32|
000020  b916              CBNZ     r6,|L20.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;1744
000026  e7f8              B        |L20.26|
                  |L20.40|
000028  2400              MOVS     r4,#0                 ;1745
00002a  e023              B        |L20.116|
                  |L20.44|
00002c  1b28              SUBS     r0,r5,r4              ;1746
00002e  2810              CMP      r0,#0x10              ;1746
000030  dd01              BLE      |L20.54|
000032  2010              MOVS     r0,#0x10              ;1746
000034  e000              B        |L20.56|
                  |L20.54|
000036  1b28              SUBS     r0,r5,r4              ;1746
                  |L20.56|
000038  b287              UXTH     r7,r0                 ;1746
00003a  1932              ADDS     r2,r6,r4              ;1747
00003c  4639              MOV      r1,r7                 ;1747
00003e  4620              MOV      r0,r4                 ;1747
000040  f7fffffe          BL       mpu_write_mem
000044  b110              CBZ      r0,|L20.76|
000046  f04f30ff          MOV      r0,#0xffffffff        ;1748
00004a  e7e6              B        |L20.26|
                  |L20.76|
00004c  aa01              ADD      r2,sp,#4              ;1749
00004e  4639              MOV      r1,r7                 ;1749
000050  4620              MOV      r0,r4                 ;1749
000052  f7fffffe          BL       mpu_read_mem
000056  b110              CBZ      r0,|L20.94|
000058  f04f30ff          MOV      r0,#0xffffffff        ;1750
00005c  e7dd              B        |L20.26|
                  |L20.94|
00005e  1930              ADDS     r0,r6,r4              ;1751
000060  463a              MOV      r2,r7                 ;1751
000062  a901              ADD      r1,sp,#4              ;1751
000064  f7fffffe          BL       memcmp
000068  b110              CBZ      r0,|L20.112|
00006a  f06f0001          MVN      r0,#1                 ;1752
00006e  e7d4              B        |L20.26|
                  |L20.112|
000070  19e0              ADDS     r0,r4,r7              ;1745
000072  b284              UXTH     r4,r0                 ;1745
                  |L20.116|
000074  42ac              CMP      r4,r5                 ;1745
000076  dbd9              BLT      |L20.44|
000078  ea4f2028          ASR      r0,r8,#8              ;1756
00007c  f88d0000          STRB     r0,[sp,#0]            ;1756
000080  f00800ff          AND      r0,r8,#0xff           ;1757
000084  f88d0001          STRB     r0,[sp,#1]            ;1757
000088  4a0a              LDR      r2,|L20.180|
00008a  6812              LDR      r2,[r2,#0]            ;1758  ; st
00008c  7e91              LDRB     r1,[r2,#0x1a]         ;1758
00008e  4a09              LDR      r2,|L20.180|
000090  6852              LDR      r2,[r2,#4]            ;1758  ; st
000092  7810              LDRB     r0,[r2,#0]            ;1758
000094  466b              MOV      r3,sp                 ;1758
000096  2202              MOVS     r2,#2                 ;1758
000098  f7fffffe          BL       i2c_write
00009c  b110              CBZ      r0,|L20.164|
00009e  f04f30ff          MOV      r0,#0xffffffff        ;1759
0000a2  e7ba              B        |L20.26|
                  |L20.164|
0000a4  2101              MOVS     r1,#1                 ;1761
0000a6  4803              LDR      r0,|L20.180|
0000a8  f8801025          STRB     r1,[r0,#0x25]         ;1761
0000ac  f8a09026          STRH     r9,[r0,#0x26]         ;1762
0000b0  2000              MOVS     r0,#0                 ;1763
0000b2  e7b2              B        |L20.26|
;;;1765   
                          ENDP

                  |L20.180|
                          DCD      ||st||

                          AREA ||i.mpu_lp_accel_mode||, CODE, READONLY, ALIGN=2

                  mpu_lp_accel_mode PROC
;;;541     */
;;;542    int mpu_lp_accel_mode(unsigned char rate)
000000  b538              PUSH     {r3-r5,lr}
;;;543    {
000002  4604              MOV      r4,r0
;;;544        unsigned char tmp[2];
;;;545    
;;;546        if (rate > 40)
000004  2c28              CMP      r4,#0x28
000006  dd02              BLE      |L21.14|
;;;547            return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L21.12|
;;;548    
;;;549        if (!rate) {
;;;550            mpu_set_int_latched(0);
;;;551            tmp[0] = 0;
;;;552            tmp[1] = BIT_STBY_XYZG;
;;;553            if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;554                return -1;
;;;555            st.chip_cfg.lp_accel_mode = 0;
;;;556            return 0;
;;;557        }
;;;558        /* For LP accel, we automatically configure the hardware to produce latched
;;;559         * interrupts. In LP accel mode, the hardware cycles into sleep mode before
;;;560         * it gets a chance to deassert the interrupt pin; therefore, we shift this
;;;561         * responsibility over to the MCU.
;;;562         *
;;;563         * Any register read will clear the interrupt.
;;;564         */
;;;565        mpu_set_int_latched(1);
;;;566    #if defined MPU6050
;;;567        tmp[0] = BIT_LPA_CYCLE;
;;;568        if (rate == 1) {
;;;569            tmp[1] = INV_LPA_1_25HZ;
;;;570            mpu_set_lpf(5);
;;;571        } else if (rate <= 5) {
;;;572            tmp[1] = INV_LPA_5HZ;
;;;573            mpu_set_lpf(5);
;;;574        } else if (rate <= 20) {
;;;575            tmp[1] = INV_LPA_20HZ;
;;;576            mpu_set_lpf(10);
;;;577        } else {
;;;578            tmp[1] = INV_LPA_40HZ;
;;;579            mpu_set_lpf(20);
;;;580        }
;;;581        tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
;;;582        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;583            return -1;
;;;584    #endif
;;;585        st.chip_cfg.sensors = INV_XYZ_ACCEL;
;;;586        st.chip_cfg.clk_src = 0;
;;;587        st.chip_cfg.lp_accel_mode = 1;
;;;588        mpu_configure_fifo(0);
;;;589    
;;;590        return 0;
;;;591    }
00000c  bd38              POP      {r3-r5,pc}
                  |L21.14|
00000e  b9dc              CBNZ     r4,|L21.72|
000010  2000              MOVS     r0,#0                 ;550
000012  f7fffffe          BL       mpu_set_int_latched
000016  2000              MOVS     r0,#0                 ;551
000018  f88d0000          STRB     r0,[sp,#0]            ;551
00001c  2007              MOVS     r0,#7                 ;552
00001e  f88d0001          STRB     r0,[sp,#1]            ;552
000022  4a2e              LDR      r2,|L21.220|
000024  6812              LDR      r2,[r2,#0]            ;553  ; st
000026  7c91              LDRB     r1,[r2,#0x12]         ;553
000028  4a2c              LDR      r2,|L21.220|
00002a  6852              LDR      r2,[r2,#4]            ;553  ; st
00002c  7810              LDRB     r0,[r2,#0]            ;553
00002e  466b              MOV      r3,sp                 ;553
000030  2202              MOVS     r2,#2                 ;553
000032  f7fffffe          BL       i2c_write
000036  b110              CBZ      r0,|L21.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;554
00003c  e7e6              B        |L21.12|
                  |L21.62|
00003e  2100              MOVS     r1,#0                 ;555
000040  4826              LDR      r0,|L21.220|
000042  7501              STRB     r1,[r0,#0x14]         ;555
000044  2000              MOVS     r0,#0                 ;556
000046  e7e1              B        |L21.12|
                  |L21.72|
000048  2001              MOVS     r0,#1                 ;565
00004a  f7fffffe          BL       mpu_set_int_latched
00004e  2020              MOVS     r0,#0x20              ;567
000050  f88d0000          STRB     r0,[sp,#0]            ;567
000054  2c01              CMP      r4,#1                 ;568
000056  d106              BNE      |L21.102|
000058  2000              MOVS     r0,#0                 ;569
00005a  f88d0001          STRB     r0,[sp,#1]            ;569
00005e  2005              MOVS     r0,#5                 ;570
000060  f7fffffe          BL       mpu_set_lpf
000064  e017              B        |L21.150|
                  |L21.102|
000066  2c05              CMP      r4,#5                 ;571
000068  dc06              BGT      |L21.120|
00006a  2001              MOVS     r0,#1                 ;572
00006c  f88d0001          STRB     r0,[sp,#1]            ;572
000070  2005              MOVS     r0,#5                 ;573
000072  f7fffffe          BL       mpu_set_lpf
000076  e00e              B        |L21.150|
                  |L21.120|
000078  2c14              CMP      r4,#0x14              ;574
00007a  dc06              BGT      |L21.138|
00007c  2002              MOVS     r0,#2                 ;575
00007e  f88d0001          STRB     r0,[sp,#1]            ;575
000082  200a              MOVS     r0,#0xa               ;576
000084  f7fffffe          BL       mpu_set_lpf
000088  e005              B        |L21.150|
                  |L21.138|
00008a  2003              MOVS     r0,#3                 ;578
00008c  f88d0001          STRB     r0,[sp,#1]            ;578
000090  2014              MOVS     r0,#0x14              ;579
000092  f7fffffe          BL       mpu_set_lpf
                  |L21.150|
000096  f89d0001          LDRB     r0,[sp,#1]            ;581
00009a  2107              MOVS     r1,#7                 ;581
00009c  eb011080          ADD      r0,r1,r0,LSL #6       ;581
0000a0  b2c0              UXTB     r0,r0                 ;581
0000a2  f88d0001          STRB     r0,[sp,#1]            ;581
0000a6  4a0d              LDR      r2,|L21.220|
0000a8  6812              LDR      r2,[r2,#0]            ;582  ; st
0000aa  7c91              LDRB     r1,[r2,#0x12]         ;582
0000ac  4a0b              LDR      r2,|L21.220|
0000ae  6852              LDR      r2,[r2,#4]            ;582  ; st
0000b0  7810              LDRB     r0,[r2,#0]            ;582
0000b2  466b              MOV      r3,sp                 ;582
0000b4  2202              MOVS     r2,#2                 ;582
0000b6  f7fffffe          BL       i2c_write
0000ba  b110              CBZ      r0,|L21.194|
0000bc  f04f30ff          MOV      r0,#0xffffffff        ;583
0000c0  e7a4              B        |L21.12|
                  |L21.194|
0000c2  2108              MOVS     r1,#8                 ;585
0000c4  4805              LDR      r0,|L21.220|
0000c6  7281              STRB     r1,[r0,#0xa]          ;585
0000c8  2100              MOVS     r1,#0                 ;586
0000ca  7301              STRB     r1,[r0,#0xc]          ;586
0000cc  2101              MOVS     r1,#1                 ;587
0000ce  7501              STRB     r1,[r0,#0x14]         ;587
0000d0  2000              MOVS     r0,#0                 ;588
0000d2  f7fffffe          BL       mpu_configure_fifo
0000d6  2000              MOVS     r0,#0                 ;590
0000d8  e798              B        |L21.12|
;;;592    
                          ENDP

0000da  0000              DCW      0x0000
                  |L21.220|
                          DCD      ||st||

                          AREA ||i.mpu_lp_motion_interrupt||, CODE, READONLY, ALIGN=2

                  mpu_lp_motion_interrupt PROC
;;;1816   
;;;1817   int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1818       unsigned char lpa_freq)
;;;1819   {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;1820       unsigned char data[3];
;;;1821   
;;;1822       if (lpa_freq) {
000008  2c00              CMP      r4,#0
00000a  d070              BEQ      |L22.238|
;;;1823           unsigned char thresh_hw;
;;;1824   
;;;1825   #if defined MPU6050
;;;1826           /* TODO: Make these const/#defines. */
;;;1827           /* 1LSb = 32mg. */
;;;1828           if (thresh > 8160)
00000c  f5b55fff          CMP      r5,#0x1fe0
000010  dd01              BLE      |L22.22|
;;;1829               thresh_hw = 255;
000012  26ff              MOVS     r6,#0xff
000014  e005              B        |L22.34|
                  |L22.22|
;;;1830           else if (thresh < 32)
000016  2d20              CMP      r5,#0x20
000018  da01              BGE      |L22.30|
;;;1831               thresh_hw = 1;
00001a  2601              MOVS     r6,#1
00001c  e001              B        |L22.34|
                  |L22.30|
;;;1832           else
;;;1833               thresh_hw = thresh >> 5;
00001e  f3c51647          UBFX     r6,r5,#5,#8
                  |L22.34|
;;;1834   
;;;1835   #endif
;;;1836   
;;;1837           if (!time)
000022  b907              CBNZ     r7,|L22.38|
;;;1838               /* Minimum duration must be 1ms. */
;;;1839               time = 1;
000024  2701              MOVS     r7,#1
                  |L22.38|
;;;1840   
;;;1841           if (lpa_freq > 40)
000026  2c28              CMP      r4,#0x28
000028  dd02              BLE      |L22.48|
;;;1842               /* At this point, the chip has not been re-configured, so the
;;;1843                * function can safely exit.
;;;1844                */
;;;1845               return -1;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L22.46|
;;;1846   
;;;1847           if (!st.chip_cfg.int_motion_only) {
;;;1848               /* Store current settings for later. */
;;;1849               if (st.chip_cfg.dmp_on) {
;;;1850                   mpu_set_dmp_state(0);
;;;1851                   st.chip_cfg.cache.dmp_on = 1;
;;;1852               } else
;;;1853                   st.chip_cfg.cache.dmp_on = 0;
;;;1854               mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
;;;1855               mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
;;;1856               mpu_get_lpf(&st.chip_cfg.cache.lpf);
;;;1857               mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
;;;1858               st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
;;;1859               mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
;;;1860           }
;;;1861   
;;;1862           /* Disable hardware interrupts for now. */
;;;1863           set_int_enable(0);
;;;1864   
;;;1865           /* Enter full-power accel-only mode. */
;;;1866           mpu_lp_accel_mode(0);
;;;1867   
;;;1868           /* Override current LPF (and HPF) settings to obtain a valid accel
;;;1869            * reading.
;;;1870            */
;;;1871           data[0] = INV_FILTER_256HZ_NOLPF2;
;;;1872           if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;1873               return -1;
;;;1874   
;;;1875           /* NOTE: Digital high pass filter should be configured here. Since this
;;;1876            * driver doesn't modify those bits anywhere, they should already be
;;;1877            * cleared by default.
;;;1878            */
;;;1879   
;;;1880           /* Configure the device to send motion interrupts. */
;;;1881           /* Enable motion interrupt. */
;;;1882           data[0] = BIT_MOT_INT_EN;
;;;1883           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;1884               goto lp_int_restore;
;;;1885   
;;;1886           /* Set motion interrupt parameters. */
;;;1887           data[0] = thresh_hw;
;;;1888           data[1] = time;
;;;1889           if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
;;;1890               goto lp_int_restore;
;;;1891   
;;;1892           /* Force hardware to "lock" current accel sample. */
;;;1893           Timer_Delayms(5);
;;;1894           data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
;;;1895           if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;1896               goto lp_int_restore;
;;;1897   
;;;1898           /* Set up LP accel mode. */
;;;1899           data[0] = BIT_LPA_CYCLE;
;;;1900           if (lpa_freq == 1)
;;;1901               data[1] = INV_LPA_1_25HZ;
;;;1902           else if (lpa_freq <= 5)
;;;1903               data[1] = INV_LPA_5HZ;
;;;1904           else if (lpa_freq <= 20)
;;;1905               data[1] = INV_LPA_20HZ;
;;;1906           else
;;;1907               data[1] = INV_LPA_40HZ;
;;;1908           data[1] = (data[1] << 6) | BIT_STBY_XYZG;
;;;1909           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
;;;1910               goto lp_int_restore;
;;;1911   
;;;1912           st.chip_cfg.int_motion_only = 1;
;;;1913           return 0;
;;;1914   
;;;1915       } else {
;;;1916           /* Don't "restore" the previous state if no state has been saved. */
;;;1917           int ii;
;;;1918           char *cache_ptr = (char*)&st.chip_cfg.cache;
;;;1919           for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
;;;1920               if (cache_ptr[ii] != 0)
;;;1921                   goto lp_int_restore;
;;;1922           }
;;;1923           /* If we reach this point, motion interrupt mode hasn't been used yet. */
;;;1924           return -1;
;;;1925       }
;;;1926   lp_int_restore:
;;;1927       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;1928       st.chip_cfg.gyro_fsr = 0xFF;
;;;1929       st.chip_cfg.accel_fsr = 0xFF;
;;;1930       st.chip_cfg.lpf = 0xFF;
;;;1931       st.chip_cfg.sample_rate = 0xFFFF;
;;;1932       st.chip_cfg.sensors = 0xFF;
;;;1933       st.chip_cfg.fifo_enable = 0xFF;
;;;1934       st.chip_cfg.clk_src = INV_CLK_PLL;
;;;1935       mpu_set_sensors(st.chip_cfg.cache.sensors_on);
;;;1936       mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
;;;1937       mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
;;;1938       mpu_set_lpf(st.chip_cfg.cache.lpf);
;;;1939       mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
;;;1940       mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
;;;1941   
;;;1942       if (st.chip_cfg.cache.dmp_on)
;;;1943           mpu_set_dmp_state(1);
;;;1944   
;;;1945   	return 0;
;;;1946   }
00002e  bdf8              POP      {r3-r7,pc}
                  |L22.48|
000030  4872              LDR      r0,|L22.508|
000032  7d40              LDRB     r0,[r0,#0x15]         ;1847
000034  bb28              CBNZ     r0,|L22.130|
000036  4871              LDR      r0,|L22.508|
000038  f8900024          LDRB     r0,[r0,#0x24]         ;1849
00003c  b138              CBZ      r0,|L22.78|
00003e  2000              MOVS     r0,#0                 ;1850
000040  f7fffffe          BL       mpu_set_dmp_state
000044  2101              MOVS     r1,#1                 ;1851
000046  486d              LDR      r0,|L22.508|
000048  f8801020          STRB     r1,[r0,#0x20]         ;1851
00004c  e003              B        |L22.86|
                  |L22.78|
00004e  2100              MOVS     r1,#0                 ;1853
000050  486a              LDR      r0,|L22.508|
000052  f8801020          STRB     r1,[r0,#0x20]         ;1853
                  |L22.86|
000056  4869              LDR      r0,|L22.508|
000058  3016              ADDS     r0,r0,#0x16           ;1854
00005a  f7fffffe          BL       mpu_get_gyro_fsr
00005e  4867              LDR      r0,|L22.508|
000060  3018              ADDS     r0,r0,#0x18           ;1855
000062  f7fffffe          BL       mpu_get_accel_fsr
000066  4865              LDR      r0,|L22.508|
000068  301a              ADDS     r0,r0,#0x1a           ;1856
00006a  f7fffffe          BL       mpu_get_lpf
00006e  4863              LDR      r0,|L22.508|
000070  301c              ADDS     r0,r0,#0x1c           ;1857
000072  f7fffffe          BL       mpu_get_sample_rate
000076  4861              LDR      r0,|L22.508|
000078  7a81              LDRB     r1,[r0,#0xa]          ;1858
00007a  7781              STRB     r1,[r0,#0x1e]         ;1858
00007c  301f              ADDS     r0,r0,#0x1f           ;1859
00007e  f7fffffe          BL       mpu_get_fifo_config
                  |L22.130|
000082  2000              MOVS     r0,#0                 ;1863
000084  f7fffffe          BL       set_int_enable
000088  2000              MOVS     r0,#0                 ;1866
00008a  f7fffffe          BL       mpu_lp_accel_mode
00008e  2000              MOVS     r0,#0                 ;1871
000090  f88d0000          STRB     r0,[sp,#0]            ;1871
000094  4a59              LDR      r2,|L22.508|
000096  6812              LDR      r2,[r2,#0]            ;1872  ; st
000098  7891              LDRB     r1,[r2,#2]            ;1872
00009a  4a58              LDR      r2,|L22.508|
00009c  6852              LDR      r2,[r2,#4]            ;1872  ; st
00009e  7810              LDRB     r0,[r2,#0]            ;1872
0000a0  466b              MOV      r3,sp                 ;1872
0000a2  2201              MOVS     r2,#1                 ;1872
0000a4  f7fffffe          BL       i2c_write
0000a8  b110              CBZ      r0,|L22.176|
0000aa  f04f30ff          MOV      r0,#0xffffffff        ;1873
0000ae  e7be              B        |L22.46|
                  |L22.176|
0000b0  2040              MOVS     r0,#0x40              ;1882
0000b2  f88d0000          STRB     r0,[sp,#0]            ;1882
0000b6  4a51              LDR      r2,|L22.508|
0000b8  6812              LDR      r2,[r2,#0]            ;1883  ; st
0000ba  7bd1              LDRB     r1,[r2,#0xf]          ;1883
0000bc  4a4f              LDR      r2,|L22.508|
0000be  6852              LDR      r2,[r2,#4]            ;1883  ; st
0000c0  7810              LDRB     r0,[r2,#0]            ;1883
0000c2  466b              MOV      r3,sp                 ;1883
0000c4  2201              MOVS     r2,#1                 ;1883
0000c6  f7fffffe          BL       i2c_write
0000ca  b100              CBZ      r0,|L22.206|
0000cc  e065              B        |L22.410|
                  |L22.206|
0000ce  f88d6000          STRB     r6,[sp,#0]            ;1887
0000d2  f88d7001          STRB     r7,[sp,#1]            ;1888
0000d6  4a49              LDR      r2,|L22.508|
0000d8  6812              LDR      r2,[r2,#0]            ;1889  ; st
0000da  7a11              LDRB     r1,[r2,#8]            ;1889
0000dc  4a47              LDR      r2,|L22.508|
0000de  6852              LDR      r2,[r2,#4]            ;1889  ; st
0000e0  7810              LDRB     r0,[r2,#0]            ;1889
0000e2  466b              MOV      r3,sp                 ;1889
0000e4  2202              MOVS     r2,#2                 ;1889
0000e6  f7fffffe          BL       i2c_write
0000ea  b108              CBZ      r0,|L22.240|
0000ec  e055              B        |L22.410|
                  |L22.238|
0000ee  e047              B        |L22.384|
                  |L22.240|
0000f0  2005              MOVS     r0,#5                 ;1893
0000f2  f7fffffe          BL       Timer_Delayms
0000f6  4841              LDR      r0,|L22.508|
0000f8  7a40              LDRB     r0,[r0,#9]            ;1894
0000fa  2107              MOVS     r1,#7                 ;1894
0000fc  eb0100c0          ADD      r0,r1,r0,LSL #3       ;1894
000100  b2c0              UXTB     r0,r0                 ;1894
000102  f88d0000          STRB     r0,[sp,#0]            ;1894
000106  4a3d              LDR      r2,|L22.508|
000108  6812              LDR      r2,[r2,#0]            ;1895  ; st
00010a  79d1              LDRB     r1,[r2,#7]            ;1895
00010c  4a3b              LDR      r2,|L22.508|
00010e  6852              LDR      r2,[r2,#4]            ;1895  ; st
000110  7810              LDRB     r0,[r2,#0]            ;1895
000112  466b              MOV      r3,sp                 ;1895
000114  2201              MOVS     r2,#1                 ;1895
000116  f7fffffe          BL       i2c_write
00011a  b100              CBZ      r0,|L22.286|
00011c  e03d              B        |L22.410|
                  |L22.286|
00011e  2020              MOVS     r0,#0x20              ;1899
000120  f88d0000          STRB     r0,[sp,#0]            ;1899
000124  2c01              CMP      r4,#1                 ;1900
000126  d103              BNE      |L22.304|
000128  2000              MOVS     r0,#0                 ;1901
00012a  f88d0001          STRB     r0,[sp,#1]            ;1901
00012e  e00e              B        |L22.334|
                  |L22.304|
000130  2c05              CMP      r4,#5                 ;1902
000132  dc03              BGT      |L22.316|
000134  2001              MOVS     r0,#1                 ;1903
000136  f88d0001          STRB     r0,[sp,#1]            ;1903
00013a  e008              B        |L22.334|
                  |L22.316|
00013c  2c14              CMP      r4,#0x14              ;1904
00013e  dc03              BGT      |L22.328|
000140  2002              MOVS     r0,#2                 ;1905
000142  f88d0001          STRB     r0,[sp,#1]            ;1905
000146  e002              B        |L22.334|
                  |L22.328|
000148  2003              MOVS     r0,#3                 ;1907
00014a  f88d0001          STRB     r0,[sp,#1]            ;1907
                  |L22.334|
00014e  f89d0001          LDRB     r0,[sp,#1]            ;1908
000152  2107              MOVS     r1,#7                 ;1908
000154  eb011080          ADD      r0,r1,r0,LSL #6       ;1908
000158  b2c0              UXTB     r0,r0                 ;1908
00015a  f88d0001          STRB     r0,[sp,#1]            ;1908
00015e  4a27              LDR      r2,|L22.508|
000160  6812              LDR      r2,[r2,#0]            ;1909  ; st
000162  7c91              LDRB     r1,[r2,#0x12]         ;1909
000164  4a25              LDR      r2,|L22.508|
000166  6852              LDR      r2,[r2,#4]            ;1909  ; st
000168  7810              LDRB     r0,[r2,#0]            ;1909
00016a  466b              MOV      r3,sp                 ;1909
00016c  2202              MOVS     r2,#2                 ;1909
00016e  f7fffffe          BL       i2c_write
000172  b100              CBZ      r0,|L22.374|
000174  e011              B        |L22.410|
                  |L22.374|
000176  2101              MOVS     r1,#1                 ;1912
000178  4820              LDR      r0,|L22.508|
00017a  7541              STRB     r1,[r0,#0x15]         ;1912
00017c  2000              MOVS     r0,#0                 ;1913
00017e  e756              B        |L22.46|
                  |L22.384|
000180  4a1e              LDR      r2,|L22.508|
000182  3216              ADDS     r2,r2,#0x16           ;1918
000184  2100              MOVS     r1,#0                 ;1919
000186  e003              B        |L22.400|
                  |L22.392|
000188  5c50              LDRB     r0,[r2,r1]            ;1920
00018a  b100              CBZ      r0,|L22.398|
00018c  e005              B        |L22.410|
                  |L22.398|
00018e  1c49              ADDS     r1,r1,#1              ;1919
                  |L22.400|
000190  290c              CMP      r1,#0xc               ;1919
000192  d3f9              BCC      |L22.392|
000194  f04f30ff          MOV      r0,#0xffffffff        ;1924
000198  e749              B        |L22.46|
                  |L22.410|
00019a  20ff              MOVS     r0,#0xff              ;1928
00019c  4917              LDR      r1,|L22.508|
00019e  7208              STRB     r0,[r1,#8]            ;1928
0001a0  21ff              MOVS     r1,#0xff              ;1929
0001a2  4816              LDR      r0,|L22.508|
0001a4  7241              STRB     r1,[r0,#9]            ;1929
0001a6  72c1              STRB     r1,[r0,#0xb]          ;1930
0001a8  f64f71ff          MOV      r1,#0xffff            ;1931
0001ac  81c1              STRH     r1,[r0,#0xe]          ;1931
0001ae  21ff              MOVS     r1,#0xff              ;1932
0001b0  7281              STRB     r1,[r0,#0xa]          ;1932
0001b2  7401              STRB     r1,[r0,#0x10]         ;1933
0001b4  2101              MOVS     r1,#1                 ;1934
0001b6  7301              STRB     r1,[r0,#0xc]          ;1934
0001b8  4601              MOV      r1,r0                 ;1935
0001ba  7f88              LDRB     r0,[r1,#0x1e]         ;1935
0001bc  f7fffffe          BL       mpu_set_sensors
0001c0  490e              LDR      r1,|L22.508|
0001c2  8ac8              LDRH     r0,[r1,#0x16]         ;1936
0001c4  f7fffffe          BL       mpu_set_gyro_fsr
0001c8  490c              LDR      r1,|L22.508|
0001ca  7e08              LDRB     r0,[r1,#0x18]         ;1937
0001cc  f7fffffe          BL       mpu_set_accel_fsr
0001d0  490a              LDR      r1,|L22.508|
0001d2  8b48              LDRH     r0,[r1,#0x1a]         ;1938
0001d4  f7fffffe          BL       mpu_set_lpf
0001d8  4908              LDR      r1,|L22.508|
0001da  8b88              LDRH     r0,[r1,#0x1c]         ;1939
0001dc  f7fffffe          BL       mpu_set_sample_rate
0001e0  4906              LDR      r1,|L22.508|
0001e2  7fc8              LDRB     r0,[r1,#0x1f]         ;1940
0001e4  f7fffffe          BL       mpu_configure_fifo
0001e8  4804              LDR      r0,|L22.508|
0001ea  f8900020          LDRB     r0,[r0,#0x20]         ;1942
0001ee  b110              CBZ      r0,|L22.502|
0001f0  2001              MOVS     r0,#1                 ;1943
0001f2  f7fffffe          BL       mpu_set_dmp_state
                  |L22.502|
0001f6  2000              MOVS     r0,#0                 ;1945
0001f8  e719              B        |L22.46|
                          ENDP

0001fa  0000              DCW      0x0000
                  |L22.508|
                          DCD      ||st||

                          AREA ||i.mpu_read_fifo||, CODE, READONLY, ALIGN=2

                  mpu_read_fifo PROC
;;;1176    */
;;;1177   int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1178           unsigned char *sensors, unsigned char *more)
;;;1179   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4693              MOV      r11,r2
00000a  461d              MOV      r5,r3
00000c  f8dda030          LDR      r10,[sp,#0x30]
;;;1180       /* Assumes maximum packet size is gyro (6) + accel (6). */
;;;1181       unsigned char data[MAX_PACKET_LENGTH];
;;;1182       unsigned char packet_size = 0;
000010  2600              MOVS     r6,#0
;;;1183       unsigned short fifo_count, index = 0;
000012  2400              MOVS     r4,#0
;;;1184   
;;;1185       if (st.chip_cfg.dmp_on)
000014  4876              LDR      r0,|L23.496|
000016  f8900024          LDRB     r0,[r0,#0x24]
00001a  b110              CBZ      r0,|L23.34|
;;;1186           return -1;
00001c  1e60              SUBS     r0,r4,#1
                  |L23.30|
;;;1187   
;;;1188       sensors[0] = 0;
;;;1189       if (!st.chip_cfg.sensors)
;;;1190           return -1;
;;;1191       if (!st.chip_cfg.fifo_enable)
;;;1192           return -1;
;;;1193   
;;;1194       if (st.chip_cfg.fifo_enable & INV_X_GYRO)
;;;1195           packet_size += 2;
;;;1196       if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
;;;1197           packet_size += 2;
;;;1198       if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
;;;1199           packet_size += 2;
;;;1200       if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
;;;1201           packet_size += 6;
;;;1202   
;;;1203       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;1204           return -1;
;;;1205       fifo_count = (data[0] << 8) | data[1];
;;;1206       if (fifo_count < packet_size)
;;;1207           return 0;
;;;1208       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1209           /* FIFO is 50% full, better check overflow bit. */
;;;1210           if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
;;;1211               return -1;
;;;1212           if (data[0] & BIT_FIFO_OVERFLOW) {
;;;1213               mpu_reset_fifo();
;;;1214               return -2;
;;;1215           }
;;;1216       }
;;;1217   //    get_ms((unsigned long*)timestamp);
;;;1218   
;;;1219       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
;;;1220           return -1;
;;;1221       more[0] = fifo_count / packet_size - 1;
;;;1222       sensors[0] = 0;
;;;1223   
;;;1224       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
;;;1225           accel[0] = (data[index+0] << 8) | data[index+1];
;;;1226           accel[1] = (data[index+2] << 8) | data[index+3];
;;;1227           accel[2] = (data[index+4] << 8) | data[index+5];
;;;1228           sensors[0] |= INV_XYZ_ACCEL;
;;;1229           index += 6;
;;;1230       }
;;;1231       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
;;;1232           gyro[0] = (data[index+0] << 8) | data[index+1];
;;;1233           sensors[0] |= INV_X_GYRO;
;;;1234           index += 2;
;;;1235       }
;;;1236       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
;;;1237           gyro[1] = (data[index+0] << 8) | data[index+1];
;;;1238           sensors[0] |= INV_Y_GYRO;
;;;1239           index += 2;
;;;1240       }
;;;1241       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
;;;1242           gyro[2] = (data[index+0] << 8) | data[index+1];
;;;1243           sensors[0] |= INV_Z_GYRO;
;;;1244           index += 2;
;;;1245       }
;;;1246   
;;;1247       return 0;
;;;1248   }
00001e  e8bd8ffe          POP      {r1-r11,pc}
                  |L23.34|
000022  2000              MOVS     r0,#0                 ;1188
000024  7028              STRB     r0,[r5,#0]            ;1188
000026  4872              LDR      r0,|L23.496|
000028  7a80              LDRB     r0,[r0,#0xa]          ;1189
00002a  b910              CBNZ     r0,|L23.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;1190
000030  e7f5              B        |L23.30|
                  |L23.50|
000032  486f              LDR      r0,|L23.496|
000034  7c00              LDRB     r0,[r0,#0x10]         ;1191
000036  b910              CBNZ     r0,|L23.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;1192
00003c  e7ef              B        |L23.30|
                  |L23.62|
00003e  486c              LDR      r0,|L23.496|
000040  7c00              LDRB     r0,[r0,#0x10]         ;1194
000042  f0100f40          TST      r0,#0x40              ;1194
000046  d001              BEQ      |L23.76|
000048  1cb0              ADDS     r0,r6,#2              ;1195
00004a  b2c6              UXTB     r6,r0                 ;1195
                  |L23.76|
00004c  4868              LDR      r0,|L23.496|
00004e  7c00              LDRB     r0,[r0,#0x10]         ;1196
000050  f0100f20          TST      r0,#0x20              ;1196
000054  d001              BEQ      |L23.90|
000056  1cb0              ADDS     r0,r6,#2              ;1197
000058  b2c6              UXTB     r6,r0                 ;1197
                  |L23.90|
00005a  4865              LDR      r0,|L23.496|
00005c  7c00              LDRB     r0,[r0,#0x10]         ;1198
00005e  f0100f10          TST      r0,#0x10              ;1198
000062  d001              BEQ      |L23.104|
000064  1cb0              ADDS     r0,r6,#2              ;1199
000066  b2c6              UXTB     r6,r0                 ;1199
                  |L23.104|
000068  4861              LDR      r0,|L23.496|
00006a  7c00              LDRB     r0,[r0,#0x10]         ;1200
00006c  f0100f08          TST      r0,#8                 ;1200
000070  d001              BEQ      |L23.118|
000072  1db0              ADDS     r0,r6,#6              ;1201
000074  b2c6              UXTB     r6,r0                 ;1201
                  |L23.118|
000076  4a5e              LDR      r2,|L23.496|
000078  6812              LDR      r2,[r2,#0]            ;1203  ; st
00007a  7a91              LDRB     r1,[r2,#0xa]          ;1203
00007c  4a5c              LDR      r2,|L23.496|
00007e  6852              LDR      r2,[r2,#4]            ;1203  ; st
000080  7810              LDRB     r0,[r2,#0]            ;1203
000082  466b              MOV      r3,sp                 ;1203
000084  2202              MOVS     r2,#2                 ;1203
000086  f7fffffe          BL       i2c_read
00008a  b110              CBZ      r0,|L23.146|
00008c  f04f30ff          MOV      r0,#0xffffffff        ;1204
000090  e7c5              B        |L23.30|
                  |L23.146|
000092  f89d0001          LDRB     r0,[sp,#1]            ;1205
000096  f89d1000          LDRB     r1,[sp,#0]            ;1205
00009a  ea402901          ORR      r9,r0,r1,LSL #8       ;1205
00009e  45b1              CMP      r9,r6                 ;1206
0000a0  da01              BGE      |L23.166|
0000a2  2000              MOVS     r0,#0                 ;1207
0000a4  e7bb              B        |L23.30|
                  |L23.166|
0000a6  4852              LDR      r0,|L23.496|
0000a8  6840              LDR      r0,[r0,#4]            ;1208  ; st
0000aa  8840              LDRH     r0,[r0,#2]            ;1208
0000ac  ebb90f60          CMP      r9,r0,ASR #1          ;1208
0000b0  dd17              BLE      |L23.226|
0000b2  4a4f              LDR      r2,|L23.496|
0000b4  6812              LDR      r2,[r2,#0]            ;1210  ; st
0000b6  7c51              LDRB     r1,[r2,#0x11]         ;1210
0000b8  4a4d              LDR      r2,|L23.496|
0000ba  6852              LDR      r2,[r2,#4]            ;1210  ; st
0000bc  7810              LDRB     r0,[r2,#0]            ;1210
0000be  466b              MOV      r3,sp                 ;1210
0000c0  2201              MOVS     r2,#1                 ;1210
0000c2  f7fffffe          BL       i2c_read
0000c6  b110              CBZ      r0,|L23.206|
0000c8  f04f30ff          MOV      r0,#0xffffffff        ;1211
0000cc  e7a7              B        |L23.30|
                  |L23.206|
0000ce  f89d0000          LDRB     r0,[sp,#0]            ;1212
0000d2  f0100f10          TST      r0,#0x10              ;1212
0000d6  d004              BEQ      |L23.226|
0000d8  f7fffffe          BL       mpu_reset_fifo
0000dc  f06f0001          MVN      r0,#1                 ;1214
0000e0  e79d              B        |L23.30|
                  |L23.226|
0000e2  4a43              LDR      r2,|L23.496|
0000e4  6812              LDR      r2,[r2,#0]            ;1219  ; st
0000e6  7ad1              LDRB     r1,[r2,#0xb]          ;1219
0000e8  4a41              LDR      r2,|L23.496|
0000ea  6852              LDR      r2,[r2,#4]            ;1219  ; st
0000ec  7810              LDRB     r0,[r2,#0]            ;1219
0000ee  466b              MOV      r3,sp                 ;1219
0000f0  4632              MOV      r2,r6                 ;1219
0000f2  f7fffffe          BL       i2c_read
0000f6  b110              CBZ      r0,|L23.254|
0000f8  f04f30ff          MOV      r0,#0xffffffff        ;1220
0000fc  e78f              B        |L23.30|
                  |L23.254|
0000fe  fb99f0f6          SDIV     r0,r9,r6              ;1221
000102  1e40              SUBS     r0,r0,#1              ;1221
000104  f88a0000          STRB     r0,[r10,#0]           ;1221
000108  2000              MOVS     r0,#0                 ;1222
00010a  7028              STRB     r0,[r5,#0]            ;1222
00010c  42b4              CMP      r4,r6                 ;1224
00010e  d02a              BEQ      |L23.358|
000110  4837              LDR      r0,|L23.496|
000112  7c00              LDRB     r0,[r0,#0x10]         ;1224
000114  f0100f08          TST      r0,#8                 ;1224
000118  d025              BEQ      |L23.358|
00011a  1c60              ADDS     r0,r4,#1              ;1225
00011c  f81d0000          LDRB     r0,[sp,r0]            ;1225
000120  f81d1004          LDRB     r1,[sp,r4]            ;1225
000124  ea402001          ORR      r0,r0,r1,LSL #8       ;1225
000128  b200              SXTH     r0,r0                 ;1225
00012a  f8a80000          STRH     r0,[r8,#0]            ;1225
00012e  1ce0              ADDS     r0,r4,#3              ;1226
000130  f81d1000          LDRB     r1,[sp,r0]            ;1226
000134  1ca0              ADDS     r0,r4,#2              ;1226
000136  f81d0000          LDRB     r0,[sp,r0]            ;1226
00013a  ea412000          ORR      r0,r1,r0,LSL #8       ;1226
00013e  b200              SXTH     r0,r0                 ;1226
000140  f8a80002          STRH     r0,[r8,#2]            ;1226
000144  1d60              ADDS     r0,r4,#5              ;1227
000146  f81d1000          LDRB     r1,[sp,r0]            ;1227
00014a  1d20              ADDS     r0,r4,#4              ;1227
00014c  f81d0000          LDRB     r0,[sp,r0]            ;1227
000150  ea412000          ORR      r0,r1,r0,LSL #8       ;1227
000154  b200              SXTH     r0,r0                 ;1227
000156  f8a80004          STRH     r0,[r8,#4]            ;1227
00015a  7828              LDRB     r0,[r5,#0]            ;1228
00015c  f0400008          ORR      r0,r0,#8              ;1228
000160  7028              STRB     r0,[r5,#0]            ;1228
000162  1da0              ADDS     r0,r4,#6              ;1229
000164  b284              UXTH     r4,r0                 ;1229
                  |L23.358|
000166  42b4              CMP      r4,r6                 ;1231
000168  d013              BEQ      |L23.402|
00016a  4821              LDR      r0,|L23.496|
00016c  7c00              LDRB     r0,[r0,#0x10]         ;1231
00016e  f0100f40          TST      r0,#0x40              ;1231
000172  d00e              BEQ      |L23.402|
000174  1c60              ADDS     r0,r4,#1              ;1232
000176  f81d0000          LDRB     r0,[sp,r0]            ;1232
00017a  f81d1004          LDRB     r1,[sp,r4]            ;1232
00017e  ea402001          ORR      r0,r0,r1,LSL #8       ;1232
000182  b200              SXTH     r0,r0                 ;1232
000184  8038              STRH     r0,[r7,#0]            ;1232
000186  7828              LDRB     r0,[r5,#0]            ;1233
000188  f0400040          ORR      r0,r0,#0x40           ;1233
00018c  7028              STRB     r0,[r5,#0]            ;1233
00018e  1ca0              ADDS     r0,r4,#2              ;1234
000190  b284              UXTH     r4,r0                 ;1234
                  |L23.402|
000192  42b4              CMP      r4,r6                 ;1236
000194  d013              BEQ      |L23.446|
000196  4816              LDR      r0,|L23.496|
000198  7c00              LDRB     r0,[r0,#0x10]         ;1236
00019a  f0100f20          TST      r0,#0x20              ;1236
00019e  d00e              BEQ      |L23.446|
0001a0  1c60              ADDS     r0,r4,#1              ;1237
0001a2  f81d0000          LDRB     r0,[sp,r0]            ;1237
0001a6  f81d1004          LDRB     r1,[sp,r4]            ;1237
0001aa  ea402001          ORR      r0,r0,r1,LSL #8       ;1237
0001ae  b200              SXTH     r0,r0                 ;1237
0001b0  8078              STRH     r0,[r7,#2]            ;1237
0001b2  7828              LDRB     r0,[r5,#0]            ;1238
0001b4  f0400020          ORR      r0,r0,#0x20           ;1238
0001b8  7028              STRB     r0,[r5,#0]            ;1238
0001ba  1ca0              ADDS     r0,r4,#2              ;1239
0001bc  b284              UXTH     r4,r0                 ;1239
                  |L23.446|
0001be  42b4              CMP      r4,r6                 ;1241
0001c0  d013              BEQ      |L23.490|
0001c2  480b              LDR      r0,|L23.496|
0001c4  7c00              LDRB     r0,[r0,#0x10]         ;1241
0001c6  f0100f10          TST      r0,#0x10              ;1241
0001ca  d00e              BEQ      |L23.490|
0001cc  1c60              ADDS     r0,r4,#1              ;1242
0001ce  f81d0000          LDRB     r0,[sp,r0]            ;1242
0001d2  f81d1004          LDRB     r1,[sp,r4]            ;1242
0001d6  ea402001          ORR      r0,r0,r1,LSL #8       ;1242
0001da  b200              SXTH     r0,r0                 ;1242
0001dc  80b8              STRH     r0,[r7,#4]            ;1242
0001de  7828              LDRB     r0,[r5,#0]            ;1243
0001e0  f0400010          ORR      r0,r0,#0x10           ;1243
0001e4  7028              STRB     r0,[r5,#0]            ;1243
0001e6  1ca0              ADDS     r0,r4,#2              ;1244
0001e8  b284              UXTH     r4,r0                 ;1244
                  |L23.490|
0001ea  2000              MOVS     r0,#0                 ;1247
0001ec  e717              B        |L23.30|
;;;1249   
                          ENDP

0001ee  0000              DCW      0x0000
                  |L23.496|
                          DCD      ||st||

                          AREA ||i.mpu_read_fifo_stream||, CODE, READONLY, ALIGN=2

                  mpu_read_fifo_stream PROC
;;;1256    */
;;;1257   int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1258       unsigned char *more)
;;;1259   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;1260       unsigned char tmp[2];
;;;1261       unsigned short fifo_count;
;;;1262       if (!st.chip_cfg.dmp_on)
000008  4827              LDR      r0,|L24.168|
00000a  f8900024          LDRB     r0,[r0,#0x24]
00000e  b910              CBNZ     r0,|L24.22|
;;;1263           return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L24.20|
;;;1264       if (!st.chip_cfg.sensors)
;;;1265           return -1;
;;;1266   
;;;1267       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
;;;1268           return -1;
;;;1269       fifo_count = (tmp[0] << 8) | tmp[1];
;;;1270       if (fifo_count < length) {
;;;1271           more[0] = 0;
;;;1272           return -1;
;;;1273       }
;;;1274       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1275           /* FIFO is 50% full, better check overflow bit. */
;;;1276           if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
;;;1277               return -1;
;;;1278           if (tmp[0] & BIT_FIFO_OVERFLOW) {
;;;1279       //        mpu_reset_fifo();
;;;1280         //      return -2;
;;;1281           }
;;;1282       }
;;;1283   
;;;1284       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
;;;1285           return -1;
;;;1286       more[0] = fifo_count / length - 1;
;;;1287       return 0;
;;;1288   }
000014  bdf8              POP      {r3-r7,pc}
                  |L24.22|
000016  4824              LDR      r0,|L24.168|
000018  7a80              LDRB     r0,[r0,#0xa]          ;1264
00001a  b910              CBNZ     r0,|L24.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1265
000020  e7f8              B        |L24.20|
                  |L24.34|
000022  4a21              LDR      r2,|L24.168|
000024  6812              LDR      r2,[r2,#0]            ;1267  ; st
000026  7a91              LDRB     r1,[r2,#0xa]          ;1267
000028  4a1f              LDR      r2,|L24.168|
00002a  6852              LDR      r2,[r2,#4]            ;1267  ; st
00002c  7810              LDRB     r0,[r2,#0]            ;1267
00002e  466b              MOV      r3,sp                 ;1267
000030  2202              MOVS     r2,#2                 ;1267
000032  f7fffffe          BL       i2c_read
000036  b110              CBZ      r0,|L24.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;1268
00003c  e7ea              B        |L24.20|
                  |L24.62|
00003e  f89d0001          LDRB     r0,[sp,#1]            ;1269
000042  f89d1000          LDRB     r1,[sp,#0]            ;1269
000046  ea402501          ORR      r5,r0,r1,LSL #8       ;1269
00004a  42a5              CMP      r5,r4                 ;1270
00004c  da03              BGE      |L24.86|
00004e  2000              MOVS     r0,#0                 ;1271
000050  7030              STRB     r0,[r6,#0]            ;1271
000052  1e40              SUBS     r0,r0,#1              ;1272
000054  e7de              B        |L24.20|
                  |L24.86|
000056  4814              LDR      r0,|L24.168|
000058  6840              LDR      r0,[r0,#4]            ;1274  ; st
00005a  8840              LDRH     r0,[r0,#2]            ;1274
00005c  ebb50f60          CMP      r5,r0,ASR #1          ;1274
000060  dd0e              BLE      |L24.128|
000062  4a11              LDR      r2,|L24.168|
000064  6812              LDR      r2,[r2,#0]            ;1276  ; st
000066  7c51              LDRB     r1,[r2,#0x11]         ;1276
000068  4a0f              LDR      r2,|L24.168|
00006a  6852              LDR      r2,[r2,#4]            ;1276  ; st
00006c  7810              LDRB     r0,[r2,#0]            ;1276
00006e  466b              MOV      r3,sp                 ;1276
000070  2201              MOVS     r2,#1                 ;1276
000072  f7fffffe          BL       i2c_read
000076  b110              CBZ      r0,|L24.126|
000078  f04f30ff          MOV      r0,#0xffffffff        ;1277
00007c  e7ca              B        |L24.20|
                  |L24.126|
00007e  bf00              NOP                            ;1278
                  |L24.128|
000080  b2e2              UXTB     r2,r4                 ;1284
000082  4b09              LDR      r3,|L24.168|
000084  681b              LDR      r3,[r3,#0]            ;1284  ; st
000086  7ad9              LDRB     r1,[r3,#0xb]          ;1284
000088  4b07              LDR      r3,|L24.168|
00008a  685b              LDR      r3,[r3,#4]            ;1284  ; st
00008c  7818              LDRB     r0,[r3,#0]            ;1284
00008e  463b              MOV      r3,r7                 ;1284
000090  f7fffffe          BL       i2c_read
000094  b110              CBZ      r0,|L24.156|
000096  f04f30ff          MOV      r0,#0xffffffff        ;1285
00009a  e7bb              B        |L24.20|
                  |L24.156|
00009c  fb95f0f4          SDIV     r0,r5,r4              ;1286
0000a0  1e40              SUBS     r0,r0,#1              ;1286
0000a2  7030              STRB     r0,[r6,#0]            ;1286
0000a4  2000              MOVS     r0,#0                 ;1287
0000a6  e7b5              B        |L24.20|
;;;1289   
                          ENDP

                  |L24.168|
                          DCD      ||st||

                          AREA ||i.mpu_read_mem||, CODE, READONLY, ALIGN=2

                  mpu_read_mem PROC
;;;1697    */
;;;1698   int mpu_read_mem(unsigned short mem_addr, unsigned short length,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1699           unsigned char *data)
;;;1700   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1701       unsigned char tmp[2];
;;;1702   
;;;1703       if (!data)
000008  b916              CBNZ     r6,|L25.16|
;;;1704           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L25.14|
;;;1705       if (!st.chip_cfg.sensors)
;;;1706           return -1;
;;;1707   
;;;1708       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;1709       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;1710   
;;;1711       /* Check bank boundaries. */
;;;1712       if (tmp[1] + length > st.hw->bank_size)
;;;1713           return -1;
;;;1714   
;;;1715       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;1716           return -1;
;;;1717       if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
;;;1718           return -1;
;;;1719       return 0;
;;;1720   }
00000e  bdf8              POP      {r3-r7,pc}
                  |L25.16|
000010  481a              LDR      r0,|L25.124|
000012  7a80              LDRB     r0,[r0,#0xa]          ;1705
000014  b910              CBNZ     r0,|L25.28|
000016  f04f30ff          MOV      r0,#0xffffffff        ;1706
00001a  e7f8              B        |L25.14|
                  |L25.28|
00001c  1220              ASRS     r0,r4,#8              ;1708
00001e  f88d0000          STRB     r0,[sp,#0]            ;1708
000022  b2e0              UXTB     r0,r4                 ;1709
000024  f88d0001          STRB     r0,[sp,#1]            ;1709
000028  f89d0001          LDRB     r0,[sp,#1]            ;1712
00002c  4428              ADD      r0,r0,r5              ;1712
00002e  4913              LDR      r1,|L25.124|
000030  6849              LDR      r1,[r1,#4]            ;1712  ; st
000032  8949              LDRH     r1,[r1,#0xa]          ;1712
000034  4288              CMP      r0,r1                 ;1712
000036  dd02              BLE      |L25.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;1713
00003c  e7e7              B        |L25.14|
                  |L25.62|
00003e  4a0f              LDR      r2,|L25.124|
000040  6812              LDR      r2,[r2,#0]            ;1715  ; st
000042  7e11              LDRB     r1,[r2,#0x18]         ;1715
000044  4a0d              LDR      r2,|L25.124|
000046  6852              LDR      r2,[r2,#4]            ;1715  ; st
000048  7810              LDRB     r0,[r2,#0]            ;1715
00004a  466b              MOV      r3,sp                 ;1715
00004c  2202              MOVS     r2,#2                 ;1715
00004e  f7fffffe          BL       i2c_write
000052  b110              CBZ      r0,|L25.90|
000054  f04f30ff          MOV      r0,#0xffffffff        ;1716
000058  e7d9              B        |L25.14|
                  |L25.90|
00005a  b2ea              UXTB     r2,r5                 ;1717
00005c  4b07              LDR      r3,|L25.124|
00005e  681b              LDR      r3,[r3,#0]            ;1717  ; st
000060  7d59              LDRB     r1,[r3,#0x15]         ;1717
000062  4b06              LDR      r3,|L25.124|
000064  685b              LDR      r3,[r3,#4]            ;1717  ; st
000066  7818              LDRB     r0,[r3,#0]            ;1717
000068  4633              MOV      r3,r6                 ;1717
00006a  f7fffffe          BL       i2c_read
00006e  b110              CBZ      r0,|L25.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;1718
000074  e7cb              B        |L25.14|
                  |L25.118|
000076  2000              MOVS     r0,#0                 ;1719
000078  e7c9              B        |L25.14|
;;;1721   
                          ENDP

00007a  0000              DCW      0x0000
                  |L25.124|
                          DCD      ||st||

                          AREA ||i.mpu_read_reg||, CODE, READONLY, ALIGN=2

                  mpu_read_reg PROC
;;;375     */
;;;376    int mpu_read_reg(unsigned char reg, unsigned char *data)
000000  b570              PUSH     {r4-r6,lr}
;;;377    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;378        if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
000006  480f              LDR      r0,|L26.68|
000008  6800              LDR      r0,[r0,#0]  ; st
00000a  7ac0              LDRB     r0,[r0,#0xb]
00000c  42a0              CMP      r0,r4
00000e  d004              BEQ      |L26.26|
000010  480c              LDR      r0,|L26.68|
000012  6800              LDR      r0,[r0,#0]  ; st
000014  7d40              LDRB     r0,[r0,#0x15]
000016  42a0              CMP      r0,r4
000018  d102              BNE      |L26.32|
                  |L26.26|
;;;379            return -1;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L26.30|
;;;380        if (reg >= st.hw->num_reg)
;;;381            return -1;
;;;382        return i2c_read(st.hw->addr, reg, 1, data);
;;;383    }
00001e  bd70              POP      {r4-r6,pc}
                  |L26.32|
000020  4808              LDR      r0,|L26.68|
000022  6840              LDR      r0,[r0,#4]            ;380  ; st
000024  7900              LDRB     r0,[r0,#4]            ;380
000026  42a0              CMP      r0,r4                 ;380
000028  dc02              BGT      |L26.48|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;381
00002e  e7f6              B        |L26.30|
                  |L26.48|
000030  4904              LDR      r1,|L26.68|
000032  6849              LDR      r1,[r1,#4]            ;382  ; st
000034  7808              LDRB     r0,[r1,#0]            ;382
000036  462b              MOV      r3,r5                 ;382
000038  2201              MOVS     r2,#1                 ;382
00003a  4621              MOV      r1,r4                 ;382
00003c  f7fffffe          BL       i2c_read
000040  e7ed              B        |L26.30|
;;;384    
                          ENDP

000042  0000              DCW      0x0000
                  |L26.68|
                          DCD      ||st||

                          AREA ||i.mpu_reg_dump||, CODE, READONLY, ALIGN=2

                  mpu_reg_dump PROC
;;;357     */
;;;358    int mpu_reg_dump(void)
000000  b538              PUSH     {r3-r5,lr}
;;;359    {
;;;360        unsigned char ii;
;;;361        unsigned char data;
;;;362    
;;;363        for (ii = 0; ii < st.hw->num_reg; ii++) {
000002  2400              MOVS     r4,#0
000004  e019              B        |L27.58|
                  |L27.6|
;;;364            if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
000006  4810              LDR      r0,|L27.72|
000008  6800              LDR      r0,[r0,#0]  ; st
00000a  7ac0              LDRB     r0,[r0,#0xb]
00000c  42a0              CMP      r0,r4
00000e  d004              BEQ      |L27.26|
000010  480d              LDR      r0,|L27.72|
000012  6800              LDR      r0,[r0,#0]  ; st
000014  7d40              LDRB     r0,[r0,#0x15]
000016  42a0              CMP      r0,r4
000018  d100              BNE      |L27.28|
                  |L27.26|
;;;365                continue;
00001a  e00c              B        |L27.54|
                  |L27.28|
;;;366            if (i2c_read(st.hw->addr, ii, 1, &data))
00001c  490a              LDR      r1,|L27.72|
00001e  6849              LDR      r1,[r1,#4]  ; st
000020  7808              LDRB     r0,[r1,#0]
000022  466b              MOV      r3,sp
000024  2201              MOVS     r2,#1
000026  4621              MOV      r1,r4
000028  f7fffffe          BL       i2c_read
00002c  b110              CBZ      r0,|L27.52|
;;;367                return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L27.50|
;;;368        }
;;;369        return 0;
;;;370    }
000032  bd38              POP      {r3-r5,pc}
                  |L27.52|
000034  bf00              NOP                            ;365
                  |L27.54|
000036  1c60              ADDS     r0,r4,#1              ;363
000038  b2c4              UXTB     r4,r0                 ;363
                  |L27.58|
00003a  4803              LDR      r0,|L27.72|
00003c  6840              LDR      r0,[r0,#4]            ;363  ; st
00003e  7900              LDRB     r0,[r0,#4]            ;363
000040  42a0              CMP      r0,r4                 ;363
000042  dce0              BGT      |L27.6|
000044  2000              MOVS     r0,#0                 ;369
000046  e7f4              B        |L27.50|
;;;371    
                          ENDP

                  |L27.72|
                          DCD      ||st||

                          AREA ||i.mpu_reset_fifo||, CODE, READONLY, ALIGN=2

                  mpu_reset_fifo PROC
;;;702     */
;;;703    int mpu_reset_fifo(void)
000000  b508              PUSH     {r3,lr}
;;;704    {
;;;705        unsigned char data;
;;;706    
;;;707        if (!(st.chip_cfg.sensors))
000002  4870              LDR      r0,|L28.452|
000004  7a80              LDRB     r0,[r0,#0xa]
000006  b910              CBNZ     r0,|L28.14|
;;;708            return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L28.12|
;;;709    
;;;710        data = 0;
;;;711        if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;712            return -1;
;;;713        if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;714            return -1;
;;;715        if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;716            return -1;
;;;717    
;;;718        if (st.chip_cfg.dmp_on) {
;;;719            data = BIT_FIFO_RST | BIT_DMP_RST;
;;;720            if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;721                return -1;
;;;722            Timer_Delayms(50);
;;;723            data = BIT_DMP_EN | BIT_FIFO_EN;
;;;724            if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;725                data |= BIT_AUX_IF_EN;
;;;726            if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;727                return -1;
;;;728            if (st.chip_cfg.int_enable)
;;;729                data = BIT_DMP_INT_EN;
;;;730            else
;;;731                data = 0;
;;;732            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;733                return -1;
;;;734            data = 0;
;;;735            if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;736                return -1;
;;;737        } else {
;;;738            data = BIT_FIFO_RST;
;;;739            if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;740                return -1;
;;;741            if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;742                data = BIT_FIFO_EN;
;;;743            else
;;;744                data = BIT_FIFO_EN | BIT_AUX_IF_EN;
;;;745            if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;746                return -1;
;;;747            Timer_Delayms(50);
;;;748            if (st.chip_cfg.int_enable)
;;;749                data = BIT_DATA_RDY_EN;
;;;750            else
;;;751                data = 0;
;;;752            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;753                return -1;
;;;754            if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
;;;755                return -1;
;;;756        }
;;;757        return 0;
;;;758    }
00000c  bd08              POP      {r3,pc}
                  |L28.14|
00000e  2000              MOVS     r0,#0                 ;710
000010  9000              STR      r0,[sp,#0]            ;710
000012  4a6c              LDR      r2,|L28.452|
000014  6812              LDR      r2,[r2,#0]            ;711  ; st
000016  7bd1              LDRB     r1,[r2,#0xf]          ;711
000018  4a6a              LDR      r2,|L28.452|
00001a  6852              LDR      r2,[r2,#4]            ;711  ; st
00001c  7810              LDRB     r0,[r2,#0]            ;711
00001e  466b              MOV      r3,sp                 ;711
000020  2201              MOVS     r2,#1                 ;711
000022  f7fffffe          BL       i2c_write
000026  b110              CBZ      r0,|L28.46|
000028  f04f30ff          MOV      r0,#0xffffffff        ;712
00002c  e7ee              B        |L28.12|
                  |L28.46|
00002e  4a65              LDR      r2,|L28.452|
000030  6812              LDR      r2,[r2,#0]            ;713  ; st
000032  7951              LDRB     r1,[r2,#5]            ;713
000034  4a63              LDR      r2,|L28.452|
000036  6852              LDR      r2,[r2,#4]            ;713  ; st
000038  7810              LDRB     r0,[r2,#0]            ;713
00003a  466b              MOV      r3,sp                 ;713
00003c  2201              MOVS     r2,#1                 ;713
00003e  f7fffffe          BL       i2c_write
000042  b110              CBZ      r0,|L28.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;714
000048  e7e0              B        |L28.12|
                  |L28.74|
00004a  4a5e              LDR      r2,|L28.452|
00004c  6812              LDR      r2,[r2,#0]            ;715  ; st
00004e  7911              LDRB     r1,[r2,#4]            ;715
000050  4a5c              LDR      r2,|L28.452|
000052  6852              LDR      r2,[r2,#4]            ;715  ; st
000054  7810              LDRB     r0,[r2,#0]            ;715
000056  466b              MOV      r3,sp                 ;715
000058  2201              MOVS     r2,#1                 ;715
00005a  f7fffffe          BL       i2c_write
00005e  b110              CBZ      r0,|L28.102|
000060  f04f30ff          MOV      r0,#0xffffffff        ;716
000064  e7d2              B        |L28.12|
                  |L28.102|
000066  4857              LDR      r0,|L28.452|
000068  f8900024          LDRB     r0,[r0,#0x24]         ;718
00006c  2800              CMP      r0,#0                 ;718
00006e  d053              BEQ      |L28.280|
000070  200c              MOVS     r0,#0xc               ;719
000072  9000              STR      r0,[sp,#0]            ;719
000074  4a53              LDR      r2,|L28.452|
000076  6812              LDR      r2,[r2,#0]            ;720  ; st
000078  7911              LDRB     r1,[r2,#4]            ;720
00007a  4a52              LDR      r2,|L28.452|
00007c  6852              LDR      r2,[r2,#4]            ;720  ; st
00007e  7810              LDRB     r0,[r2,#0]            ;720
000080  466b              MOV      r3,sp                 ;720
000082  2201              MOVS     r2,#1                 ;720
000084  f7fffffe          BL       i2c_write
000088  b110              CBZ      r0,|L28.144|
00008a  f04f30ff          MOV      r0,#0xffffffff        ;721
00008e  e7bd              B        |L28.12|
                  |L28.144|
000090  2032              MOVS     r0,#0x32              ;722
000092  f7fffffe          BL       Timer_Delayms
000096  20c0              MOVS     r0,#0xc0              ;723
000098  9000              STR      r0,[sp,#0]            ;723
00009a  484a              LDR      r0,|L28.452|
00009c  7a80              LDRB     r0,[r0,#0xa]          ;724
00009e  f0100f01          TST      r0,#1                 ;724
0000a2  d004              BEQ      |L28.174|
0000a4  f89d0000          LDRB     r0,[sp,#0]            ;725
0000a8  f0400020          ORR      r0,r0,#0x20           ;725
0000ac  9000              STR      r0,[sp,#0]            ;725
                  |L28.174|
0000ae  4a45              LDR      r2,|L28.452|
0000b0  6812              LDR      r2,[r2,#0]            ;726  ; st
0000b2  7911              LDRB     r1,[r2,#4]            ;726
0000b4  4a43              LDR      r2,|L28.452|
0000b6  6852              LDR      r2,[r2,#4]            ;726  ; st
0000b8  7810              LDRB     r0,[r2,#0]            ;726
0000ba  466b              MOV      r3,sp                 ;726
0000bc  2201              MOVS     r2,#1                 ;726
0000be  f7fffffe          BL       i2c_write
0000c2  b110              CBZ      r0,|L28.202|
0000c4  f04f30ff          MOV      r0,#0xffffffff        ;727
0000c8  e7a0              B        |L28.12|
                  |L28.202|
0000ca  483e              LDR      r0,|L28.452|
0000cc  7c40              LDRB     r0,[r0,#0x11]         ;728
0000ce  b110              CBZ      r0,|L28.214|
0000d0  2002              MOVS     r0,#2                 ;729
0000d2  9000              STR      r0,[sp,#0]            ;729
0000d4  e001              B        |L28.218|
                  |L28.214|
0000d6  2000              MOVS     r0,#0                 ;731
0000d8  9000              STR      r0,[sp,#0]            ;731
                  |L28.218|
0000da  4a3a              LDR      r2,|L28.452|
0000dc  6812              LDR      r2,[r2,#0]            ;732  ; st
0000de  7bd1              LDRB     r1,[r2,#0xf]          ;732
0000e0  4a38              LDR      r2,|L28.452|
0000e2  6852              LDR      r2,[r2,#4]            ;732  ; st
0000e4  7810              LDRB     r0,[r2,#0]            ;732
0000e6  466b              MOV      r3,sp                 ;732
0000e8  2201              MOVS     r2,#1                 ;732
0000ea  f7fffffe          BL       i2c_write
0000ee  b110              CBZ      r0,|L28.246|
0000f0  f04f30ff          MOV      r0,#0xffffffff        ;733
0000f4  e78a              B        |L28.12|
                  |L28.246|
0000f6  2000              MOVS     r0,#0                 ;734
0000f8  9000              STR      r0,[sp,#0]            ;734
0000fa  4a32              LDR      r2,|L28.452|
0000fc  6812              LDR      r2,[r2,#0]            ;735  ; st
0000fe  7951              LDRB     r1,[r2,#5]            ;735
000100  4a30              LDR      r2,|L28.452|
000102  6852              LDR      r2,[r2,#4]            ;735  ; st
000104  7810              LDRB     r0,[r2,#0]            ;735
000106  466b              MOV      r3,sp                 ;735
000108  2201              MOVS     r2,#1                 ;735
00010a  f7fffffe          BL       i2c_write
00010e  2800              CMP      r0,#0                 ;735
000110  d055              BEQ      |L28.446|
000112  f04f30ff          MOV      r0,#0xffffffff        ;736
000116  e779              B        |L28.12|
                  |L28.280|
000118  2004              MOVS     r0,#4                 ;738
00011a  9000              STR      r0,[sp,#0]            ;738
00011c  4a29              LDR      r2,|L28.452|
00011e  6812              LDR      r2,[r2,#0]            ;739  ; st
000120  7911              LDRB     r1,[r2,#4]            ;739
000122  4a28              LDR      r2,|L28.452|
000124  6852              LDR      r2,[r2,#4]            ;739  ; st
000126  7810              LDRB     r0,[r2,#0]            ;739
000128  466b              MOV      r3,sp                 ;739
00012a  2201              MOVS     r2,#1                 ;739
00012c  f7fffffe          BL       i2c_write
000130  b110              CBZ      r0,|L28.312|
000132  f04f30ff          MOV      r0,#0xffffffff        ;740
000136  e769              B        |L28.12|
                  |L28.312|
000138  4822              LDR      r0,|L28.452|
00013a  7c80              LDRB     r0,[r0,#0x12]         ;741
00013c  b920              CBNZ     r0,|L28.328|
00013e  4821              LDR      r0,|L28.452|
000140  7a80              LDRB     r0,[r0,#0xa]          ;741
000142  f0100f01          TST      r0,#1                 ;741
000146  d102              BNE      |L28.334|
                  |L28.328|
000148  2040              MOVS     r0,#0x40              ;742
00014a  9000              STR      r0,[sp,#0]            ;742
00014c  e001              B        |L28.338|
                  |L28.334|
00014e  2060              MOVS     r0,#0x60              ;744
000150  9000              STR      r0,[sp,#0]            ;744
                  |L28.338|
000152  4a1c              LDR      r2,|L28.452|
000154  6812              LDR      r2,[r2,#0]            ;745  ; st
000156  7911              LDRB     r1,[r2,#4]            ;745
000158  4a1a              LDR      r2,|L28.452|
00015a  6852              LDR      r2,[r2,#4]            ;745  ; st
00015c  7810              LDRB     r0,[r2,#0]            ;745
00015e  466b              MOV      r3,sp                 ;745
000160  2201              MOVS     r2,#1                 ;745
000162  f7fffffe          BL       i2c_write
000166  b110              CBZ      r0,|L28.366|
000168  f04f30ff          MOV      r0,#0xffffffff        ;746
00016c  e74e              B        |L28.12|
                  |L28.366|
00016e  2032              MOVS     r0,#0x32              ;747
000170  f7fffffe          BL       Timer_Delayms
000174  4813              LDR      r0,|L28.452|
000176  7c40              LDRB     r0,[r0,#0x11]         ;748
000178  b110              CBZ      r0,|L28.384|
00017a  2001              MOVS     r0,#1                 ;749
00017c  9000              STR      r0,[sp,#0]            ;749
00017e  e001              B        |L28.388|
                  |L28.384|
000180  2000              MOVS     r0,#0                 ;751
000182  9000              STR      r0,[sp,#0]            ;751
                  |L28.388|
000184  4a0f              LDR      r2,|L28.452|
000186  6812              LDR      r2,[r2,#0]            ;752  ; st
000188  7bd1              LDRB     r1,[r2,#0xf]          ;752
00018a  4a0e              LDR      r2,|L28.452|
00018c  6852              LDR      r2,[r2,#4]            ;752  ; st
00018e  7810              LDRB     r0,[r2,#0]            ;752
000190  466b              MOV      r3,sp                 ;752
000192  2201              MOVS     r2,#1                 ;752
000194  f7fffffe          BL       i2c_write
000198  b110              CBZ      r0,|L28.416|
00019a  f04f30ff          MOV      r0,#0xffffffff        ;753
00019e  e735              B        |L28.12|
                  |L28.416|
0001a0  4a08              LDR      r2,|L28.452|
0001a2  6812              LDR      r2,[r2,#0]            ;754  ; st
0001a4  7951              LDRB     r1,[r2,#5]            ;754
0001a6  4a07              LDR      r2,|L28.452|
0001a8  6852              LDR      r2,[r2,#4]            ;754  ; st
0001aa  7810              LDRB     r0,[r2,#0]            ;754
0001ac  4b05              LDR      r3,|L28.452|
0001ae  3310              ADDS     r3,r3,#0x10           ;754
0001b0  2201              MOVS     r2,#1                 ;754
0001b2  f7fffffe          BL       i2c_write
0001b6  b110              CBZ      r0,|L28.446|
0001b8  f04f30ff          MOV      r0,#0xffffffff        ;755
0001bc  e726              B        |L28.12|
                  |L28.446|
0001be  2000              MOVS     r0,#0                 ;757
0001c0  e724              B        |L28.12|
;;;759    
                          ENDP

0001c2  0000              DCW      0x0000
                  |L28.452|
                          DCD      ||st||

                          AREA ||i.mpu_run_self_test||, CODE, READONLY, ALIGN=2

                  mpu_run_self_test PROC
;;;1577    ***/
;;;1578   int mpu_run_self_test(long *gyro, long *accel)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1579   {
000004  b08d              SUB      sp,sp,#0x34
000006  4683              MOV      r11,r0
000008  460f              MOV      r7,r1
;;;1580   #ifdef MPU6050
;;;1581       const unsigned char tries = 2;
00000a  2002              MOVS     r0,#2
00000c  900c              STR      r0,[sp,#0x30]
;;;1582       long gyro_st[3], accel_st[3];
;;;1583       unsigned char accel_result, gyro_result;
;;;1584       int ii;
;;;1585   #endif
;;;1586       int result;
;;;1587       unsigned char accel_fsr, fifo_sensors, sensors_on;
;;;1588       unsigned short gyro_fsr, sample_rate, lpf;
;;;1589       unsigned char dmp_was_on;
;;;1590   
;;;1591       if (st.chip_cfg.dmp_on) {
00000e  4842              LDR      r0,|L29.280|
000010  f8900024          LDRB     r0,[r0,#0x24]
000014  b120              CBZ      r0,|L29.32|
;;;1592           mpu_set_dmp_state(0);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       mpu_set_dmp_state
;;;1593           dmp_was_on = 1;
00001c  2601              MOVS     r6,#1
00001e  e000              B        |L29.34|
                  |L29.32|
;;;1594       } else
;;;1595           dmp_was_on = 0;
000020  2600              MOVS     r6,#0
                  |L29.34|
;;;1596   
;;;1597       /* Get initial settings. */
;;;1598       mpu_get_gyro_fsr(&gyro_fsr);
000022  a803              ADD      r0,sp,#0xc
000024  f7fffffe          BL       mpu_get_gyro_fsr
;;;1599       mpu_get_accel_fsr(&accel_fsr);
000028  a805              ADD      r0,sp,#0x14
00002a  f7fffffe          BL       mpu_get_accel_fsr
;;;1600       mpu_get_lpf(&lpf);
00002e  a801              ADD      r0,sp,#4
000030  f7fffffe          BL       mpu_get_lpf
;;;1601       mpu_get_sample_rate(&sample_rate);
000034  a802              ADD      r0,sp,#8
000036  f7fffffe          BL       mpu_get_sample_rate
;;;1602       sensors_on = st.chip_cfg.sensors;
00003a  4837              LDR      r0,|L29.280|
00003c  f890a00a          LDRB     r10,[r0,#0xa]
;;;1603       mpu_get_fifo_config(&fifo_sensors);
000040  a804              ADD      r0,sp,#0x10
000042  f7fffffe          BL       mpu_get_fifo_config
;;;1604   
;;;1605       /* For older chips, the self-test will be different. */
;;;1606   #if defined MPU6050
;;;1607       for (ii = 0; ii < tries; ii++)
000046  2400              MOVS     r4,#0
000048  e007              B        |L29.90|
                  |L29.74|
;;;1608           if (!get_st_biases(gyro, accel, 0))
00004a  2200              MOVS     r2,#0
00004c  4639              MOV      r1,r7
00004e  4658              MOV      r0,r11
000050  f7fffffe          BL       get_st_biases
000054  b900              CBNZ     r0,|L29.88|
;;;1609               break;
000056  e002              B        |L29.94|
                  |L29.88|
000058  1c64              ADDS     r4,r4,#1              ;1607
                  |L29.90|
00005a  2c02              CMP      r4,#2                 ;1607
00005c  dbf5              BLT      |L29.74|
                  |L29.94|
00005e  bf00              NOP      
;;;1610       if (ii == tries) {
000060  2c02              CMP      r4,#2
000062  d101              BNE      |L29.104|
;;;1611           /* If we reach this point, we most likely encountered an I2C error.
;;;1612            * We'll just report an error for all three sensors.
;;;1613            */
;;;1614           result = 0;
000064  2500              MOVS     r5,#0
;;;1615           goto restore;
000066  e028              B        |L29.186|
                  |L29.104|
;;;1616       }
;;;1617       for (ii = 0; ii < tries; ii++)
000068  2400              MOVS     r4,#0
00006a  e007              B        |L29.124|
                  |L29.108|
;;;1618           if (!get_st_biases(gyro_st, accel_st, 1))
00006c  2201              MOVS     r2,#1
00006e  a906              ADD      r1,sp,#0x18
000070  a809              ADD      r0,sp,#0x24
000072  f7fffffe          BL       get_st_biases
000076  b900              CBNZ     r0,|L29.122|
;;;1619               break;
000078  e002              B        |L29.128|
                  |L29.122|
00007a  1c64              ADDS     r4,r4,#1              ;1617
                  |L29.124|
00007c  2c02              CMP      r4,#2                 ;1617
00007e  dbf5              BLT      |L29.108|
                  |L29.128|
000080  bf00              NOP      
;;;1620       if (ii == tries) {
000082  2c02              CMP      r4,#2
000084  d101              BNE      |L29.138|
;;;1621           /* Again, probably an I2C error. */
;;;1622           result = 0;
000086  2500              MOVS     r5,#0
;;;1623           goto restore;
000088  e017              B        |L29.186|
                  |L29.138|
;;;1624       }
;;;1625       accel_result = accel_self_test(accel, accel_st);
00008a  a906              ADD      r1,sp,#0x18
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       accel_self_test
000092  f00008ff          AND      r8,r0,#0xff
;;;1626       gyro_result = gyro_self_test(gyro, gyro_st);
000096  a909              ADD      r1,sp,#0x24
000098  4658              MOV      r0,r11
00009a  f7fffffe          BL       gyro_self_test
00009e  f00009ff          AND      r9,r0,#0xff
;;;1627   
;;;1628       result = 0;
0000a2  2500              MOVS     r5,#0
;;;1629       if (!gyro_result)
0000a4  f1b90f00          CMP      r9,#0
0000a8  d101              BNE      |L29.174|
;;;1630           result |= 0x01;
0000aa  f0450501          ORR      r5,r5,#1
                  |L29.174|
;;;1631       if (!accel_result)
0000ae  f1b80f00          CMP      r8,#0
0000b2  d101              BNE      |L29.184|
;;;1632           result |= 0x02;
0000b4  f0450502          ORR      r5,r5,#2
                  |L29.184|
;;;1633   restore:
0000b8  bf00              NOP      
                  |L29.186|
;;;1634   #endif
;;;1635       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;1636       st.chip_cfg.gyro_fsr = 0xFF;
0000ba  20ff              MOVS     r0,#0xff
0000bc  4916              LDR      r1,|L29.280|
0000be  7208              STRB     r0,[r1,#8]
;;;1637       st.chip_cfg.accel_fsr = 0xFF;
0000c0  21ff              MOVS     r1,#0xff
0000c2  4815              LDR      r0,|L29.280|
0000c4  7241              STRB     r1,[r0,#9]
;;;1638       st.chip_cfg.lpf = 0xFF;
0000c6  72c1              STRB     r1,[r0,#0xb]
;;;1639       st.chip_cfg.sample_rate = 0xFFFF;
0000c8  f64f71ff          MOV      r1,#0xffff
0000cc  81c1              STRH     r1,[r0,#0xe]
;;;1640       st.chip_cfg.sensors = 0xFF;
0000ce  21ff              MOVS     r1,#0xff
0000d0  7281              STRB     r1,[r0,#0xa]
;;;1641       st.chip_cfg.fifo_enable = 0xFF;
0000d2  7401              STRB     r1,[r0,#0x10]
;;;1642       st.chip_cfg.clk_src = INV_CLK_PLL;
0000d4  2101              MOVS     r1,#1
0000d6  7301              STRB     r1,[r0,#0xc]
;;;1643       mpu_set_gyro_fsr(gyro_fsr);
0000d8  f8bd000c          LDRH     r0,[sp,#0xc]
0000dc  f7fffffe          BL       mpu_set_gyro_fsr
;;;1644       mpu_set_accel_fsr(accel_fsr);
0000e0  f89d0014          LDRB     r0,[sp,#0x14]
0000e4  f7fffffe          BL       mpu_set_accel_fsr
;;;1645       mpu_set_lpf(lpf);
0000e8  f8bd0004          LDRH     r0,[sp,#4]
0000ec  f7fffffe          BL       mpu_set_lpf
;;;1646       mpu_set_sample_rate(sample_rate);
0000f0  f8bd0008          LDRH     r0,[sp,#8]
0000f4  f7fffffe          BL       mpu_set_sample_rate
;;;1647       mpu_set_sensors(sensors_on);
0000f8  4650              MOV      r0,r10
0000fa  f7fffffe          BL       mpu_set_sensors
;;;1648       mpu_configure_fifo(fifo_sensors);
0000fe  f89d0010          LDRB     r0,[sp,#0x10]
000102  f7fffffe          BL       mpu_configure_fifo
;;;1649   
;;;1650       if (dmp_was_on)
000106  b116              CBZ      r6,|L29.270|
;;;1651           mpu_set_dmp_state(1);
000108  2001              MOVS     r0,#1
00010a  f7fffffe          BL       mpu_set_dmp_state
                  |L29.270|
;;;1652   
;;;1653       return result;
00010e  4628              MOV      r0,r5
;;;1654   }
000110  b00d              ADD      sp,sp,#0x34
000112  e8bd8ff0          POP      {r4-r11,pc}
;;;1655   
                          ENDP

000116  0000              DCW      0x0000
                  |L29.280|
                          DCD      ||st||

                          AREA ||i.mpu_set_accel_bias||, CODE, READONLY, ALIGN=2

                  mpu_set_accel_bias PROC
;;;653     */
;;;654    int mpu_set_accel_bias(const long *accel_bias)
000000  b510              PUSH     {r4,lr}
;;;655    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;656        unsigned char data[6];
;;;657        short accel_hw[3];
;;;658        short got_accel[3];
;;;659        short fg[3];
;;;660    
;;;661        if (!accel_bias)
000006  b91c              CBNZ     r4,|L30.16|
;;;662            return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L30.12|
;;;663        if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
;;;664            return 0;
;;;665    
;;;666        if (i2c_read(st.hw->addr, 3, 3, data))
;;;667            return -1;
;;;668        fg[0] = ((data[0] >> 4) + 8) & 0xf;
;;;669        fg[1] = ((data[1] >> 4) + 8) & 0xf;
;;;670        fg[2] = ((data[2] >> 4) + 8) & 0xf;
;;;671    
;;;672        accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
;;;673        accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
;;;674        accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
;;;675    
;;;676        if (i2c_read(st.hw->addr, 0x06, 6, data))
;;;677            return -1;
;;;678    
;;;679        got_accel[0] = ((short)data[0] << 8) | data[1];
;;;680        got_accel[1] = ((short)data[2] << 8) | data[3];
;;;681        got_accel[2] = ((short)data[4] << 8) | data[5];
;;;682    
;;;683        accel_hw[0] += got_accel[0];
;;;684        accel_hw[1] += got_accel[1];
;;;685        accel_hw[2] += got_accel[2];
;;;686    
;;;687        data[0] = (accel_hw[0] >> 8) & 0xff;
;;;688        data[1] = (accel_hw[0]) & 0xff;
;;;689        data[2] = (accel_hw[1] >> 8) & 0xff;
;;;690        data[3] = (accel_hw[1]) & 0xff;
;;;691        data[4] = (accel_hw[2] >> 8) & 0xff;
;;;692        data[5] = (accel_hw[2]) & 0xff;
;;;693    
;;;694        if (i2c_write(st.hw->addr, 0x06, 6, data))
;;;695            return -1;
;;;696        return 0;
;;;697    }
00000c  b008              ADD      sp,sp,#0x20
00000e  bd10              POP      {r4,pc}
                  |L30.16|
000010  6820              LDR      r0,[r4,#0]            ;663
000012  b928              CBNZ     r0,|L30.32|
000014  6860              LDR      r0,[r4,#4]            ;663
000016  b918              CBNZ     r0,|L30.32|
000018  68a0              LDR      r0,[r4,#8]            ;663
00001a  b908              CBNZ     r0,|L30.32|
00001c  2000              MOVS     r0,#0                 ;664
00001e  e7f5              B        |L30.12|
                  |L30.32|
000020  4956              LDR      r1,|L30.380|
000022  6849              LDR      r1,[r1,#4]            ;666  ; st
000024  7808              LDRB     r0,[r1,#0]            ;666
000026  ab06              ADD      r3,sp,#0x18           ;666
000028  2203              MOVS     r2,#3                 ;666
00002a  4611              MOV      r1,r2                 ;666
00002c  f7fffffe          BL       i2c_read
000030  b110              CBZ      r0,|L30.56|
000032  f04f30ff          MOV      r0,#0xffffffff        ;667
000036  e7e9              B        |L30.12|
                  |L30.56|
000038  f89d0018          LDRB     r0,[sp,#0x18]         ;668
00003c  2108              MOVS     r1,#8                 ;668
00003e  eb011020          ADD      r0,r1,r0,ASR #4       ;668
000042  f000000f          AND      r0,r0,#0xf            ;668
000046  f8ad0000          STRH     r0,[sp,#0]            ;668
00004a  f89d0019          LDRB     r0,[sp,#0x19]         ;669
00004e  eb011020          ADD      r0,r1,r0,ASR #4       ;669
000052  f000000f          AND      r0,r0,#0xf            ;669
000056  f8ad0002          STRH     r0,[sp,#2]            ;669
00005a  f89d001a          LDRB     r0,[sp,#0x1a]         ;670
00005e  eb011020          ADD      r0,r1,r0,ASR #4       ;670
000062  f000000f          AND      r0,r0,#0xf            ;670
000066  f8ad0004          STRH     r0,[sp,#4]            ;670
00006a  6820              LDR      r0,[r4,#0]            ;672
00006c  0041              LSLS     r1,r0,#1              ;672
00006e  f9bd0000          LDRSH    r0,[sp,#0]            ;672
000072  3040              ADDS     r0,r0,#0x40           ;672
000074  fb91f0f0          SDIV     r0,r1,r0              ;672
000078  b200              SXTH     r0,r0                 ;672
00007a  f8ad0010          STRH     r0,[sp,#0x10]         ;672
00007e  6860              LDR      r0,[r4,#4]            ;673
000080  0041              LSLS     r1,r0,#1              ;673
000082  f9bd0002          LDRSH    r0,[sp,#2]            ;673
000086  3040              ADDS     r0,r0,#0x40           ;673
000088  fb91f0f0          SDIV     r0,r1,r0              ;673
00008c  b200              SXTH     r0,r0                 ;673
00008e  f8ad0012          STRH     r0,[sp,#0x12]         ;673
000092  68a0              LDR      r0,[r4,#8]            ;674
000094  0041              LSLS     r1,r0,#1              ;674
000096  f9bd0004          LDRSH    r0,[sp,#4]            ;674
00009a  3040              ADDS     r0,r0,#0x40           ;674
00009c  fb91f0f0          SDIV     r0,r1,r0              ;674
0000a0  b200              SXTH     r0,r0                 ;674
0000a2  f8ad0014          STRH     r0,[sp,#0x14]         ;674
0000a6  4935              LDR      r1,|L30.380|
0000a8  6849              LDR      r1,[r1,#4]            ;676  ; st
0000aa  7808              LDRB     r0,[r1,#0]            ;676
0000ac  ab06              ADD      r3,sp,#0x18           ;676
0000ae  2206              MOVS     r2,#6                 ;676
0000b0  4611              MOV      r1,r2                 ;676
0000b2  f7fffffe          BL       i2c_read
0000b6  b110              CBZ      r0,|L30.190|
0000b8  f04f30ff          MOV      r0,#0xffffffff        ;677
0000bc  e7a6              B        |L30.12|
                  |L30.190|
0000be  f89d0019          LDRB     r0,[sp,#0x19]         ;679
0000c2  f89d1018          LDRB     r1,[sp,#0x18]         ;679
0000c6  ea402001          ORR      r0,r0,r1,LSL #8       ;679
0000ca  b200              SXTH     r0,r0                 ;679
0000cc  f8ad0008          STRH     r0,[sp,#8]            ;679
0000d0  f89d001b          LDRB     r0,[sp,#0x1b]         ;680
0000d4  f89d101a          LDRB     r1,[sp,#0x1a]         ;680
0000d8  ea402001          ORR      r0,r0,r1,LSL #8       ;680
0000dc  b200              SXTH     r0,r0                 ;680
0000de  f8ad000a          STRH     r0,[sp,#0xa]          ;680
0000e2  f89d001d          LDRB     r0,[sp,#0x1d]         ;681
0000e6  f89d101c          LDRB     r1,[sp,#0x1c]         ;681
0000ea  ea402001          ORR      r0,r0,r1,LSL #8       ;681
0000ee  b200              SXTH     r0,r0                 ;681
0000f0  f8ad000c          STRH     r0,[sp,#0xc]          ;681
0000f4  f8bd0010          LDRH     r0,[sp,#0x10]         ;683
0000f8  f8bd1008          LDRH     r1,[sp,#8]            ;683
0000fc  4408              ADD      r0,r0,r1              ;683
0000fe  b200              SXTH     r0,r0                 ;683
000100  f8ad0010          STRH     r0,[sp,#0x10]         ;683
000104  f8bd0012          LDRH     r0,[sp,#0x12]         ;684
000108  f8bd100a          LDRH     r1,[sp,#0xa]          ;684
00010c  4408              ADD      r0,r0,r1              ;684
00010e  b200              SXTH     r0,r0                 ;684
000110  f8ad0012          STRH     r0,[sp,#0x12]         ;684
000114  f8bd0014          LDRH     r0,[sp,#0x14]         ;685
000118  f8bd100c          LDRH     r1,[sp,#0xc]          ;685
00011c  4408              ADD      r0,r0,r1              ;685
00011e  b200              SXTH     r0,r0                 ;685
000120  f8ad0014          STRH     r0,[sp,#0x14]         ;685
000124  f8bd0010          LDRH     r0,[sp,#0x10]         ;687
000128  0a00              LSRS     r0,r0,#8              ;687
00012a  f88d0018          STRB     r0,[sp,#0x18]         ;687
00012e  f8bd0010          LDRH     r0,[sp,#0x10]         ;688
000132  b2c0              UXTB     r0,r0                 ;688
000134  f88d0019          STRB     r0,[sp,#0x19]         ;688
000138  f8bd0012          LDRH     r0,[sp,#0x12]         ;689
00013c  0a00              LSRS     r0,r0,#8              ;689
00013e  f88d001a          STRB     r0,[sp,#0x1a]         ;689
000142  f8bd0012          LDRH     r0,[sp,#0x12]         ;690
000146  b2c0              UXTB     r0,r0                 ;690
000148  f88d001b          STRB     r0,[sp,#0x1b]         ;690
00014c  f8bd0014          LDRH     r0,[sp,#0x14]         ;691
000150  0a00              LSRS     r0,r0,#8              ;691
000152  f88d001c          STRB     r0,[sp,#0x1c]         ;691
000156  f8bd0014          LDRH     r0,[sp,#0x14]         ;692
00015a  b2c0              UXTB     r0,r0                 ;692
00015c  f88d001d          STRB     r0,[sp,#0x1d]         ;692
000160  4906              LDR      r1,|L30.380|
000162  6849              LDR      r1,[r1,#4]            ;694  ; st
000164  7808              LDRB     r0,[r1,#0]            ;694
000166  ab06              ADD      r3,sp,#0x18           ;694
000168  2206              MOVS     r2,#6                 ;694
00016a  4611              MOV      r1,r2                 ;694
00016c  f7fffffe          BL       i2c_write
000170  b110              CBZ      r0,|L30.376|
000172  f04f30ff          MOV      r0,#0xffffffff        ;695
000176  e749              B        |L30.12|
                  |L30.376|
000178  2000              MOVS     r0,#0                 ;696
00017a  e747              B        |L30.12|
;;;698    
                          ENDP

                  |L30.380|
                          DCD      ||st||

                          AREA ||i.mpu_set_accel_fsr||, CODE, READONLY, ALIGN=2

                  mpu_set_accel_fsr PROC
;;;850     */
;;;851    int mpu_set_accel_fsr(unsigned char fsr)
000000  b538              PUSH     {r3-r5,lr}
;;;852    {
000002  4604              MOV      r4,r0
;;;853        unsigned char data;
;;;854    
;;;855        if (!(st.chip_cfg.sensors))
000004  481e              LDR      r0,|L31.128|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L31.16|
;;;856            return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L31.14|
;;;857    
;;;858        switch (fsr) {
;;;859        case 2:
;;;860            data = INV_FSR_2G << 3;
;;;861            break;
;;;862        case 4:
;;;863            data = INV_FSR_4G << 3;
;;;864            break;
;;;865        case 8:
;;;866            data = INV_FSR_8G << 3;
;;;867            break;
;;;868        case 16:
;;;869            data = INV_FSR_16G << 3;
;;;870            break;
;;;871        default:
;;;872            return -1;
;;;873        }
;;;874    
;;;875        if (st.chip_cfg.accel_fsr == (data >> 3))
;;;876            return 0;
;;;877        if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
;;;878            return -1;
;;;879        st.chip_cfg.accel_fsr = data >> 3;
;;;880        return 0;
;;;881    }
00000e  bd38              POP      {r3-r5,pc}
                  |L31.16|
000010  2c02              CMP      r4,#2                 ;858
000012  d006              BEQ      |L31.34|
000014  2c04              CMP      r4,#4                 ;858
000016  d007              BEQ      |L31.40|
000018  2c08              CMP      r4,#8                 ;858
00001a  d008              BEQ      |L31.46|
00001c  2c10              CMP      r4,#0x10              ;858
00001e  d10c              BNE      |L31.58|
000020  e008              B        |L31.52|
                  |L31.34|
000022  2000              MOVS     r0,#0                 ;860
000024  9000              STR      r0,[sp,#0]            ;860
000026  e00b              B        |L31.64|
                  |L31.40|
000028  2008              MOVS     r0,#8                 ;863
00002a  9000              STR      r0,[sp,#0]            ;863
00002c  e008              B        |L31.64|
                  |L31.46|
00002e  2010              MOVS     r0,#0x10              ;866
000030  9000              STR      r0,[sp,#0]            ;866
000032  e005              B        |L31.64|
                  |L31.52|
000034  2018              MOVS     r0,#0x18              ;869
000036  9000              STR      r0,[sp,#0]            ;869
000038  e002              B        |L31.64|
                  |L31.58|
00003a  f04f30ff          MOV      r0,#0xffffffff        ;872
00003e  e7e6              B        |L31.14|
                  |L31.64|
000040  bf00              NOP                            ;861
000042  480f              LDR      r0,|L31.128|
000044  7a40              LDRB     r0,[r0,#9]            ;875
000046  f89d1000          LDRB     r1,[sp,#0]            ;875
00004a  ebb00fe1          CMP      r0,r1,ASR #3          ;875
00004e  d101              BNE      |L31.84|
000050  2000              MOVS     r0,#0                 ;876
000052  e7dc              B        |L31.14|
                  |L31.84|
000054  4a0a              LDR      r2,|L31.128|
000056  6812              LDR      r2,[r2,#0]            ;877  ; st
000058  79d1              LDRB     r1,[r2,#7]            ;877
00005a  4a09              LDR      r2,|L31.128|
00005c  6852              LDR      r2,[r2,#4]            ;877  ; st
00005e  7810              LDRB     r0,[r2,#0]            ;877
000060  466b              MOV      r3,sp                 ;877
000062  2201              MOVS     r2,#1                 ;877
000064  f7fffffe          BL       i2c_write
000068  b110              CBZ      r0,|L31.112|
00006a  f04f30ff          MOV      r0,#0xffffffff        ;878
00006e  e7ce              B        |L31.14|
                  |L31.112|
000070  f89d0000          LDRB     r0,[sp,#0]            ;879
000074  10c1              ASRS     r1,r0,#3              ;879
000076  4802              LDR      r0,|L31.128|
000078  7241              STRB     r1,[r0,#9]            ;879
00007a  2000              MOVS     r0,#0                 ;880
00007c  e7c7              B        |L31.14|
;;;882    
                          ENDP

00007e  0000              DCW      0x0000
                  |L31.128|
                          DCD      ||st||

                          AREA ||i.mpu_set_bypass||, CODE, READONLY, ALIGN=2

                  mpu_set_bypass PROC
;;;1294    */
;;;1295   int mpu_set_bypass(unsigned char bypass_on)
000000  b538              PUSH     {r3-r5,lr}
;;;1296   {
000002  4604              MOV      r4,r0
;;;1297       unsigned char tmp;
;;;1298   
;;;1299       if (st.chip_cfg.bypass_mode == bypass_on)
000004  4850              LDR      r0,|L32.328|
000006  7c80              LDRB     r0,[r0,#0x12]
000008  42a0              CMP      r0,r4
00000a  d101              BNE      |L32.16|
;;;1300           return 0;
00000c  2000              MOVS     r0,#0
                  |L32.14|
;;;1301   
;;;1302       if (bypass_on) {
;;;1303           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1304               return -1;
;;;1305           tmp &= ~BIT_AUX_IF_EN;
;;;1306           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1307               return -1;
;;;1308           Timer_Delayms(3);
;;;1309           tmp = BIT_BYPASS_EN;
;;;1310           if (st.chip_cfg.active_low_int)
;;;1311               tmp |= BIT_ACTL;
;;;1312           if (st.chip_cfg.latched_int)
;;;1313               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1314           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1315               return -1;
;;;1316       } else {
;;;1317           /* Enable I2C master mode if compass is being used. */
;;;1318           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1319               return -1;
;;;1320           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1321               tmp |= BIT_AUX_IF_EN;
;;;1322           else
;;;1323               tmp &= ~BIT_AUX_IF_EN;
;;;1324           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1325               return -1;
;;;1326           Timer_Delayms(3);
;;;1327           if (st.chip_cfg.active_low_int)
;;;1328               tmp = BIT_ACTL;
;;;1329           else
;;;1330               tmp = 0;
;;;1331           if (st.chip_cfg.latched_int)
;;;1332               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1333           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1334               return -1;
;;;1335       }
;;;1336       st.chip_cfg.bypass_mode = bypass_on;
;;;1337       return 0;
;;;1338   }
00000e  bd38              POP      {r3-r5,pc}
                  |L32.16|
000010  2c00              CMP      r4,#0                 ;1302
000012  d046              BEQ      |L32.162|
000014  4a4c              LDR      r2,|L32.328|
000016  6812              LDR      r2,[r2,#0]            ;1303  ; st
000018  7911              LDRB     r1,[r2,#4]            ;1303
00001a  4a4b              LDR      r2,|L32.328|
00001c  6852              LDR      r2,[r2,#4]            ;1303  ; st
00001e  7810              LDRB     r0,[r2,#0]            ;1303
000020  466b              MOV      r3,sp                 ;1303
000022  2201              MOVS     r2,#1                 ;1303
000024  f7fffffe          BL       i2c_read
000028  b110              CBZ      r0,|L32.48|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;1304
00002e  e7ee              B        |L32.14|
                  |L32.48|
000030  f89d0000          LDRB     r0,[sp,#0]            ;1305
000034  f0200020          BIC      r0,r0,#0x20           ;1305
000038  9000              STR      r0,[sp,#0]            ;1305
00003a  4a43              LDR      r2,|L32.328|
00003c  6812              LDR      r2,[r2,#0]            ;1306  ; st
00003e  7911              LDRB     r1,[r2,#4]            ;1306
000040  4a41              LDR      r2,|L32.328|
000042  6852              LDR      r2,[r2,#4]            ;1306  ; st
000044  7810              LDRB     r0,[r2,#0]            ;1306
000046  466b              MOV      r3,sp                 ;1306
000048  2201              MOVS     r2,#1                 ;1306
00004a  f7fffffe          BL       i2c_write
00004e  b110              CBZ      r0,|L32.86|
000050  f04f30ff          MOV      r0,#0xffffffff        ;1307
000054  e7db              B        |L32.14|
                  |L32.86|
000056  2003              MOVS     r0,#3                 ;1308
000058  f7fffffe          BL       Timer_Delayms
00005c  2002              MOVS     r0,#2                 ;1309
00005e  9000              STR      r0,[sp,#0]            ;1309
000060  4839              LDR      r0,|L32.328|
000062  f8900022          LDRB     r0,[r0,#0x22]         ;1310
000066  b120              CBZ      r0,|L32.114|
000068  f89d0000          LDRB     r0,[sp,#0]            ;1311
00006c  f0400080          ORR      r0,r0,#0x80           ;1311
000070  9000              STR      r0,[sp,#0]            ;1311
                  |L32.114|
000072  4835              LDR      r0,|L32.328|
000074  f8900023          LDRB     r0,[r0,#0x23]         ;1312
000078  b120              CBZ      r0,|L32.132|
00007a  f89d0000          LDRB     r0,[sp,#0]            ;1313
00007e  f0400030          ORR      r0,r0,#0x30           ;1313
000082  9000              STR      r0,[sp,#0]            ;1313
                  |L32.132|
000084  4a30              LDR      r2,|L32.328|
000086  6812              LDR      r2,[r2,#0]            ;1314  ; st
000088  7d11              LDRB     r1,[r2,#0x14]         ;1314
00008a  4a2f              LDR      r2,|L32.328|
00008c  6852              LDR      r2,[r2,#4]            ;1314  ; st
00008e  7810              LDRB     r0,[r2,#0]            ;1314
000090  466b              MOV      r3,sp                 ;1314
000092  2201              MOVS     r2,#1                 ;1314
000094  f7fffffe          BL       i2c_write
000098  2800              CMP      r0,#0                 ;1314
00009a  d051              BEQ      |L32.320|
00009c  f04f30ff          MOV      r0,#0xffffffff        ;1315
0000a0  e7b5              B        |L32.14|
                  |L32.162|
0000a2  4a29              LDR      r2,|L32.328|
0000a4  6812              LDR      r2,[r2,#0]            ;1318  ; st
0000a6  7911              LDRB     r1,[r2,#4]            ;1318
0000a8  4a27              LDR      r2,|L32.328|
0000aa  6852              LDR      r2,[r2,#4]            ;1318  ; st
0000ac  7810              LDRB     r0,[r2,#0]            ;1318
0000ae  466b              MOV      r3,sp                 ;1318
0000b0  2201              MOVS     r2,#1                 ;1318
0000b2  f7fffffe          BL       i2c_read
0000b6  b110              CBZ      r0,|L32.190|
0000b8  f04f30ff          MOV      r0,#0xffffffff        ;1319
0000bc  e7a7              B        |L32.14|
                  |L32.190|
0000be  4822              LDR      r0,|L32.328|
0000c0  7a80              LDRB     r0,[r0,#0xa]          ;1320
0000c2  f0100f01          TST      r0,#1                 ;1320
0000c6  d005              BEQ      |L32.212|
0000c8  f89d0000          LDRB     r0,[sp,#0]            ;1321
0000cc  f0400020          ORR      r0,r0,#0x20           ;1321
0000d0  9000              STR      r0,[sp,#0]            ;1321
0000d2  e004              B        |L32.222|
                  |L32.212|
0000d4  f89d0000          LDRB     r0,[sp,#0]            ;1323
0000d8  f0200020          BIC      r0,r0,#0x20           ;1323
0000dc  9000              STR      r0,[sp,#0]            ;1323
                  |L32.222|
0000de  4a1a              LDR      r2,|L32.328|
0000e0  6812              LDR      r2,[r2,#0]            ;1324  ; st
0000e2  7911              LDRB     r1,[r2,#4]            ;1324
0000e4  4a18              LDR      r2,|L32.328|
0000e6  6852              LDR      r2,[r2,#4]            ;1324  ; st
0000e8  7810              LDRB     r0,[r2,#0]            ;1324
0000ea  466b              MOV      r3,sp                 ;1324
0000ec  2201              MOVS     r2,#1                 ;1324
0000ee  f7fffffe          BL       i2c_write
0000f2  b110              CBZ      r0,|L32.250|
0000f4  f04f30ff          MOV      r0,#0xffffffff        ;1325
0000f8  e789              B        |L32.14|
                  |L32.250|
0000fa  2003              MOVS     r0,#3                 ;1326
0000fc  f7fffffe          BL       Timer_Delayms
000100  4811              LDR      r0,|L32.328|
000102  f8900022          LDRB     r0,[r0,#0x22]         ;1327
000106  b110              CBZ      r0,|L32.270|
000108  2080              MOVS     r0,#0x80              ;1328
00010a  9000              STR      r0,[sp,#0]            ;1328
00010c  e001              B        |L32.274|
                  |L32.270|
00010e  2000              MOVS     r0,#0                 ;1330
000110  9000              STR      r0,[sp,#0]            ;1330
                  |L32.274|
000112  480d              LDR      r0,|L32.328|
000114  f8900023          LDRB     r0,[r0,#0x23]         ;1331
000118  b120              CBZ      r0,|L32.292|
00011a  f89d0000          LDRB     r0,[sp,#0]            ;1332
00011e  f0400030          ORR      r0,r0,#0x30           ;1332
000122  9000              STR      r0,[sp,#0]            ;1332
                  |L32.292|
000124  4a08              LDR      r2,|L32.328|
000126  6812              LDR      r2,[r2,#0]            ;1333  ; st
000128  7d11              LDRB     r1,[r2,#0x14]         ;1333
00012a  4a07              LDR      r2,|L32.328|
00012c  6852              LDR      r2,[r2,#4]            ;1333  ; st
00012e  7810              LDRB     r0,[r2,#0]            ;1333
000130  466b              MOV      r3,sp                 ;1333
000132  2201              MOVS     r2,#1                 ;1333
000134  f7fffffe          BL       i2c_write
000138  b110              CBZ      r0,|L32.320|
00013a  f04f30ff          MOV      r0,#0xffffffff        ;1334
00013e  e766              B        |L32.14|
                  |L32.320|
000140  4801              LDR      r0,|L32.328|
000142  7484              STRB     r4,[r0,#0x12]         ;1336
000144  2000              MOVS     r0,#0                 ;1337
000146  e762              B        |L32.14|
;;;1339   
                          ENDP

                  |L32.328|
                          DCD      ||st||

                          AREA ||i.mpu_set_dmp_state||, CODE, READONLY, ALIGN=2

                  mpu_set_dmp_state PROC
;;;1770    */
;;;1771   int mpu_set_dmp_state(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;1772   {
000002  4604              MOV      r4,r0
;;;1773       unsigned char tmp;
;;;1774       if (st.chip_cfg.dmp_on == enable)
000004  4821              LDR      r0,|L33.140|
000006  f8900024          LDRB     r0,[r0,#0x24]
00000a  42a0              CMP      r0,r4
00000c  d101              BNE      |L33.18|
;;;1775           return 0;
00000e  2000              MOVS     r0,#0
                  |L33.16|
;;;1776   
;;;1777       if (enable) {
;;;1778           if (!st.chip_cfg.dmp_loaded)
;;;1779               return -1;
;;;1780           /* Disable data ready interrupt. */
;;;1781           set_int_enable(0);
;;;1782           /* Disable bypass mode. */
;;;1783           mpu_set_bypass(0);
;;;1784           /* Keep constant sample rate, FIFO rate controlled by DMP. */
;;;1785           mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
;;;1786           /* Remove FIFO elements. */
;;;1787           tmp = 0;
;;;1788           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;1789           st.chip_cfg.dmp_on = 1;
;;;1790           /* Enable DMP interrupt. */
;;;1791           set_int_enable(1);
;;;1792           mpu_reset_fifo();
;;;1793       } else {
;;;1794           /* Disable DMP interrupt. */
;;;1795           set_int_enable(0);
;;;1796           /* Restore FIFO settings. */
;;;1797           tmp = st.chip_cfg.fifo_enable;
;;;1798           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;1799           st.chip_cfg.dmp_on = 0;
;;;1800           mpu_reset_fifo();
;;;1801       }
;;;1802       return 0;
;;;1803   }
000010  bd38              POP      {r3-r5,pc}
                  |L33.18|
000012  b324              CBZ      r4,|L33.94|
000014  481d              LDR      r0,|L33.140|
000016  f8900025          LDRB     r0,[r0,#0x25]         ;1778
00001a  b910              CBNZ     r0,|L33.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1779
000020  e7f6              B        |L33.16|
                  |L33.34|
000022  2000              MOVS     r0,#0                 ;1781
000024  f7fffffe          BL       set_int_enable
000028  2000              MOVS     r0,#0                 ;1783
00002a  f7fffffe          BL       mpu_set_bypass
00002e  4917              LDR      r1,|L33.140|
000030  8cc8              LDRH     r0,[r1,#0x26]         ;1785
000032  f7fffffe          BL       mpu_set_sample_rate
000036  2000              MOVS     r0,#0                 ;1787
000038  9000              STR      r0,[sp,#0]            ;1787
00003a  4914              LDR      r1,|L33.140|
00003c  6849              LDR      r1,[r1,#4]            ;1788  ; st
00003e  7808              LDRB     r0,[r1,#0]            ;1788
000040  466b              MOV      r3,sp                 ;1788
000042  2201              MOVS     r2,#1                 ;1788
000044  2123              MOVS     r1,#0x23              ;1788
000046  f7fffffe          BL       i2c_write
00004a  2101              MOVS     r1,#1                 ;1789
00004c  480f              LDR      r0,|L33.140|
00004e  f8801024          STRB     r1,[r0,#0x24]         ;1789
000052  2001              MOVS     r0,#1                 ;1791
000054  f7fffffe          BL       set_int_enable
000058  f7fffffe          BL       mpu_reset_fifo
00005c  e013              B        |L33.134|
                  |L33.94|
00005e  2000              MOVS     r0,#0                 ;1795
000060  f7fffffe          BL       set_int_enable
000064  4809              LDR      r0,|L33.140|
000066  7c00              LDRB     r0,[r0,#0x10]         ;1797
000068  9000              STR      r0,[sp,#0]            ;1797
00006a  4908              LDR      r1,|L33.140|
00006c  6849              LDR      r1,[r1,#4]            ;1798  ; st
00006e  7808              LDRB     r0,[r1,#0]            ;1798
000070  466b              MOV      r3,sp                 ;1798
000072  2201              MOVS     r2,#1                 ;1798
000074  2123              MOVS     r1,#0x23              ;1798
000076  f7fffffe          BL       i2c_write
00007a  2100              MOVS     r1,#0                 ;1799
00007c  4803              LDR      r0,|L33.140|
00007e  f8801024          STRB     r1,[r0,#0x24]         ;1799
000082  f7fffffe          BL       mpu_reset_fifo
                  |L33.134|
000086  2000              MOVS     r0,#0                 ;1802
000088  e7c2              B        |L33.16|
;;;1804   
                          ENDP

00008a  0000              DCW      0x0000
                  |L33.140|
                          DCD      ||st||

                          AREA ||i.mpu_set_gyro_fsr||, CODE, READONLY, ALIGN=2

                  mpu_set_gyro_fsr PROC
;;;787     */
;;;788    int mpu_set_gyro_fsr(unsigned short fsr)
000000  b538              PUSH     {r3-r5,lr}
;;;789    {
000002  4604              MOV      r4,r0
;;;790        unsigned char data;
;;;791    
;;;792        if (!(st.chip_cfg.sensors))
000004  481f              LDR      r0,|L34.132|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L34.16|
;;;793            return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L34.14|
;;;794    
;;;795        switch (fsr) {
;;;796        case 250:
;;;797            data = INV_FSR_250DPS << 3;
;;;798            break;
;;;799        case 500:
;;;800            data = INV_FSR_500DPS << 3;
;;;801            break;
;;;802        case 1000:
;;;803            data = INV_FSR_1000DPS << 3;
;;;804            break;
;;;805        case 2000:
;;;806            data = INV_FSR_2000DPS << 3;
;;;807            break;
;;;808        default:
;;;809            return -1;
;;;810        }
;;;811    
;;;812        if (st.chip_cfg.gyro_fsr == (data >> 3))
;;;813            return 0;
;;;814        if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
;;;815            return -1;
;;;816        st.chip_cfg.gyro_fsr = data >> 3;
;;;817        return 0;
;;;818    }
00000e  bd38              POP      {r3-r5,pc}
                  |L34.16|
000010  2cfa              CMP      r4,#0xfa              ;795
000012  d009              BEQ      |L34.40|
000014  f5b47ffa          CMP      r4,#0x1f4             ;795
000018  d009              BEQ      |L34.46|
00001a  f5b47f7a          CMP      r4,#0x3e8             ;795
00001e  d009              BEQ      |L34.52|
000020  f5b46ffa          CMP      r4,#0x7d0             ;795
000024  d10c              BNE      |L34.64|
000026  e008              B        |L34.58|
                  |L34.40|
000028  2000              MOVS     r0,#0                 ;797
00002a  9000              STR      r0,[sp,#0]            ;797
00002c  e00b              B        |L34.70|
                  |L34.46|
00002e  2008              MOVS     r0,#8                 ;800
000030  9000              STR      r0,[sp,#0]            ;800
000032  e008              B        |L34.70|
                  |L34.52|
000034  2010              MOVS     r0,#0x10              ;803
000036  9000              STR      r0,[sp,#0]            ;803
000038  e005              B        |L34.70|
                  |L34.58|
00003a  2018              MOVS     r0,#0x18              ;806
00003c  9000              STR      r0,[sp,#0]            ;806
00003e  e002              B        |L34.70|
                  |L34.64|
000040  f04f30ff          MOV      r0,#0xffffffff        ;809
000044  e7e3              B        |L34.14|
                  |L34.70|
000046  bf00              NOP                            ;798
000048  480e              LDR      r0,|L34.132|
00004a  7a00              LDRB     r0,[r0,#8]            ;812  ; st
00004c  f89d1000          LDRB     r1,[sp,#0]            ;812
000050  ebb00fe1          CMP      r0,r1,ASR #3          ;812
000054  d101              BNE      |L34.90|
000056  2000              MOVS     r0,#0                 ;813
000058  e7d9              B        |L34.14|
                  |L34.90|
00005a  4a0a              LDR      r2,|L34.132|
00005c  6812              LDR      r2,[r2,#0]            ;814  ; st
00005e  7991              LDRB     r1,[r2,#6]            ;814
000060  4a08              LDR      r2,|L34.132|
000062  6852              LDR      r2,[r2,#4]            ;814  ; st
000064  7810              LDRB     r0,[r2,#0]            ;814
000066  466b              MOV      r3,sp                 ;814
000068  2201              MOVS     r2,#1                 ;814
00006a  f7fffffe          BL       i2c_write
00006e  b110              CBZ      r0,|L34.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;815
000074  e7cb              B        |L34.14|
                  |L34.118|
000076  f89d0000          LDRB     r0,[sp,#0]            ;816
00007a  10c0              ASRS     r0,r0,#3              ;816
00007c  4901              LDR      r1,|L34.132|
00007e  7208              STRB     r0,[r1,#8]            ;816
000080  2000              MOVS     r0,#0                 ;817
000082  e7c4              B        |L34.14|
;;;819    
                          ENDP

                  |L34.132|
                          DCD      ||st||

                          AREA ||i.mpu_set_int_latched||, CODE, READONLY, ALIGN=2

                  mpu_set_int_latched PROC
;;;1356    */
;;;1357   int mpu_set_int_latched(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;1358   {
000002  4604              MOV      r4,r0
;;;1359       unsigned char tmp;
;;;1360       if (st.chip_cfg.latched_int == enable)
000004  4818              LDR      r0,|L35.104|
000006  f8900023          LDRB     r0,[r0,#0x23]
00000a  42a0              CMP      r0,r4
00000c  d101              BNE      |L35.18|
;;;1361           return 0;
00000e  2000              MOVS     r0,#0
                  |L35.16|
;;;1362   
;;;1363       if (enable)
;;;1364           tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1365       else
;;;1366           tmp = 0;
;;;1367       if (st.chip_cfg.bypass_mode)
;;;1368           tmp |= BIT_BYPASS_EN;
;;;1369       if (st.chip_cfg.active_low_int)
;;;1370           tmp |= BIT_ACTL;
;;;1371       if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1372           return -1;
;;;1373       st.chip_cfg.latched_int = enable;
;;;1374       return 0;
;;;1375   }
000010  bd38              POP      {r3-r5,pc}
                  |L35.18|
000012  b114              CBZ      r4,|L35.26|
000014  2030              MOVS     r0,#0x30              ;1364
000016  9000              STR      r0,[sp,#0]            ;1364
000018  e001              B        |L35.30|
                  |L35.26|
00001a  2000              MOVS     r0,#0                 ;1366
00001c  9000              STR      r0,[sp,#0]            ;1366
                  |L35.30|
00001e  4812              LDR      r0,|L35.104|
000020  7c80              LDRB     r0,[r0,#0x12]         ;1367
000022  b120              CBZ      r0,|L35.46|
000024  f89d0000          LDRB     r0,[sp,#0]            ;1368
000028  f0400002          ORR      r0,r0,#2              ;1368
00002c  9000              STR      r0,[sp,#0]            ;1368
                  |L35.46|
00002e  480e              LDR      r0,|L35.104|
000030  f8900022          LDRB     r0,[r0,#0x22]         ;1369
000034  b120              CBZ      r0,|L35.64|
000036  f89d0000          LDRB     r0,[sp,#0]            ;1370
00003a  f0400080          ORR      r0,r0,#0x80           ;1370
00003e  9000              STR      r0,[sp,#0]            ;1370
                  |L35.64|
000040  4a09              LDR      r2,|L35.104|
000042  6812              LDR      r2,[r2,#0]            ;1371  ; st
000044  7d11              LDRB     r1,[r2,#0x14]         ;1371
000046  4a08              LDR      r2,|L35.104|
000048  6852              LDR      r2,[r2,#4]            ;1371  ; st
00004a  7810              LDRB     r0,[r2,#0]            ;1371
00004c  466b              MOV      r3,sp                 ;1371
00004e  2201              MOVS     r2,#1                 ;1371
000050  f7fffffe          BL       i2c_write
000054  b110              CBZ      r0,|L35.92|
000056  f04f30ff          MOV      r0,#0xffffffff        ;1372
00005a  e7d9              B        |L35.16|
                  |L35.92|
00005c  4802              LDR      r0,|L35.104|
00005e  f8804023          STRB     r4,[r0,#0x23]         ;1373
000062  2000              MOVS     r0,#0                 ;1374
000064  e7d4              B        |L35.16|
;;;1376   
                          ENDP

000066  0000              DCW      0x0000
                  |L35.104|
                          DCD      ||st||

                          AREA ||i.mpu_set_int_level||, CODE, READONLY, ALIGN=2

                  mpu_set_int_level PROC
;;;1344    */
;;;1345   int mpu_set_int_level(unsigned char active_low)
000000  4601              MOV      r1,r0
;;;1346   {
;;;1347       st.chip_cfg.active_low_int = active_low;
000002  4802              LDR      r0,|L36.12|
000004  f8801022          STRB     r1,[r0,#0x22]
;;;1348       return 0;
000008  2000              MOVS     r0,#0
;;;1349   }
00000a  4770              BX       lr
;;;1350   
                          ENDP

                  |L36.12|
                          DCD      ||st||

                          AREA ||i.mpu_set_lpf||, CODE, READONLY, ALIGN=2

                  mpu_set_lpf PROC
;;;919     */
;;;920    int mpu_set_lpf(unsigned short lpf)
000000  b538              PUSH     {r3-r5,lr}
;;;921    {
000002  4604              MOV      r4,r0
;;;922        unsigned char data;
;;;923    
;;;924        if (!(st.chip_cfg.sensors))
000004  481e              LDR      r0,|L37.128|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L37.16|
;;;925            return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L37.14|
;;;926    
;;;927        if (lpf >= 188)
;;;928            data = INV_FILTER_188HZ;
;;;929        else if (lpf >= 98)
;;;930            data = INV_FILTER_98HZ;
;;;931        else if (lpf >= 42)
;;;932            data = INV_FILTER_42HZ;
;;;933        else if (lpf >= 20)
;;;934            data = INV_FILTER_20HZ;
;;;935        else if (lpf >= 10)
;;;936            data = INV_FILTER_10HZ;
;;;937        else
;;;938            data = INV_FILTER_5HZ;
;;;939    
;;;940        if (st.chip_cfg.lpf == data)
;;;941            return 0;
;;;942        if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
;;;943            return -1;
;;;944        st.chip_cfg.lpf = data;
;;;945        return 0;
;;;946    }
00000e  bd38              POP      {r3-r5,pc}
                  |L37.16|
000010  2cbc              CMP      r4,#0xbc              ;927
000012  db02              BLT      |L37.26|
000014  2001              MOVS     r0,#1                 ;928
000016  9000              STR      r0,[sp,#0]            ;928
000018  e015              B        |L37.70|
                  |L37.26|
00001a  2c62              CMP      r4,#0x62              ;929
00001c  db02              BLT      |L37.36|
00001e  2002              MOVS     r0,#2                 ;930
000020  9000              STR      r0,[sp,#0]            ;930
000022  e010              B        |L37.70|
                  |L37.36|
000024  2c2a              CMP      r4,#0x2a              ;931
000026  db02              BLT      |L37.46|
000028  2003              MOVS     r0,#3                 ;932
00002a  9000              STR      r0,[sp,#0]            ;932
00002c  e00b              B        |L37.70|
                  |L37.46|
00002e  2c14              CMP      r4,#0x14              ;933
000030  db02              BLT      |L37.56|
000032  2004              MOVS     r0,#4                 ;934
000034  9000              STR      r0,[sp,#0]            ;934
000036  e006              B        |L37.70|
                  |L37.56|
000038  2c0a              CMP      r4,#0xa               ;935
00003a  db02              BLT      |L37.66|
00003c  2005              MOVS     r0,#5                 ;936
00003e  9000              STR      r0,[sp,#0]            ;936
000040  e001              B        |L37.70|
                  |L37.66|
000042  2006              MOVS     r0,#6                 ;938
000044  9000              STR      r0,[sp,#0]            ;938
                  |L37.70|
000046  480e              LDR      r0,|L37.128|
000048  7ac0              LDRB     r0,[r0,#0xb]          ;940
00004a  f89d1000          LDRB     r1,[sp,#0]            ;940
00004e  4288              CMP      r0,r1                 ;940
000050  d101              BNE      |L37.86|
000052  2000              MOVS     r0,#0                 ;941
000054  e7db              B        |L37.14|
                  |L37.86|
000056  4a0a              LDR      r2,|L37.128|
000058  6812              LDR      r2,[r2,#0]            ;942  ; st
00005a  7891              LDRB     r1,[r2,#2]            ;942
00005c  4a08              LDR      r2,|L37.128|
00005e  6852              LDR      r2,[r2,#4]            ;942  ; st
000060  7810              LDRB     r0,[r2,#0]            ;942
000062  466b              MOV      r3,sp                 ;942
000064  2201              MOVS     r2,#1                 ;942
000066  f7fffffe          BL       i2c_write
00006a  b110              CBZ      r0,|L37.114|
00006c  f04f30ff          MOV      r0,#0xffffffff        ;943
000070  e7cd              B        |L37.14|
                  |L37.114|
000072  f89d1000          LDRB     r1,[sp,#0]            ;944
000076  4802              LDR      r0,|L37.128|
000078  72c1              STRB     r1,[r0,#0xb]          ;944
00007a  2000              MOVS     r0,#0                 ;945
00007c  e7c7              B        |L37.14|
;;;947    
                          ENDP

00007e  0000              DCW      0x0000
                  |L37.128|
                          DCD      ||st||

                          AREA ||i.mpu_set_motion_int||, CODE, READONLY, ALIGN=2

                  mpu_set_motion_int PROC
;;;491    
;;;492    int mpu_set_motion_int(void)
000000  b508              PUSH     {r3,lr}
;;;493    {
;;;494    	unsigned char data[2];
;;;495    	/***************??????*****dewey:add*******************/
;;;496    	memset(data,0,2);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;497      /* ********Reset device************* */
;;;498      data[0] = 0x80;
000006  2080              MOVS     r0,#0x80
000008  f88d0000          STRB     r0,[sp,#0]
;;;499      if ( i2c_write( st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0]) ) )
00000c  4a44              LDR      r2,|L38.288|
00000e  6812              LDR      r2,[r2,#0]  ; st
000010  7c91              LDRB     r1,[r2,#0x12]
000012  4a43              LDR      r2,|L38.288|
000014  6852              LDR      r2,[r2,#4]  ; st
000016  7810              LDRB     r0,[r2,#0]
000018  466b              MOV      r3,sp
00001a  2201              MOVS     r2,#1
00001c  f7fffffe          BL       i2c_write
000020  b110              CBZ      r0,|L38.40|
;;;500          return -1;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L38.38|
;;;501      Timer_Delayms(100);
;;;502    
;;;503      /******************Wake up chip*************/
;;;504      data[0] = 0x00;
;;;505      if ( i2c_write( st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0]) ) )
;;;506         return -1;
;;;507    
;;;508    	data[0] = 0x30;
;;;509      if ( i2c_write( st.hw->addr, st.reg->int_pin_cfg, 1, &data[0]) ){
;;;510    		return -1;
;;;511    	}
;;;512    	data[0] = 0x40;
;;;513      if ( i2c_write( st.hw->addr, st.reg->int_enable, 1, &data[0]) ){
;;;514    		return -1;
;;;515    	}
;;;516    	data[0] = 0x01;
;;;517      if ( i2c_write( st.hw->addr, st.reg->motion_dur, 1, &data[0]) ){
;;;518    		return -1;
;;;519    	}
;;;520    	data[0] = 0x03;
;;;521      if ( i2c_write( st.hw->addr, st.reg->motion_thr, 1, &data[0]) ){
;;;522    		return -1;
;;;523    	}
;;;524    	data[0] = 0x00;
;;;525      if ( i2c_write( st.hw->addr, st.reg->motion_detect_ctrl, 1, &data[0]) ){
;;;526    		return -1;
;;;527    	}
;;;528    	
;;;529    	Timer_Delayms(6);
;;;530    
;;;531      if ( i2c_read( st.hw->addr, st.reg->motion_detect_status, 1, &(data[0]) ) )
;;;532    		return -1;	
;;;533    /*********************end********************************/
;;;534    	return 0;
;;;535    	
;;;536    }
000026  bd08              POP      {r3,pc}
                  |L38.40|
000028  2064              MOVS     r0,#0x64              ;501
00002a  f7fffffe          BL       Timer_Delayms
00002e  2000              MOVS     r0,#0                 ;504
000030  f88d0000          STRB     r0,[sp,#0]            ;504
000034  4a3a              LDR      r2,|L38.288|
000036  6812              LDR      r2,[r2,#0]            ;505  ; st
000038  7c91              LDRB     r1,[r2,#0x12]         ;505
00003a  4a39              LDR      r2,|L38.288|
00003c  6852              LDR      r2,[r2,#4]            ;505  ; st
00003e  7810              LDRB     r0,[r2,#0]            ;505
000040  466b              MOV      r3,sp                 ;505
000042  2201              MOVS     r2,#1                 ;505
000044  f7fffffe          BL       i2c_write
000048  b110              CBZ      r0,|L38.80|
00004a  f04f30ff          MOV      r0,#0xffffffff        ;506
00004e  e7ea              B        |L38.38|
                  |L38.80|
000050  2030              MOVS     r0,#0x30              ;508
000052  f88d0000          STRB     r0,[sp,#0]            ;508
000056  4a32              LDR      r2,|L38.288|
000058  6812              LDR      r2,[r2,#0]            ;509  ; st
00005a  7d11              LDRB     r1,[r2,#0x14]         ;509
00005c  4a30              LDR      r2,|L38.288|
00005e  6852              LDR      r2,[r2,#4]            ;509  ; st
000060  7810              LDRB     r0,[r2,#0]            ;509
000062  466b              MOV      r3,sp                 ;509
000064  2201              MOVS     r2,#1                 ;509
000066  f7fffffe          BL       i2c_write
00006a  b110              CBZ      r0,|L38.114|
00006c  f04f30ff          MOV      r0,#0xffffffff        ;510
000070  e7d9              B        |L38.38|
                  |L38.114|
000072  2040              MOVS     r0,#0x40              ;512
000074  f88d0000          STRB     r0,[sp,#0]            ;512
000078  4a29              LDR      r2,|L38.288|
00007a  6812              LDR      r2,[r2,#0]            ;513  ; st
00007c  7bd1              LDRB     r1,[r2,#0xf]          ;513
00007e  4a28              LDR      r2,|L38.288|
000080  6852              LDR      r2,[r2,#4]            ;513  ; st
000082  7810              LDRB     r0,[r2,#0]            ;513
000084  466b              MOV      r3,sp                 ;513
000086  2201              MOVS     r2,#1                 ;513
000088  f7fffffe          BL       i2c_write
00008c  b110              CBZ      r0,|L38.148|
00008e  f04f30ff          MOV      r0,#0xffffffff        ;514
000092  e7c8              B        |L38.38|
                  |L38.148|
000094  2001              MOVS     r0,#1                 ;516
000096  f88d0000          STRB     r0,[sp,#0]            ;516
00009a  4a21              LDR      r2,|L38.288|
00009c  6812              LDR      r2,[r2,#0]            ;517  ; st
00009e  7a51              LDRB     r1,[r2,#9]            ;517
0000a0  4a1f              LDR      r2,|L38.288|
0000a2  6852              LDR      r2,[r2,#4]            ;517  ; st
0000a4  7810              LDRB     r0,[r2,#0]            ;517
0000a6  466b              MOV      r3,sp                 ;517
0000a8  2201              MOVS     r2,#1                 ;517
0000aa  f7fffffe          BL       i2c_write
0000ae  b110              CBZ      r0,|L38.182|
0000b0  f04f30ff          MOV      r0,#0xffffffff        ;518
0000b4  e7b7              B        |L38.38|
                  |L38.182|
0000b6  2003              MOVS     r0,#3                 ;520
0000b8  f88d0000          STRB     r0,[sp,#0]            ;520
0000bc  4a18              LDR      r2,|L38.288|
0000be  6812              LDR      r2,[r2,#0]            ;521  ; st
0000c0  7a11              LDRB     r1,[r2,#8]            ;521
0000c2  4a17              LDR      r2,|L38.288|
0000c4  6852              LDR      r2,[r2,#4]            ;521  ; st
0000c6  7810              LDRB     r0,[r2,#0]            ;521
0000c8  466b              MOV      r3,sp                 ;521
0000ca  2201              MOVS     r2,#1                 ;521
0000cc  f7fffffe          BL       i2c_write
0000d0  b110              CBZ      r0,|L38.216|
0000d2  f04f30ff          MOV      r0,#0xffffffff        ;522
0000d6  e7a6              B        |L38.38|
                  |L38.216|
0000d8  2000              MOVS     r0,#0                 ;524
0000da  f88d0000          STRB     r0,[sp,#0]            ;524
0000de  4a10              LDR      r2,|L38.288|
0000e0  6812              LDR      r2,[r2,#0]            ;525  ; st
0000e2  7f11              LDRB     r1,[r2,#0x1c]         ;525
0000e4  4a0e              LDR      r2,|L38.288|
0000e6  6852              LDR      r2,[r2,#4]            ;525  ; st
0000e8  7810              LDRB     r0,[r2,#0]            ;525
0000ea  466b              MOV      r3,sp                 ;525
0000ec  2201              MOVS     r2,#1                 ;525
0000ee  f7fffffe          BL       i2c_write
0000f2  b110              CBZ      r0,|L38.250|
0000f4  f04f30ff          MOV      r0,#0xffffffff        ;526
0000f8  e795              B        |L38.38|
                  |L38.250|
0000fa  2006              MOVS     r0,#6                 ;529
0000fc  f7fffffe          BL       Timer_Delayms
000100  4a07              LDR      r2,|L38.288|
000102  6812              LDR      r2,[r2,#0]            ;531  ; st
000104  7ed1              LDRB     r1,[r2,#0x1b]         ;531
000106  4a06              LDR      r2,|L38.288|
000108  6852              LDR      r2,[r2,#4]            ;531  ; st
00010a  7810              LDRB     r0,[r2,#0]            ;531
00010c  466b              MOV      r3,sp                 ;531
00010e  2201              MOVS     r2,#1                 ;531
000110  f7fffffe          BL       i2c_read
000114  b110              CBZ      r0,|L38.284|
000116  f04f30ff          MOV      r0,#0xffffffff        ;532
00011a  e784              B        |L38.38|
                  |L38.284|
00011c  2000              MOVS     r0,#0                 ;534
00011e  e782              B        |L38.38|
;;;537    
                          ENDP

                  |L38.288|
                          DCD      ||st||

                          AREA ||i.mpu_set_sample_rate||, CODE, READONLY, ALIGN=2

                  mpu_set_sample_rate PROC
;;;964     */
;;;965    int mpu_set_sample_rate(unsigned short rate)
000000  b538              PUSH     {r3-r5,lr}
;;;966    {
000002  4604              MOV      r4,r0
;;;967        unsigned char data;
;;;968    
;;;969        if (!(st.chip_cfg.sensors))
000004  4824              LDR      r0,|L39.152|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L39.16|
;;;970            return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L39.14|
;;;971    
;;;972        if (st.chip_cfg.dmp_on)
;;;973            return -1;
;;;974        else {
;;;975            if (st.chip_cfg.lp_accel_mode) {
;;;976                if (rate && (rate <= 40)) {
;;;977                    /* Just stay in low-power accel mode. */
;;;978                    mpu_lp_accel_mode(rate);
;;;979                    return 0;
;;;980                }
;;;981                /* Requested rate exceeds the allowed frequencies in LP accel mode,
;;;982                 * switch back to full-power mode.
;;;983                 */
;;;984                mpu_lp_accel_mode(0);
;;;985            }
;;;986            if (rate < 4)
;;;987                rate = 4;
;;;988            else if (rate > 1000)
;;;989                rate = 1000;
;;;990    
;;;991            data = 1000 / rate - 1;
;;;992            if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
;;;993                return -1;
;;;994    
;;;995            st.chip_cfg.sample_rate = 1000 / (1 + data);
;;;996    
;;;997            /* Automatically set LPF to 1/2 sampling rate. */
;;;998            mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
;;;999            return 0;
;;;1000       }
;;;1001   }
00000e  bd38              POP      {r3-r5,pc}
                  |L39.16|
000010  4821              LDR      r0,|L39.152|
000012  f8900024          LDRB     r0,[r0,#0x24]         ;972
000016  b110              CBZ      r0,|L39.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;973
00001c  e7f7              B        |L39.14|
                  |L39.30|
00001e  481e              LDR      r0,|L39.152|
000020  7d00              LDRB     r0,[r0,#0x14]         ;975
000022  b150              CBZ      r0,|L39.58|
000024  b134              CBZ      r4,|L39.52|
000026  2c28              CMP      r4,#0x28              ;976
000028  dc04              BGT      |L39.52|
00002a  b2e0              UXTB     r0,r4                 ;978
00002c  f7fffffe          BL       mpu_lp_accel_mode
000030  2000              MOVS     r0,#0                 ;979
000032  e7ec              B        |L39.14|
                  |L39.52|
000034  2000              MOVS     r0,#0                 ;984
000036  f7fffffe          BL       mpu_lp_accel_mode
                  |L39.58|
00003a  2c04              CMP      r4,#4                 ;986
00003c  da01              BGE      |L39.66|
00003e  2404              MOVS     r4,#4                 ;987
000040  e004              B        |L39.76|
                  |L39.66|
000042  f5b47f7a          CMP      r4,#0x3e8             ;988
000046  dd01              BLE      |L39.76|
000048  f44f747a          MOV      r4,#0x3e8             ;989
                  |L39.76|
00004c  f44f707a          MOV      r0,#0x3e8             ;991
000050  fb90f0f4          SDIV     r0,r0,r4              ;991
000054  1e40              SUBS     r0,r0,#1              ;991
000056  b2c0              UXTB     r0,r0                 ;991
000058  9000              STR      r0,[sp,#0]            ;991
00005a  4a0f              LDR      r2,|L39.152|
00005c  6812              LDR      r2,[r2,#0]            ;992  ; st
00005e  7851              LDRB     r1,[r2,#1]            ;992
000060  4a0d              LDR      r2,|L39.152|
000062  6852              LDR      r2,[r2,#4]            ;992  ; st
000064  7810              LDRB     r0,[r2,#0]            ;992
000066  466b              MOV      r3,sp                 ;992
000068  2201              MOVS     r2,#1                 ;992
00006a  f7fffffe          BL       i2c_write
00006e  b110              CBZ      r0,|L39.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;993
000074  e7cb              B        |L39.14|
                  |L39.118|
000076  f89d0000          LDRB     r0,[sp,#0]            ;995
00007a  1c40              ADDS     r0,r0,#1              ;995
00007c  f44f717a          MOV      r1,#0x3e8             ;995
000080  fb91f0f0          SDIV     r0,r1,r0              ;995
000084  b281              UXTH     r1,r0                 ;995
000086  4804              LDR      r0,|L39.152|
000088  81c1              STRH     r1,[r0,#0xe]          ;995
00008a  4601              MOV      r1,r0                 ;998
00008c  89c9              LDRH     r1,[r1,#0xe]          ;998
00008e  1048              ASRS     r0,r1,#1              ;998
000090  f7fffffe          BL       mpu_set_lpf
000094  2000              MOVS     r0,#0                 ;999
000096  e7ba              B        |L39.14|
;;;1002   
                          ENDP

                  |L39.152|
                          DCD      ||st||

                          AREA ||i.mpu_set_sensors||, CODE, READONLY, ALIGN=2

                  mpu_set_sensors PROC
;;;1117    */
;;;1118   int mpu_set_sensors(unsigned char sensors)
000000  b538              PUSH     {r3-r5,lr}
;;;1119   {
000002  4604              MOV      r4,r0
;;;1120       unsigned char data;
;;;1121   
;;;1122       if (sensors & INV_XYZ_GYRO)
000004  f0140f70          TST      r4,#0x70
000008  d002              BEQ      |L40.16|
;;;1123           data = INV_CLK_PLL;
00000a  2001              MOVS     r0,#1
00000c  9000              STR      r0,[sp,#0]
00000e  e005              B        |L40.28|
                  |L40.16|
;;;1124       else if (sensors)
000010  b114              CBZ      r4,|L40.24|
;;;1125           data = 0;
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  e001              B        |L40.28|
                  |L40.24|
;;;1126       else
;;;1127           data = BIT_SLEEP;
000018  2040              MOVS     r0,#0x40
00001a  9000              STR      r0,[sp,#0]
                  |L40.28|
;;;1128       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
00001c  4a2b              LDR      r2,|L40.204|
00001e  6812              LDR      r2,[r2,#0]  ; st
000020  7c91              LDRB     r1,[r2,#0x12]
000022  4a2a              LDR      r2,|L40.204|
000024  6852              LDR      r2,[r2,#4]  ; st
000026  7810              LDRB     r0,[r2,#0]
000028  466b              MOV      r3,sp
00002a  2201              MOVS     r2,#1
00002c  f7fffffe          BL       i2c_write
000030  b120              CBZ      r0,|L40.60|
;;;1129           st.chip_cfg.sensors = 0;
000032  2100              MOVS     r1,#0
000034  4825              LDR      r0,|L40.204|
000036  7281              STRB     r1,[r0,#0xa]
;;;1130           return -1;
000038  1e48              SUBS     r0,r1,#1
                  |L40.58|
;;;1131       }
;;;1132       st.chip_cfg.clk_src = data & ~BIT_SLEEP;
;;;1133   
;;;1134       data = 0;
;;;1135       if (!(sensors & INV_X_GYRO))
;;;1136           data |= BIT_STBY_XG;
;;;1137       if (!(sensors & INV_Y_GYRO))
;;;1138           data |= BIT_STBY_YG;
;;;1139       if (!(sensors & INV_Z_GYRO))
;;;1140           data |= BIT_STBY_ZG;
;;;1141       if (!(sensors & INV_XYZ_ACCEL))
;;;1142           data |= BIT_STBY_XYZA;
;;;1143       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
;;;1144           st.chip_cfg.sensors = 0;
;;;1145           return -1;
;;;1146       }
;;;1147   
;;;1148       if (sensors && (sensors != INV_XYZ_ACCEL))
;;;1149           /* Latched interrupts only used in LP accel mode. */
;;;1150           mpu_set_int_latched(0);
;;;1151   
;;;1152       st.chip_cfg.sensors = sensors;
;;;1153       st.chip_cfg.lp_accel_mode = 0;
;;;1154       Timer_Delayms(50);
;;;1155       return 0;
;;;1156   }
00003a  bd38              POP      {r3-r5,pc}
                  |L40.60|
00003c  f89d0000          LDRB     r0,[sp,#0]            ;1132
000040  f0200140          BIC      r1,r0,#0x40           ;1132
000044  4821              LDR      r0,|L40.204|
000046  7301              STRB     r1,[r0,#0xc]          ;1132
000048  2000              MOVS     r0,#0                 ;1134
00004a  9000              STR      r0,[sp,#0]            ;1134
00004c  f0140f40          TST      r4,#0x40              ;1135
000050  d104              BNE      |L40.92|
000052  f89d0000          LDRB     r0,[sp,#0]            ;1136
000056  f0400004          ORR      r0,r0,#4              ;1136
00005a  9000              STR      r0,[sp,#0]            ;1136
                  |L40.92|
00005c  f0140f20          TST      r4,#0x20              ;1137
000060  d104              BNE      |L40.108|
000062  f89d0000          LDRB     r0,[sp,#0]            ;1138
000066  f0400002          ORR      r0,r0,#2              ;1138
00006a  9000              STR      r0,[sp,#0]            ;1138
                  |L40.108|
00006c  f0140f10          TST      r4,#0x10              ;1139
000070  d104              BNE      |L40.124|
000072  f89d0000          LDRB     r0,[sp,#0]            ;1140
000076  f0400001          ORR      r0,r0,#1              ;1140
00007a  9000              STR      r0,[sp,#0]            ;1140
                  |L40.124|
00007c  f0140f08          TST      r4,#8                 ;1141
000080  d104              BNE      |L40.140|
000082  f89d0000          LDRB     r0,[sp,#0]            ;1142
000086  f0400038          ORR      r0,r0,#0x38           ;1142
00008a  9000              STR      r0,[sp,#0]            ;1142
                  |L40.140|
00008c  4a0f              LDR      r2,|L40.204|
00008e  6812              LDR      r2,[r2,#0]            ;1143  ; st
000090  7cd1              LDRB     r1,[r2,#0x13]         ;1143
000092  4a0e              LDR      r2,|L40.204|
000094  6852              LDR      r2,[r2,#4]            ;1143  ; st
000096  7810              LDRB     r0,[r2,#0]            ;1143
000098  466b              MOV      r3,sp                 ;1143
00009a  2201              MOVS     r2,#1                 ;1143
00009c  f7fffffe          BL       i2c_write
0000a0  b120              CBZ      r0,|L40.172|
0000a2  2100              MOVS     r1,#0                 ;1144
0000a4  4809              LDR      r0,|L40.204|
0000a6  7281              STRB     r1,[r0,#0xa]          ;1144
0000a8  1e48              SUBS     r0,r1,#1              ;1145
0000aa  e7c6              B        |L40.58|
                  |L40.172|
0000ac  b124              CBZ      r4,|L40.184|
0000ae  2c08              CMP      r4,#8                 ;1148
0000b0  d002              BEQ      |L40.184|
0000b2  2000              MOVS     r0,#0                 ;1150
0000b4  f7fffffe          BL       mpu_set_int_latched
                  |L40.184|
0000b8  4804              LDR      r0,|L40.204|
0000ba  7284              STRB     r4,[r0,#0xa]          ;1152
0000bc  2100              MOVS     r1,#0                 ;1153
0000be  7501              STRB     r1,[r0,#0x14]         ;1153
0000c0  2032              MOVS     r0,#0x32              ;1154
0000c2  f7fffffe          BL       Timer_Delayms
0000c6  2000              MOVS     r0,#0                 ;1155
0000c8  e7b7              B        |L40.58|
;;;1157   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L40.204|
                          DCD      ||st||

                          AREA ||i.mpu_write_mem||, CODE, READONLY, ALIGN=2

                  mpu_write_mem PROC
;;;1664    */
;;;1665   int mpu_write_mem(unsigned short mem_addr, unsigned short length,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1666           unsigned char *data)
;;;1667   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1668       unsigned char tmp[2];
;;;1669   
;;;1670       if (!data)
000008  b916              CBNZ     r6,|L41.16|
;;;1671           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L41.14|
;;;1672       if (!st.chip_cfg.sensors)
;;;1673           return -1;
;;;1674   
;;;1675       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;1676       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;1677   
;;;1678       /* Check bank boundaries. */
;;;1679       if (tmp[1] + length > st.hw->bank_size)
;;;1680           return -1;
;;;1681   
;;;1682       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;1683           return -1;
;;;1684       if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
;;;1685           return -1;
;;;1686       return 0;
;;;1687   }
00000e  bdf8              POP      {r3-r7,pc}
                  |L41.16|
000010  481a              LDR      r0,|L41.124|
000012  7a80              LDRB     r0,[r0,#0xa]          ;1672
000014  b910              CBNZ     r0,|L41.28|
000016  f04f30ff          MOV      r0,#0xffffffff        ;1673
00001a  e7f8              B        |L41.14|
                  |L41.28|
00001c  1220              ASRS     r0,r4,#8              ;1675
00001e  f88d0000          STRB     r0,[sp,#0]            ;1675
000022  b2e0              UXTB     r0,r4                 ;1676
000024  f88d0001          STRB     r0,[sp,#1]            ;1676
000028  f89d0001          LDRB     r0,[sp,#1]            ;1679
00002c  4428              ADD      r0,r0,r5              ;1679
00002e  4913              LDR      r1,|L41.124|
000030  6849              LDR      r1,[r1,#4]            ;1679  ; st
000032  8949              LDRH     r1,[r1,#0xa]          ;1679
000034  4288              CMP      r0,r1                 ;1679
000036  dd02              BLE      |L41.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;1680
00003c  e7e7              B        |L41.14|
                  |L41.62|
00003e  4a0f              LDR      r2,|L41.124|
000040  6812              LDR      r2,[r2,#0]            ;1682  ; st
000042  7e11              LDRB     r1,[r2,#0x18]         ;1682
000044  4a0d              LDR      r2,|L41.124|
000046  6852              LDR      r2,[r2,#4]            ;1682  ; st
000048  7810              LDRB     r0,[r2,#0]            ;1682
00004a  466b              MOV      r3,sp                 ;1682
00004c  2202              MOVS     r2,#2                 ;1682
00004e  f7fffffe          BL       i2c_write
000052  b110              CBZ      r0,|L41.90|
000054  f04f30ff          MOV      r0,#0xffffffff        ;1683
000058  e7d9              B        |L41.14|
                  |L41.90|
00005a  b2ea              UXTB     r2,r5                 ;1684
00005c  4b07              LDR      r3,|L41.124|
00005e  681b              LDR      r3,[r3,#0]            ;1684  ; st
000060  7d59              LDRB     r1,[r3,#0x15]         ;1684
000062  4b06              LDR      r3,|L41.124|
000064  685b              LDR      r3,[r3,#4]            ;1684  ; st
000066  7818              LDRB     r0,[r3,#0]            ;1684
000068  4633              MOV      r3,r6                 ;1684
00006a  f7fffffe          BL       i2c_write
00006e  b110              CBZ      r0,|L41.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;1685
000074  e7cb              B        |L41.14|
                  |L41.118|
000076  2000              MOVS     r0,#0                 ;1686
000078  e7c9              B        |L41.14|
;;;1688   
                          ENDP

00007a  0000              DCW      0x0000
                  |L41.124|
                          DCD      ||st||

                          AREA ||i.set_int_enable||, CODE, READONLY, ALIGN=2

                  set_int_enable PROC
;;;325     */
;;;326    static int set_int_enable(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328        unsigned char tmp;
;;;329    
;;;330        if (st.chip_cfg.dmp_on) {
000004  4821              LDR      r0,|L42.140|
000006  f8900024          LDRB     r0,[r0,#0x24]
00000a  b1c0              CBZ      r0,|L42.62|
;;;331            if (enable)
00000c  b114              CBZ      r4,|L42.20|
;;;332                tmp = BIT_DMP_INT_EN;
00000e  2002              MOVS     r0,#2
000010  9000              STR      r0,[sp,#0]
000012  e001              B        |L42.24|
                  |L42.20|
;;;333            else
;;;334                tmp = 0x00;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
                  |L42.24|
;;;335            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
000018  4a1c              LDR      r2,|L42.140|
00001a  6812              LDR      r2,[r2,#0]  ; st
00001c  7bd1              LDRB     r1,[r2,#0xf]
00001e  4a1b              LDR      r2,|L42.140|
000020  6852              LDR      r2,[r2,#4]  ; st
000022  7810              LDRB     r0,[r2,#0]
000024  466b              MOV      r3,sp
000026  2201              MOVS     r2,#1
000028  f7fffffe          BL       i2c_write
00002c  b110              CBZ      r0,|L42.52|
;;;336                return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L42.50|
;;;337            st.chip_cfg.int_enable = tmp;
;;;338        } else {
;;;339            if (!st.chip_cfg.sensors)
;;;340                return -1;
;;;341            if (enable && st.chip_cfg.int_enable)
;;;342                return 0;
;;;343            if (enable)
;;;344                tmp = BIT_DATA_RDY_EN;
;;;345            else
;;;346                tmp = 0x00;
;;;347            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
;;;348                return -1;
;;;349            st.chip_cfg.int_enable = tmp;
;;;350        }
;;;351        return 0;
;;;352    }
000032  bd38              POP      {r3-r5,pc}
                  |L42.52|
000034  f89d1000          LDRB     r1,[sp,#0]            ;337
000038  4814              LDR      r0,|L42.140|
00003a  7441              STRB     r1,[r0,#0x11]         ;337
00003c  e023              B        |L42.134|
                  |L42.62|
00003e  4813              LDR      r0,|L42.140|
000040  7a80              LDRB     r0,[r0,#0xa]          ;339
000042  b910              CBNZ     r0,|L42.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;340
000048  e7f3              B        |L42.50|
                  |L42.74|
00004a  b124              CBZ      r4,|L42.86|
00004c  480f              LDR      r0,|L42.140|
00004e  7c40              LDRB     r0,[r0,#0x11]         ;341
000050  b108              CBZ      r0,|L42.86|
000052  2000              MOVS     r0,#0                 ;342
000054  e7ed              B        |L42.50|
                  |L42.86|
000056  b114              CBZ      r4,|L42.94|
000058  2001              MOVS     r0,#1                 ;344
00005a  9000              STR      r0,[sp,#0]            ;344
00005c  e001              B        |L42.98|
                  |L42.94|
00005e  2000              MOVS     r0,#0                 ;346
000060  9000              STR      r0,[sp,#0]            ;346
                  |L42.98|
000062  4a0a              LDR      r2,|L42.140|
000064  6812              LDR      r2,[r2,#0]            ;347  ; st
000066  7bd1              LDRB     r1,[r2,#0xf]          ;347
000068  4a08              LDR      r2,|L42.140|
00006a  6852              LDR      r2,[r2,#4]            ;347  ; st
00006c  7810              LDRB     r0,[r2,#0]            ;347
00006e  466b              MOV      r3,sp                 ;347
000070  2201              MOVS     r2,#1                 ;347
000072  f7fffffe          BL       i2c_write
000076  b110              CBZ      r0,|L42.126|
000078  f04f30ff          MOV      r0,#0xffffffff        ;348
00007c  e7d9              B        |L42.50|
                  |L42.126|
00007e  f89d1000          LDRB     r1,[sp,#0]            ;349
000082  4802              LDR      r0,|L42.140|
000084  7441              STRB     r1,[r0,#0x11]         ;349
                  |L42.134|
000086  2000              MOVS     r0,#0                 ;351
000088  e7d3              B        |L42.50|
;;;353    
                          ENDP

00008a  0000              DCW      0x0000
                  |L42.140|
                          DCD      ||st||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ||hw||
000000  6800              DCB      0x68,0x00
000002  0400              DCW      0x0400
000004  7600              DCB      0x76,0x00
000006  0154              DCW      0x0154
000008  fdf70100          DCW      0xfdf7,0x0100
                  ||reg||
00000c  75191a0c          DCB      0x75,0x19,0x1a,0x0c
000010  6a231b1c          DCB      0x6a,0x23,0x1b,0x1c
000014  1f207274          DCB      0x1f,0x20,0x72,0x74
000018  433b4138          DCB      0x43,0x3b,0x41,0x38
00001c  393a6b6c          DCB      0x39,0x3a,0x6b,0x6c
000020  376f0624          DCB      0x37,0x6f,0x06,0x24
000024  6d6e7069          DCB      0x6d,0x6e,0x70,0x69
000028  61000000          DCB      0x61,0x00,0x00,0x00
                  test
                          DCD      0x00000083
                          DCD      0x00000800
000034  00010018          DCB      0x00,0x01,0x00,0x18
000038  0032              DCW      0x0032
00003a  0500              DCB      0x05,0x00
00003c  41200000          DCFS     0x41200000 ; 10
000040  42d20000          DCFS     0x42d20000 ; 105
000044  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645
000048  3e99999a          DCFS     0x3e99999a ; 0.30000001192092896
00004c  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
000050  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645

                          AREA ||.data||, DATA, ALIGN=2

                  dmpstatus13
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ||st||
                          DCD      ||reg||
                          DCD      ||hw||
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  0000              DCB      0x00,0x00
000012  0000              DCW      0x0000
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
000024  00000000          DCB      0x00,0x00,0x00,0x00
000028  0000              DCB      0x00,0x00
00002a  0000              DCW      0x0000
                          DCD      test
