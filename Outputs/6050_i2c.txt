; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\6050_i2c.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\6050_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP\GPS -I..\BSP\Sim900A -I..\BSP -I..\BSP\IWDG -I..\BSP\BlueTooth -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\BSP\Adxl345 -I..\BSP\TL718 -I..\BSP\PAM8403 -I..\BSP\W25X16 -I..\BSP\USB -I..\App\Debug -I..\App\SelfCheck -I..\App\GPSTask -I..\App\OBD -I..\App\Mems -I..\App\Voltage -I..\App\LKClient -I..\App\Paramlist -I..\App\ATC30 -I..\App -I..\BSP\mpu6050 -I..\App\mid-proc -I..\App\mpu6050Task -I..\BSP\dmp -I..\BSP\Bluetooth -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\6050_i2c.crf ..\BSP\6050_I2C.c]
                          THUMB

                          AREA ||i.I2C_Ack||, CODE, READONLY, ALIGN=2

                  I2C_Ack PROC
;;;38     
;;;39     static void I2C_Ack( void )
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41         SCL_L;
000002  2080              MOVS     r0,#0x80
000004  4909              LDR      r1,|L1.44|
000006  6148              STR      r0,[r1,#0x14]
;;;42         I2C_delay();
000008  f7fffffe          BL       I2C_delay
;;;43         SDA_L;
00000c  2040              MOVS     r0,#0x40
00000e  4907              LDR      r1,|L1.44|
000010  6148              STR      r0,[r1,#0x14]
;;;44         I2C_delay();
000012  f7fffffe          BL       I2C_delay
;;;45         SCL_H;
000016  2080              MOVS     r0,#0x80
000018  4904              LDR      r1,|L1.44|
00001a  6108              STR      r0,[r1,#0x10]
;;;46         I2C_delay();
00001c  f7fffffe          BL       I2C_delay
;;;47         SCL_L;
000020  2080              MOVS     r0,#0x80
000022  4902              LDR      r1,|L1.44|
000024  6148              STR      r0,[r1,#0x14]
;;;48         I2C_delay();
000026  f7fffffe          BL       I2C_delay
;;;49     }
00002a  bd10              POP      {r4,pc}
;;;50     
                          ENDP

                  |L1.44|
                          DCD      0x40011000

                          AREA ||i.I2C_NoAck||, CODE, READONLY, ALIGN=2

                  I2C_NoAck PROC
;;;50     
;;;51     static void I2C_NoAck( void )
000000  b510              PUSH     {r4,lr}
;;;52     {
;;;53         SCL_L;
000002  2080              MOVS     r0,#0x80
000004  4909              LDR      r1,|L2.44|
000006  6148              STR      r0,[r1,#0x14]
;;;54         I2C_delay();
000008  f7fffffe          BL       I2C_delay
;;;55         SDA_H;
00000c  2040              MOVS     r0,#0x40
00000e  4907              LDR      r1,|L2.44|
000010  6108              STR      r0,[r1,#0x10]
;;;56         I2C_delay();
000012  f7fffffe          BL       I2C_delay
;;;57         SCL_H;
000016  2080              MOVS     r0,#0x80
000018  4904              LDR      r1,|L2.44|
00001a  6108              STR      r0,[r1,#0x10]
;;;58         I2C_delay();
00001c  f7fffffe          BL       I2C_delay
;;;59         SCL_L;
000020  2080              MOVS     r0,#0x80
000022  4902              LDR      r1,|L2.44|
000024  6148              STR      r0,[r1,#0x14]
;;;60         I2C_delay();
000026  f7fffffe          BL       I2C_delay
;;;61     }
00002a  bd10              POP      {r4,pc}
;;;62     
                          ENDP

                  |L2.44|
                          DCD      0x40011000

                          AREA ||i.I2C_ReceiveByte||, CODE, READONLY, ALIGN=2

                  I2C_ReceiveByte PROC
;;;96     
;;;97     static uint8_t I2C_ReceiveByte( void )
000000  b570              PUSH     {r4-r6,lr}
;;;98     {
;;;99         uint8_t i = 8;
000002  2508              MOVS     r5,#8
;;;100        uint8_t byte = 0;
000004  2400              MOVS     r4,#0
;;;101    
;;;102        SDA_H;
000006  2040              MOVS     r0,#0x40
000008  490f              LDR      r1,|L3.72|
00000a  6108              STR      r0,[r1,#0x10]
;;;103        while ( i-- ) {
00000c  e012              B        |L3.52|
                  |L3.14|
;;;104            byte <<= 1;
00000e  0660              LSLS     r0,r4,#25
000010  0e04              LSRS     r4,r0,#24
;;;105            SCL_L;
000012  2080              MOVS     r0,#0x80
000014  490c              LDR      r1,|L3.72|
000016  6148              STR      r0,[r1,#0x14]
;;;106            I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;107            SCL_H;
00001c  2080              MOVS     r0,#0x80
00001e  490a              LDR      r1,|L3.72|
000020  6108              STR      r0,[r1,#0x10]
;;;108            I2C_delay();
000022  f7fffffe          BL       I2C_delay
;;;109            if ( SDA_read ) {
000026  4808              LDR      r0,|L3.72|
000028  6880              LDR      r0,[r0,#8]
00002a  f0100f40          TST      r0,#0x40
00002e  d001              BEQ      |L3.52|
;;;110                byte |= 0x01;
000030  f0440401          ORR      r4,r4,#1
                  |L3.52|
000034  0028              MOVS     r0,r5                 ;103
000036  f1a50101          SUB      r1,r5,#1              ;103
00003a  b2cd              UXTB     r5,r1                 ;103
00003c  d1e7              BNE      |L3.14|
;;;111            }
;;;112        }
;;;113        SCL_L;
00003e  2080              MOVS     r0,#0x80
000040  4901              LDR      r1,|L3.72|
000042  6148              STR      r0,[r1,#0x14]
;;;114        return byte;
000044  4620              MOV      r0,r4
;;;115    }
000046  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP

                  |L3.72|
                          DCD      0x40011000

                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=2

                  I2C_SendByte PROC
;;;78     
;;;79     static void I2C_SendByte( uint8_t byte )
000000  b570              PUSH     {r4-r6,lr}
;;;80     {
000002  4604              MOV      r4,r0
;;;81         uint8_t i = 8;
000004  2508              MOVS     r5,#8
;;;82         while ( i-- ) {
000006  e017              B        |L4.56|
                  |L4.8|
;;;83             SCL_L;
000008  2080              MOVS     r0,#0x80
00000a  4910              LDR      r1,|L4.76|
00000c  6148              STR      r0,[r1,#0x14]
;;;84             I2C_delay();
00000e  f7fffffe          BL       I2C_delay
;;;85             if ( byte & 0x80 )
000012  f0140f80          TST      r4,#0x80
000016  d003              BEQ      |L4.32|
;;;86                 SDA_H;
000018  2040              MOVS     r0,#0x40
00001a  490c              LDR      r1,|L4.76|
00001c  6108              STR      r0,[r1,#0x10]
00001e  e002              B        |L4.38|
                  |L4.32|
;;;87             else
;;;88                 SDA_L;
000020  2040              MOVS     r0,#0x40
000022  490a              LDR      r1,|L4.76|
000024  6148              STR      r0,[r1,#0x14]
                  |L4.38|
;;;89             byte <<= 1;
000026  0660              LSLS     r0,r4,#25
000028  0e04              LSRS     r4,r0,#24
;;;90             I2C_delay();
00002a  f7fffffe          BL       I2C_delay
;;;91             SCL_H;
00002e  2080              MOVS     r0,#0x80
000030  4906              LDR      r1,|L4.76|
000032  6108              STR      r0,[r1,#0x10]
;;;92             I2C_delay();
000034  f7fffffe          BL       I2C_delay
                  |L4.56|
000038  0028              MOVS     r0,r5                 ;82
00003a  f1a50101          SUB      r1,r5,#1              ;82
00003e  b2cd              UXTB     r5,r1                 ;82
000040  d1e2              BNE      |L4.8|
;;;93         }
;;;94         SCL_L;
000042  2080              MOVS     r0,#0x80
000044  4901              LDR      r1,|L4.76|
000046  6148              STR      r0,[r1,#0x14]
;;;95     }
000048  bd70              POP      {r4-r6,pc}
;;;96     
                          ENDP

00004a  0000              DCW      0x0000
                  |L4.76|
                          DCD      0x40011000

                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=2

                  I2C_Start PROC
;;;10     
;;;11     static bool I2C_Start( void )
000000  b510              PUSH     {r4,lr}
;;;12     {
;;;13         SDA_H;
000002  2040              MOVS     r0,#0x40
000004  4911              LDR      r1,|L5.76|
000006  6108              STR      r0,[r1,#0x10]
;;;14         SCL_H;
000008  2080              MOVS     r0,#0x80
00000a  6108              STR      r0,[r1,#0x10]
;;;15         I2C_delay();
00000c  f7fffffe          BL       I2C_delay
;;;16         if ( !SDA_read )
000010  480e              LDR      r0,|L5.76|
000012  6880              LDR      r0,[r0,#8]
000014  b908              CBNZ     r0,|L5.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L5.28|
                  |L5.26|
00001a  2000              MOVS     r0,#0
                  |L5.28|
00001c  f0100f40          TST      r0,#0x40
000020  d001              BEQ      |L5.38|
;;;17             return false;
000022  2000              MOVS     r0,#0
                  |L5.36|
;;;18         SDA_L;
;;;19         I2C_delay();
;;;20         if (SDA_read)
;;;21             return false;
;;;22         SDA_L;
;;;23         I2C_delay();
;;;24         return true;
;;;25     }
000024  bd10              POP      {r4,pc}
                  |L5.38|
000026  2040              MOVS     r0,#0x40              ;18
000028  4908              LDR      r1,|L5.76|
00002a  6148              STR      r0,[r1,#0x14]         ;18
00002c  f7fffffe          BL       I2C_delay
000030  4806              LDR      r0,|L5.76|
000032  6880              LDR      r0,[r0,#8]            ;20
000034  f0100f40          TST      r0,#0x40              ;20
000038  d001              BEQ      |L5.62|
00003a  2000              MOVS     r0,#0                 ;21
00003c  e7f2              B        |L5.36|
                  |L5.62|
00003e  2040              MOVS     r0,#0x40              ;22
000040  4902              LDR      r1,|L5.76|
000042  6148              STR      r0,[r1,#0x14]         ;22
000044  f7fffffe          BL       I2C_delay
000048  2001              MOVS     r0,#1                 ;24
00004a  e7eb              B        |L5.36|
;;;26     
                          ENDP

                  |L5.76|
                          DCD      0x40011000

                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=2

                  I2C_Stop PROC
;;;26     
;;;27     static void I2C_Stop( void )
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29         SCL_L;
000002  2080              MOVS     r0,#0x80
000004  4909              LDR      r1,|L6.44|
000006  6148              STR      r0,[r1,#0x14]
;;;30         I2C_delay();
000008  f7fffffe          BL       I2C_delay
;;;31         SDA_L;
00000c  2040              MOVS     r0,#0x40
00000e  4907              LDR      r1,|L6.44|
000010  6148              STR      r0,[r1,#0x14]
;;;32         I2C_delay();
000012  f7fffffe          BL       I2C_delay
;;;33         SCL_H;
000016  2080              MOVS     r0,#0x80
000018  4904              LDR      r1,|L6.44|
00001a  6108              STR      r0,[r1,#0x10]
;;;34         I2C_delay();
00001c  f7fffffe          BL       I2C_delay
;;;35         SDA_H;
000020  2040              MOVS     r0,#0x40
000022  4902              LDR      r1,|L6.44|
000024  6108              STR      r0,[r1,#0x10]
;;;36         I2C_delay();
000026  f7fffffe          BL       I2C_delay
;;;37     }
00002a  bd10              POP      {r4,pc}
;;;38     
                          ENDP

                  |L6.44|
                          DCD      0x40011000

                          AREA ||i.I2C_WaitAck||, CODE, READONLY, ALIGN=2

                  I2C_WaitAck PROC
;;;62     
;;;63     static bool I2C_WaitAck(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65         SCL_L;
000002  2080              MOVS     r0,#0x80
000004  490e              LDR      r1,|L7.64|
000006  6148              STR      r0,[r1,#0x14]
;;;66         I2C_delay();
000008  f7fffffe          BL       I2C_delay
;;;67         SDA_H;
00000c  2040              MOVS     r0,#0x40
00000e  490c              LDR      r1,|L7.64|
000010  6108              STR      r0,[r1,#0x10]
;;;68         I2C_delay();
000012  f7fffffe          BL       I2C_delay
;;;69         SCL_H;
000016  2080              MOVS     r0,#0x80
000018  4909              LDR      r1,|L7.64|
00001a  6108              STR      r0,[r1,#0x10]
;;;70         I2C_delay();
00001c  f7fffffe          BL       I2C_delay
;;;71         if (SDA_read) {
000020  4807              LDR      r0,|L7.64|
000022  6880              LDR      r0,[r0,#8]
000024  f0100f40          TST      r0,#0x40
000028  d004              BEQ      |L7.52|
;;;72             SCL_L;
00002a  2080              MOVS     r0,#0x80
00002c  4904              LDR      r1,|L7.64|
00002e  6148              STR      r0,[r1,#0x14]
;;;73             return false;
000030  2000              MOVS     r0,#0
                  |L7.50|
;;;74         }
;;;75         SCL_L;
;;;76         return true;
;;;77     }
000032  bd10              POP      {r4,pc}
                  |L7.52|
000034  2080              MOVS     r0,#0x80              ;75
000036  4902              LDR      r1,|L7.64|
000038  6148              STR      r0,[r1,#0x14]         ;75
00003a  2001              MOVS     r0,#1                 ;76
00003c  e7f9              B        |L7.50|
;;;78     
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x40011000

                          AREA ||i.I2C_delay||, CODE, READONLY, ALIGN=1

                  I2C_delay PROC
;;;3      
;;;4      static void I2C_delay( void )
000000  b508              PUSH     {r3,lr}
;;;5      {
;;;6          volatile int i = 7;
000002  2007              MOVS     r0,#7
000004  9000              STR      r0,[sp,#0]
;;;7          while (i)
000006  e002              B        |L8.14|
                  |L8.8|
;;;8              i--;
000008  9800              LDR      r0,[sp,#0]
00000a  1e40              SUBS     r0,r0,#1
00000c  9000              STR      r0,[sp,#0]
                  |L8.14|
00000e  9800              LDR      r0,[sp,#0]            ;7
000010  2800              CMP      r0,#0                 ;7
000012  d1f9              BNE      |L8.8|
;;;9      }
000014  bd08              POP      {r3,pc}
;;;10     
                          ENDP


                          AREA ||i.i2cInit||, CODE, READONLY, ALIGN=2

                  i2cInit PROC
;;;116    
;;;117    void i2cInit( void )
000000  b508              PUSH     {r3,lr}
;;;118    {
;;;119        GPIO_InitTypeDef gpio;
;;;120    		RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC , ENABLE );    
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121        gpio.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
00000a  20c0              MOVS     r0,#0xc0
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;122        gpio.GPIO_Speed = GPIO_Speed_2MHz;
000010  2002              MOVS     r0,#2
000012  f88d0002          STRB     r0,[sp,#2]
;;;123        gpio.GPIO_Mode = GPIO_Mode_Out_OD;
000016  2014              MOVS     r0,#0x14
000018  f88d0003          STRB     r0,[sp,#3]
;;;124        GPIO_Init(GPIOC, &gpio);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L9.40|
000020  f7fffffe          BL       GPIO_Init
;;;125    	
;;;126    	
;;;127    }
000024  bd08              POP      {r3,pc}
;;;128    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0x40011000

                          AREA ||i.i2cReadBuffer||, CODE, READONLY, ALIGN=1

                  i2cReadBuffer PROC
;;;180    
;;;181    bool i2cReadBuffer( uint8_t addr, uint8_t reg, uint8_t len, uint8_t *buf )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;182    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;183        if ( !I2C_Start() )
00000c  f7fffffe          BL       I2C_Start
000010  b910              CBNZ     r0,|L10.24|
;;;184            return false;
000012  2000              MOVS     r0,#0
                  |L10.20|
;;;185        I2C_SendByte( addr << 1 | I2C_Direction_Transmitter );
;;;186        if ( !I2C_WaitAck() ) {
;;;187            I2C_Stop();
;;;188            return false;
;;;189        }
;;;190        I2C_SendByte( reg );
;;;191        I2C_WaitAck();
;;;192        I2C_Start();
;;;193        I2C_SendByte( addr << 1 | I2C_Direction_Receiver );
;;;194        I2C_WaitAck();
;;;195        while (len) {
;;;196            *buf = I2C_ReceiveByte();
;;;197            if ( len == 1 )
;;;198                I2C_NoAck();
;;;199            else
;;;200                I2C_Ack();
;;;201            buf++;
;;;202            len--;
;;;203        }
;;;204        I2C_Stop();
;;;205        return true;
;;;206    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L10.24|
000018  2100              MOVS     r1,#0                 ;185
00001a  ea410145          ORR      r1,r1,r5,LSL #1       ;185
00001e  b2c8              UXTB     r0,r1                 ;185
000020  f7fffffe          BL       I2C_SendByte
000024  f7fffffe          BL       I2C_WaitAck
000028  b918              CBNZ     r0,|L10.50|
00002a  f7fffffe          BL       I2C_Stop
00002e  2000              MOVS     r0,#0                 ;188
000030  e7f0              B        |L10.20|
                  |L10.50|
000032  4638              MOV      r0,r7                 ;190
000034  f7fffffe          BL       I2C_SendByte
000038  f7fffffe          BL       I2C_WaitAck
00003c  f7fffffe          BL       I2C_Start
000040  2101              MOVS     r1,#1                 ;193
000042  eb010145          ADD      r1,r1,r5,LSL #1       ;193
000046  b2c8              UXTB     r0,r1                 ;193
000048  f7fffffe          BL       I2C_SendByte
00004c  f7fffffe          BL       I2C_WaitAck
000050  e00c              B        |L10.108|
                  |L10.82|
000052  f7fffffe          BL       I2C_ReceiveByte
000056  7030              STRB     r0,[r6,#0]            ;196
000058  2c01              CMP      r4,#1                 ;197
00005a  d102              BNE      |L10.98|
00005c  f7fffffe          BL       I2C_NoAck
000060  e001              B        |L10.102|
                  |L10.98|
000062  f7fffffe          BL       I2C_Ack
                  |L10.102|
000066  1c76              ADDS     r6,r6,#1              ;201
000068  1e60              SUBS     r0,r4,#1              ;202
00006a  b2c4              UXTB     r4,r0                 ;202
                  |L10.108|
00006c  2c00              CMP      r4,#0                 ;195
00006e  d1f0              BNE      |L10.82|
000070  f7fffffe          BL       I2C_Stop
000074  2001              MOVS     r0,#1                 ;205
000076  e7cd              B        |L10.20|
                          ENDP


                          AREA ||i.i2cWriteBuffer||, CODE, READONLY, ALIGN=1

                  i2cWriteBuffer PROC
;;;130    
;;;131    bool i2cWriteBuffer( uint8_t addr, uint8_t reg, uint8_t len, uint8_t * data )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;132    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;133        int i;
;;;134        if ( !I2C_Start() )
00000c  f7fffffe          BL       I2C_Start
000010  b910              CBNZ     r0,|L11.24|
;;;135            return false;
000012  2000              MOVS     r0,#0
                  |L11.20|
;;;136        I2C_SendByte( addr << 1 | I2C_Direction_Transmitter );
;;;137        if ( !I2C_WaitAck() ) {
;;;138            I2C_Stop();
;;;139            return false;
;;;140        }
;;;141        I2C_SendByte( reg );
;;;142        I2C_WaitAck();
;;;143        for ( i = 0; i < len; i ++ ) {
;;;144            I2C_SendByte( data[i] );
;;;145            if ( !I2C_WaitAck() ) {
;;;146                I2C_Stop();
;;;147                return false;
;;;148            }
;;;149        }
;;;150        I2C_Stop();
;;;151        return true;
;;;152    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L11.24|
000018  2100              MOVS     r1,#0                 ;136
00001a  ea410145          ORR      r1,r1,r5,LSL #1       ;136
00001e  b2c8              UXTB     r0,r1                 ;136
000020  f7fffffe          BL       I2C_SendByte
000024  f7fffffe          BL       I2C_WaitAck
000028  b918              CBNZ     r0,|L11.50|
00002a  f7fffffe          BL       I2C_Stop
00002e  2000              MOVS     r0,#0                 ;139
000030  e7f0              B        |L11.20|
                  |L11.50|
000032  4630              MOV      r0,r6                 ;141
000034  f7fffffe          BL       I2C_SendByte
000038  f7fffffe          BL       I2C_WaitAck
00003c  2400              MOVS     r4,#0                 ;143
00003e  e00b              B        |L11.88|
                  |L11.64|
000040  f8180004          LDRB     r0,[r8,r4]            ;144
000044  f7fffffe          BL       I2C_SendByte
000048  f7fffffe          BL       I2C_WaitAck
00004c  b918              CBNZ     r0,|L11.86|
00004e  f7fffffe          BL       I2C_Stop
000052  2000              MOVS     r0,#0                 ;147
000054  e7de              B        |L11.20|
                  |L11.86|
000056  1c64              ADDS     r4,r4,#1              ;143
                  |L11.88|
000058  42bc              CMP      r4,r7                 ;143
00005a  dbf1              BLT      |L11.64|
00005c  f7fffffe          BL       I2C_Stop
000060  2001              MOVS     r0,#1                 ;151
000062  e7d7              B        |L11.20|
;;;153    
                          ENDP


                          AREA ||i.i2c_read||, CODE, READONLY, ALIGN=1

                  i2c_read PROC
;;;167    
;;;168    int8_t i2c_read( uint8_t addr, uint8_t reg, uint8_t len, uint8_t *buf )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;169    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;170    	if( i2cReadBuffer(addr, reg, len, buf ))
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       i2cReadBuffer
000018  b110              CBZ      r0,|L12.32|
;;;171    	{
;;;172    		return TRUE;
00001a  2000              MOVS     r0,#0
                  |L12.28|
;;;173    	}
;;;174    	else
;;;175    	{
;;;176    		return FALSE;
;;;177    	}
;;;178    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L12.32|
000020  f04f30ff          MOV      r0,#0xffffffff        ;176
000024  e7fa              B        |L12.28|
;;;179    
                          ENDP


                          AREA ||i.i2c_write||, CODE, READONLY, ALIGN=1

                  i2c_write PROC
;;;153    
;;;154    int8_t i2c_write(uint8_t addr, uint8_t reg, uint8_t len, uint8_t * data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;155    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;156    	if( i2cWriteBuffer(addr, reg, len, data) )
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       i2cWriteBuffer
000018  b110              CBZ      r0,|L13.32|
;;;157    	{
;;;158    		return TRUE;
00001a  2000              MOVS     r0,#0
                  |L13.28|
;;;159    	}
;;;160    	else
;;;161    	{
;;;162    		return FALSE;
;;;163    	}
;;;164    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.32|
000020  f04f30ff          MOV      r0,#0xffffffff        ;162
000024  e7fa              B        |L13.28|
;;;165    
                          ENDP

