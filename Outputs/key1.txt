; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\key1.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\key1.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP -I..\BSP\IWDG -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\App\Debug -I..\App\SelfCheck -I..\App\Voltage -I..\App\ATC30 -I..\App -I..\BSP\uart -I..\App\Task -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\key1.crf ..\BSP\key1.c]
                          THUMB

                          AREA ||i.Get_Key||, CODE, READONLY, ALIGN=2

                  Get_Key PROC
;;;10     //SYSTIMER KEY7_Tim;
;;;11     static uchar Get_Key(void)
000000  b510              PUSH     {r4,lr}
;;;12     {
;;;13          if (KEY0_STATUS==RESET) return KEY0_DOWN;
000002  f44f5180          MOV      r1,#0x1000
000006  4820              LDR      r0,|L1.136|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  b908              CBNZ     r0,|L1.18|
00000e  2001              MOVS     r0,#1
                  |L1.16|
;;;14          if (KEY1_STATUS==RESET) return KEY1_DOWN;
;;;15          if (KEY2_STATUS==RESET) return KEY2_DOWN;
;;;16          if (KEY3_STATUS==RESET) return KEY3_DOWN;
;;;17     	   if (KEY4_STATUS==RESET) return KEY4_DOWN;
;;;18     	   if (KEY5_STATUS==RESET) return KEY5_DOWN;
;;;19     	   if (KEY6_STATUS==RESET) return KEY6_DOWN;
;;;20     	   if (KEY7_STATUS==RESET) return KEY7_DOWN;
;;;21         return NO_KEY;
;;;22     }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  f44f5180          MOV      r1,#0x1000            ;14
000016  481c              LDR      r0,|L1.136|
000018  f7fffffe          BL       GPIO_ReadInputDataBit
00001c  b908              CBNZ     r0,|L1.34|
00001e  2002              MOVS     r0,#2                 ;14
000020  e7f6              B        |L1.16|
                  |L1.34|
000022  f44f5100          MOV      r1,#0x2000            ;15
000026  4818              LDR      r0,|L1.136|
000028  f7fffffe          BL       GPIO_ReadInputDataBit
00002c  b908              CBNZ     r0,|L1.50|
00002e  2003              MOVS     r0,#3                 ;15
000030  e7ee              B        |L1.16|
                  |L1.50|
000032  f44f4180          MOV      r1,#0x4000            ;16
000036  4814              LDR      r0,|L1.136|
000038  f7fffffe          BL       GPIO_ReadInputDataBit
00003c  b908              CBNZ     r0,|L1.66|
00003e  2004              MOVS     r0,#4                 ;16
000040  e7e6              B        |L1.16|
                  |L1.66|
000042  f44f4100          MOV      r1,#0x8000            ;17
000046  4810              LDR      r0,|L1.136|
000048  f7fffffe          BL       GPIO_ReadInputDataBit
00004c  b908              CBNZ     r0,|L1.82|
00004e  2005              MOVS     r0,#5                 ;17
000050  e7de              B        |L1.16|
                  |L1.82|
000052  f44f7180          MOV      r1,#0x100             ;18
000056  480c              LDR      r0,|L1.136|
000058  f7fffffe          BL       GPIO_ReadInputDataBit
00005c  b908              CBNZ     r0,|L1.98|
00005e  2006              MOVS     r0,#6                 ;18
000060  e7d6              B        |L1.16|
                  |L1.98|
000062  f44f7180          MOV      r1,#0x100             ;19
000066  4808              LDR      r0,|L1.136|
000068  f7fffffe          BL       GPIO_ReadInputDataBit
00006c  b908              CBNZ     r0,|L1.114|
00006e  2007              MOVS     r0,#7                 ;19
000070  e7ce              B        |L1.16|
                  |L1.114|
000072  f44f7180          MOV      r1,#0x100             ;20
000076  4804              LDR      r0,|L1.136|
000078  f7fffffe          BL       GPIO_ReadInputDataBit
00007c  b908              CBNZ     r0,|L1.130|
00007e  2008              MOVS     r0,#8                 ;20
000080  e7c6              B        |L1.16|
                  |L1.130|
000082  2000              MOVS     r0,#0                 ;21
000084  e7c4              B        |L1.16|
;;;23     
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40010c00

                          AREA ||i.Key1_Scan||, CODE, READONLY, ALIGN=2

                  Key1_Scan PROC
;;;23     
;;;24     uchar Key1_Scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {
;;;26         static uchar Key_State   = 0;        //按键状态
;;;27         static uchar Key_Prev    = 0;        //上一次按键
;;;28         static uchar Key_Delay   = 0;        //按键连发时间
;;;29         static uchar Key_Series  = FALSE;    //标志连发开始
;;;30     
;;;31         uchar Key_Press  = NO_KEY;           //按键值
000002  2400              MOVS     r4,#0
;;;32         uchar Key_Return = NO_KEY;           //按键返回值
000004  2500              MOVS     r5,#0
;;;33     
;;;34         Key_Press = Get_Key();
000006  f7fffffe          BL       Get_Key
00000a  4604              MOV      r4,r0
;;;35     
;;;36         switch (Key_State)
00000c  482b              LDR      r0,|L2.188|
00000e  7800              LDRB     r0,[r0,#0]  ; Key_State
000010  b120              CBZ      r0,|L2.28|
000012  2801              CMP      r0,#1
000014  d009              BEQ      |L2.42|
000016  2802              CMP      r0,#2
000018  d14c              BNE      |L2.180|
00001a  e016              B        |L2.74|
                  |L2.28|
;;;37         {
;;;38     
;;;39         case 0://按键初始态00
;;;40             if (Key_Press !=NO_KEY)//有按键按下
00001c  b124              CBZ      r4,|L2.40|
;;;41             {
;;;42                 Key_State = 1;//转到按键确认
00001e  2001              MOVS     r0,#1
000020  4926              LDR      r1,|L2.188|
000022  7008              STRB     r0,[r1,#0]
;;;43                 Key_Prev  = Key_Press;//保存按键状态
000024  4826              LDR      r0,|L2.192|
000026  7004              STRB     r4,[r0,#0]
                  |L2.40|
;;;44             }
;;;45             break;
000028  e045              B        |L2.182|
                  |L2.42|
;;;46     
;;;47         case 1://按键确认态01
;;;48             if ( Key_Press ==Key_Prev )//确认和上次按键相同
00002a  4825              LDR      r0,|L2.192|
00002c  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00002e  4284              CMP      r4,r0
000030  d107              BNE      |L2.66|
;;;49             {
;;;50                 Key_State = 2;//判断按键长按
000032  2002              MOVS     r0,#2
000034  4921              LDR      r1,|L2.188|
000036  7008              STRB     r0,[r1,#0]
;;;51     
;;;52                 //返回按键按下键值,按键按下就响应,如果想弹起来再响应
;;;53                 //可以在弹起来后再返回按键值
;;;54      
;;;55                 Key_Return = KEY_DOWN | Key_Prev;
000038  4821              LDR      r0,|L2.192|
00003a  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00003c  f04005a0          ORR      r5,r0,#0xa0
000040  e002              B        |L2.72|
                  |L2.66|
;;;56             }
;;;57             else//按键抬起,是抖动,不响应按键
;;;58             {
;;;59                 Key_State = 0;
000042  2000              MOVS     r0,#0
000044  491d              LDR      r1,|L2.188|
000046  7008              STRB     r0,[r1,#0]
                  |L2.72|
;;;60             }
;;;61             break;
000048  e035              B        |L2.182|
                  |L2.74|
;;;62     
;;;63         case 2://按键释放态10
;;;64             if (Key_Press == NO_KEY )//按键释放了
00004a  b95c              CBNZ     r4,|L2.100|
;;;65             {
;;;66                 Key_State = 0;
00004c  2000              MOVS     r0,#0
00004e  491b              LDR      r1,|L2.188|
000050  7008              STRB     r0,[r1,#0]
;;;67                 Key_Delay = 0;
000052  491c              LDR      r1,|L2.196|
000054  7008              STRB     r0,[r1,#0]
;;;68                 Key_Series  = FALSE;
000056  491c              LDR      r1,|L2.200|
000058  7008              STRB     r0,[r1,#0]
;;;69                 Key_Return  = KEY_UP | Key_Prev;      //返回按键抬起值
00005a  4819              LDR      r0,|L2.192|
00005c  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00005e  f04005d0          ORR      r5,r0,#0xd0
;;;70                 break;
000062  e028              B        |L2.182|
                  |L2.100|
;;;71             }
;;;72             if ( Key_Press ==Key_Prev )
000064  4816              LDR      r0,|L2.192|
000066  7800              LDRB     r0,[r0,#0]  ; Key_Prev
000068  4284              CMP      r4,r0
00006a  d122              BNE      |L2.178|
;;;73             {
;;;74                 Key_Delay++;
00006c  4815              LDR      r0,|L2.196|
00006e  7800              LDRB     r0,[r0,#0]  ; Key_Delay
000070  1c40              ADDS     r0,r0,#1
000072  4914              LDR      r1,|L2.196|
000074  7008              STRB     r0,[r1,#0]
;;;75                 if ((Key_Series==TRUE) && (Key_Delay>KEY_SERIES_DELAY))
000076  4814              LDR      r0,|L2.200|
000078  7800              LDRB     r0,[r0,#0]  ; Key_Series
00007a  2801              CMP      r0,#1
00007c  d10a              BNE      |L2.148|
00007e  4608              MOV      r0,r1
000080  7800              LDRB     r0,[r0,#0]  ; Key_Delay
000082  2832              CMP      r0,#0x32
000084  dd06              BLE      |L2.148|
;;;76                 {
;;;77                     Key_Delay  = 0;
000086  2000              MOVS     r0,#0
000088  7008              STRB     r0,[r1,#0]
;;;78                     Key_Return = KEY_LIAN | Key_Press;  //返回连发的值
00008a  f04405c0          ORR      r5,r4,#0xc0
;;;79                     Key_Prev   = Key_Press;      //记住上次的按键.
00008e  480c              LDR      r0,|L2.192|
000090  7004              STRB     r4,[r0,#0]
;;;80                     break;
000092  e010              B        |L2.182|
                  |L2.148|
;;;81                 }
;;;82                 if (Key_Delay>KEY_SERIES_FLAG)
000094  480b              LDR      r0,|L2.196|
000096  7800              LDRB     r0,[r0,#0]  ; Key_Delay
000098  2864              CMP      r0,#0x64
00009a  dd0a              BLE      |L2.178|
;;;83                 {
;;;84                     Key_Series = TRUE;
00009c  2001              MOVS     r0,#1
00009e  490a              LDR      r1,|L2.200|
0000a0  7008              STRB     r0,[r1,#0]
;;;85                     Key_Delay  = 0;
0000a2  2000              MOVS     r0,#0
0000a4  4907              LDR      r1,|L2.196|
0000a6  7008              STRB     r0,[r1,#0]
;;;86                     Key_Return = KEY_LONG | Key_Prev;   //返回长按后的值
0000a8  4805              LDR      r0,|L2.192|
0000aa  7800              LDRB     r0,[r0,#0]  ; Key_Prev
0000ac  f04005b0          ORR      r5,r0,#0xb0
;;;87                     break;
0000b0  e001              B        |L2.182|
                  |L2.178|
;;;88                 }
;;;89             }
;;;90     
;;;91         default :
0000b2  bf00              NOP      
                  |L2.180|
;;;92             break;
0000b4  bf00              NOP      
                  |L2.182|
0000b6  bf00              NOP                            ;45
;;;93         }
;;;94     
;;;95         return Key_Return;
0000b8  4628              MOV      r0,r5
;;;96     }
0000ba  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L2.188|
                          DCD      Key_State
                  |L2.192|
                          DCD      Key_Prev
                  |L2.196|
                          DCD      Key_Delay
                  |L2.200|
                          DCD      Key_Series

                          AREA ||.data||, DATA, ALIGN=0

                  Key_State
000000  00                DCB      0x00
                  Key_Prev
000001  00                DCB      0x00
                  Key_Delay
000002  00                DCB      0x00
                  Key_Series
000003  00                DCB      0x00
