; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\key.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\key.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP -I..\BSP\IWDG -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\App\Debug -I..\App\SelfCheck -I..\App\Voltage -I..\App\ATC30 -I..\App -I..\BSP\uart -I..\App\Task -I..\App\Task -IH:\xiangwei\xiangwei\mart\Project\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\key.crf ..\BSP\Key\key.c]
                          THUMB

                          AREA ||i.Get_Key||, CODE, READONLY, ALIGN=2

                  Get_Key PROC
;;;13     }
;;;14     static uchar Get_Key(void)
000000  b510              PUSH     {r4,lr}
;;;15     {
;;;16          if (KEY0_STATUS==RESET) return KEY_DOWN1;
000002  2102              MOVS     r1,#2
000004  4803              LDR      r0,|L1.20|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  b908              CBNZ     r0,|L1.16|
00000c  2001              MOVS     r0,#1
                  |L1.14|
;;;17         return NO_KEY;
;;;18     }
00000e  bd10              POP      {r4,pc}
                  |L1.16|
000010  2000              MOVS     r0,#0                 ;17
000012  e7fc              B        |L1.14|
;;;19     
                          ENDP

                  |L1.20|
                          DCD      0x40011000

                          AREA ||i.Key_Init||, CODE, READONLY, ALIGN=2

                  Key_Init PROC
;;;4      
;;;5      void Key_Init(void)
000000  b508              PUSH     {r3,lr}
;;;6      {
;;;7      	GPIO_InitTypeDef GPIO_InitStructure; //按键1
;;;8      	RCC_APB2PeriphClockCmd(KEY0_RCC, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;9      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;10     	GPIO_InitStructure.GPIO_Pin = KEY0_PIN;
000010  2002              MOVS     r0,#2
000012  f8ad0000          STRH     r0,[sp,#0]
;;;11     	GPIO_Init(KEY0_PORT, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4801              LDR      r0,|L2.32|
00001a  f7fffffe          BL       GPIO_Init
;;;12      
;;;13     }
00001e  bd08              POP      {r3,pc}
;;;14     static uchar Get_Key(void)
                          ENDP

                  |L2.32|
                          DCD      0x40011000

                          AREA ||i.Key_Scan||, CODE, READONLY, ALIGN=2

                  Key_Scan PROC
;;;19     
;;;20     uchar Key_Scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;21     {
;;;22         static uchar Key_State   = 0;        //按键状态
;;;23         static uchar Key_Prev    = 0;        //上一次按键
;;;24         static uchar Key_Delay   = 0;        //按键连发时间
;;;25         uchar Key_Press  = NO_KEY;           //按键值
000002  2400              MOVS     r4,#0
;;;26         uchar Key_Return = NO_KEY;           //按键返回值
000004  2500              MOVS     r5,#0
;;;27     
;;;28         Key_Press = Get_Key();
000006  f7fffffe          BL       Get_Key
00000a  4604              MOV      r4,r0
;;;29     
;;;30         switch (Key_State)
00000c  4823              LDR      r0,|L3.156|
00000e  7800              LDRB     r0,[r0,#0]  ; Key_State
000010  b120              CBZ      r0,|L3.28|
000012  2801              CMP      r0,#1
000014  d009              BEQ      |L3.42|
000016  2802              CMP      r0,#2
000018  d13b              BNE      |L3.146|
00001a  e016              B        |L3.74|
                  |L3.28|
;;;31         {
;;;32     
;;;33         case 0://按键初始态00
;;;34             if (Key_Press !=NO_KEY)//有按键按下
00001c  b124              CBZ      r4,|L3.40|
;;;35             {
;;;36                 Key_State = 1;//转到按键确认
00001e  2001              MOVS     r0,#1
000020  491e              LDR      r1,|L3.156|
000022  7008              STRB     r0,[r1,#0]
;;;37                 Key_Prev  = Key_Press;//保存按键状态
000024  481e              LDR      r0,|L3.160|
000026  7004              STRB     r4,[r0,#0]
                  |L3.40|
;;;38             }
;;;39             break;
000028  e034              B        |L3.148|
                  |L3.42|
;;;40     
;;;41         case 1://按键确认态01
;;;42             if ( Key_Press ==Key_Prev )//确认和上次按键相同
00002a  481d              LDR      r0,|L3.160|
00002c  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00002e  4284              CMP      r4,r0
000030  d107              BNE      |L3.66|
;;;43             {
;;;44                 Key_State = 2;//判断按键长按
000032  2002              MOVS     r0,#2
000034  4919              LDR      r1,|L3.156|
000036  7008              STRB     r0,[r1,#0]
;;;45     
;;;46                 //返回按键按下键值,按键按下就响应,如果想弹起来再响应
;;;47                 //可以在弹起来后再返回按键值
;;;48                
;;;49                 Key_Return = KEY_DOWN | Key_Prev;
000038  4819              LDR      r0,|L3.160|
00003a  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00003c  f04005a0          ORR      r5,r0,#0xa0
000040  e002              B        |L3.72|
                  |L3.66|
;;;50             }
;;;51             else//按键抬起,是抖动,不响应按键
;;;52             {
;;;53                 Key_State = 0;
000042  2000              MOVS     r0,#0
000044  4915              LDR      r1,|L3.156|
000046  7008              STRB     r0,[r1,#0]
                  |L3.72|
;;;54             }
;;;55             break;
000048  e024              B        |L3.148|
                  |L3.74|
;;;56     
;;;57         case 2://按键释放态10
;;;58     //        if (Key_Press == NO_KEY )//按键释放了
;;;59     //        {
;;;60     //            Key_State = 0;
;;;61     //            Key_Delay = 0;
;;;62     //            Key_Series  = FALSE;
;;;63     //            Key_Return  = KEY_UP | Key_Prev;      //返回按键抬起值
;;;64     //            break;
;;;65     //        }
;;;66     		      Key_Delay++;
00004a  4816              LDR      r0,|L3.164|
00004c  7800              LDRB     r0,[r0,#0]  ; Key_Delay
00004e  1c40              ADDS     r0,r0,#1
000050  4914              LDR      r1,|L3.164|
000052  7008              STRB     r0,[r1,#0]
;;;67     		     if( (Key_Press == NO_KEY) && (Key_Delay<KEY_SERIES_DELAY))
000054  b96c              CBNZ     r4,|L3.114|
000056  4608              MOV      r0,r1
000058  7800              LDRB     r0,[r0,#0]  ; Key_Delay
00005a  2832              CMP      r0,#0x32
00005c  da09              BGE      |L3.114|
;;;68                 {
;;;69                 Key_State = 0;
00005e  2000              MOVS     r0,#0
000060  490e              LDR      r1,|L3.156|
000062  7008              STRB     r0,[r1,#0]
;;;70                 Key_Delay = 0;
000064  490f              LDR      r1,|L3.164|
000066  7008              STRB     r0,[r1,#0]
;;;71                 Key_Return  = KEY_UP | Key_Prev;      //返回按键抬起值
000068  480d              LDR      r0,|L3.160|
00006a  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00006c  f04005d0          ORR      r5,r0,#0xd0
;;;72                 break;
000070  e010              B        |L3.148|
                  |L3.114|
;;;73                 }
;;;74             if( (Key_Press == NO_KEY) && (Key_Delay>KEY_SERIES_DELAY))
000072  b96c              CBNZ     r4,|L3.144|
000074  480b              LDR      r0,|L3.164|
000076  7800              LDRB     r0,[r0,#0]  ; Key_Delay
000078  2832              CMP      r0,#0x32
00007a  dd09              BLE      |L3.144|
;;;75                 {
;;;76                 Key_State = 0;
00007c  2000              MOVS     r0,#0
00007e  4907              LDR      r1,|L3.156|
000080  7008              STRB     r0,[r1,#0]
;;;77                 Key_Delay = 0;
000082  4908              LDR      r1,|L3.164|
000084  7008              STRB     r0,[r1,#0]
;;;78                 Key_Return  = KEY_LONG | Key_Prev;      //返回按键抬起值
000086  4806              LDR      r0,|L3.160|
000088  7800              LDRB     r0,[r0,#0]  ; Key_Prev
00008a  f04005b0          ORR      r5,r0,#0xb0
;;;79                 break;
00008e  e001              B        |L3.148|
                  |L3.144|
;;;80                 }
;;;81         default :
000090  bf00              NOP      
                  |L3.146|
;;;82             break;
000092  bf00              NOP      
                  |L3.148|
000094  bf00              NOP                            ;39
;;;83         }
;;;84     
;;;85         return Key_Return;
000096  4628              MOV      r0,r5
;;;86     }
000098  bd70              POP      {r4-r6,pc}
;;;87     
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      Key_State
                  |L3.160|
                          DCD      Key_Prev
                  |L3.164|
                          DCD      Key_Delay

                          AREA ||.data||, DATA, ALIGN=0

                  Key_State
000000  00                DCB      0x00
                  Key_Prev
000001  00                DCB      0x00
                  Key_Delay
000002  00                DCB      0x00
