; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\bluetooth.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\bluetooth.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP\GPS -I..\BSP\Sim900A -I..\BSP -I..\BSP\IWDG -I..\BSP\BlueTooth -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\BSP\Adxl345 -I..\BSP\TL718 -I..\BSP\PAM8403 -I..\BSP\W25X16 -I..\BSP\USB -I..\App\Debug -I..\App\SelfCheck -I..\App\GPSTask -I..\App\OBD -I..\App\Mems -I..\App\Voltage -I..\App\LKClient -I..\App\Paramlist -I..\App\ATC30 -I..\App -I..\BSP\mpu6050 -I..\App\mid-proc -I..\App\mpu6050Task -I..\BSP\dmp -I..\BSP\Bluetooth -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\bluetooth.crf ..\BSP\Bluetooth\BlueTooth.c]
                          THUMB

                          AREA ||i.BT_Enable_RcvIT||, CODE, READONLY, ALIGN=2

                  BT_Enable_RcvIT PROC
;;;68     
;;;69     void BT_Enable_RcvIT(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	USART_ITConfig(BT_COM, USART_IT_RXNE, ENABLE);
000002  2201              MOVS     r2,#1
000004  f2405125          MOV      r1,#0x525
000008  4801              LDR      r0,|L1.16|
00000a  f7fffffe          BL       USART_ITConfig
;;;72     	
;;;73     }
00000e  bd10              POP      {r4,pc}
;;;74     
                          ENDP

                  |L1.16|
                          DCD      0x40004c00

                          AREA ||i.BT_GPIO_INIT||, CODE, READONLY, ALIGN=2

                  BT_GPIO_INIT PROC
;;;74     
;;;75     void BT_GPIO_INIT(void)
000000  b508              PUSH     {r3,lr}
;;;76     {
;;;77     	GPIO_InitTypeDef GPIO_InitStructure;
;;;78     	RCC_APB2PeriphClockCmd(BT_POWER_RCC|BT_STA_RCC, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;79      
;;;80     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000a  2010              MOVS     r0,#0x10
00000c  f88d0003          STRB     r0,[sp,#3]
;;;81     	GPIO_InitStructure.GPIO_Pin = BT_POWER_PIN;
000010  0140              LSLS     r0,r0,#5
000012  f8ad0000          STRH     r0,[sp,#0]
;;;82     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000016  2002              MOVS     r0,#2
000018  f88d0002          STRB     r0,[sp,#2]
;;;83     	GPIO_Init(BT_POWER_PORT, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4807              LDR      r0,|L2.60|
000020  f7fffffe          BL       GPIO_Init
;;;84     	 
;;;85     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000024  2004              MOVS     r0,#4
000026  f88d0003          STRB     r0,[sp,#3]
;;;86     	GPIO_InitStructure.GPIO_Pin = BT_STA_PIN;
00002a  0180              LSLS     r0,r0,#6
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;87     	GPIO_Init(BT_STA_PORT, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  4802              LDR      r0,|L2.60|
000034  f7fffffe          BL       GPIO_Init
;;;88     	 
;;;89     }
000038  bd08              POP      {r3,pc}
;;;90     
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      0x40011000

                          AREA ||i.BT_INIT||, CODE, READONLY, ALIGN=1

                  BT_INIT PROC
;;;58     
;;;59     void BT_INIT(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61     	BT_GPIO_INIT();
000002  f7fffffe          BL       BT_GPIO_INIT
;;;62     	BT_UART_Enable();
000006  f7fffffe          BL       BT_UART_Enable
;;;63     	BT_Enable_RcvIT();
00000a  f7fffffe          BL       BT_Enable_RcvIT
;;;64     	BT_POWER_ON(); 
00000e  f7fffffe          BL       BT_POWER_ON
;;;65     }
000012  bd10              POP      {r4,pc}
;;;66     
                          ENDP


                          AREA ||i.BT_POWER_OFF||, CODE, READONLY, ALIGN=2

                  BT_POWER_OFF PROC
;;;95     
;;;96     void BT_POWER_OFF(void)
000000  b510              PUSH     {r4,lr}
;;;97     {
;;;98     	GPIO_SetBits(BT_POWER_PORT, BT_POWER_PIN);
000002  f44f7100          MOV      r1,#0x200
000006  4802              LDR      r0,|L4.16|
000008  f7fffffe          BL       GPIO_SetBits
;;;99     }
00000c  bd10              POP      {r4,pc}
;;;100    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40011000

                          AREA ||i.BT_POWER_ON||, CODE, READONLY, ALIGN=2

                  BT_POWER_ON PROC
;;;90     
;;;91     void BT_POWER_ON(void)
000000  b510              PUSH     {r4,lr}
;;;92     {
;;;93     	GPIO_ResetBits(BT_POWER_PORT, BT_POWER_PIN);
000002  f44f7100          MOV      r1,#0x200
000006  4802              LDR      r0,|L5.16|
000008  f7fffffe          BL       GPIO_ResetBits
;;;94     }
00000c  bd10              POP      {r4,pc}
;;;95     
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40011000

                          AREA ||i.BT_RTC_GET||, CODE, READONLY, ALIGN=2

                  BT_RTC_GET PROC
;;;113    
;;;114    void BT_RTC_GET(void)
000000  4829              LDR      r0,|L6.168|
;;;115    {
;;;116    	RTC_Time.year=(BT_Buffer[6]-'0')*1000+BT_Buffer[7]-'0'*100+BT_Buffer[8]-'0'*10+BT_Buffer[9]-'0';
000002  79c1              LDRB     r1,[r0,#7]  ; BT_Buffer
000004  7980              LDRB     r0,[r0,#6]  ; BT_Buffer
000006  3830              SUBS     r0,r0,#0x30
000008  eb000240          ADD      r2,r0,r0,LSL #1
00000c  ebc210c0          RSB      r0,r2,r0,LSL #7
000010  eb0100c0          ADD      r0,r1,r0,LSL #3
000014  f5a05096          SUB      r0,r0,#0x12c0
000018  4923              LDR      r1,|L6.168|
00001a  7a09              LDRB     r1,[r1,#8]  ; BT_Buffer
00001c  4408              ADD      r0,r0,r1
00001e  f5a070f0          SUB      r0,r0,#0x1e0
000022  4921              LDR      r1,|L6.168|
000024  7a49              LDRB     r1,[r1,#9]  ; BT_Buffer
000026  4408              ADD      r0,r0,r1
000028  3830              SUBS     r0,r0,#0x30
00002a  4920              LDR      r1,|L6.172|
00002c  8008              STRH     r0,[r1,#0]
;;;117    	RTC_Time.month=(BT_Buffer[11]-'0')*10+(BT_Buffer[12]-'0');
00002e  481e              LDR      r0,|L6.168|
000030  7b00              LDRB     r0,[r0,#0xc]  ; BT_Buffer
000032  3830              SUBS     r0,r0,#0x30
000034  491c              LDR      r1,|L6.168|
000036  7ac9              LDRB     r1,[r1,#0xb]  ; BT_Buffer
000038  3930              SUBS     r1,r1,#0x30
00003a  eb010181          ADD      r1,r1,r1,LSL #2
00003e  eb000041          ADD      r0,r0,r1,LSL #1
000042  491a              LDR      r1,|L6.172|
000044  7088              STRB     r0,[r1,#2]
;;;118    	RTC_Time.day=(BT_Buffer[14]-'0')*10+(BT_Buffer[15]-'0');
000046  4818              LDR      r0,|L6.168|
000048  7bc0              LDRB     r0,[r0,#0xf]  ; BT_Buffer
00004a  3830              SUBS     r0,r0,#0x30
00004c  4916              LDR      r1,|L6.168|
00004e  7b89              LDRB     r1,[r1,#0xe]  ; BT_Buffer
000050  3930              SUBS     r1,r1,#0x30
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  eb000041          ADD      r0,r0,r1,LSL #1
00005a  4914              LDR      r1,|L6.172|
00005c  70c8              STRB     r0,[r1,#3]
;;;119    	RTC_Time.hour=(BT_Buffer[17]-'0')*10+(BT_Buffer[18]-'0');
00005e  4812              LDR      r0,|L6.168|
000060  7c80              LDRB     r0,[r0,#0x12]  ; BT_Buffer
000062  3830              SUBS     r0,r0,#0x30
000064  4910              LDR      r1,|L6.168|
000066  7c49              LDRB     r1,[r1,#0x11]  ; BT_Buffer
000068  3930              SUBS     r1,r1,#0x30
00006a  eb010181          ADD      r1,r1,r1,LSL #2
00006e  eb000041          ADD      r0,r0,r1,LSL #1
000072  490e              LDR      r1,|L6.172|
000074  7108              STRB     r0,[r1,#4]
;;;120    	RTC_Time.min=(BT_Buffer[20]-'0')*10+(BT_Buffer[21]-'0');
000076  480c              LDR      r0,|L6.168|
000078  7d40              LDRB     r0,[r0,#0x15]  ; BT_Buffer
00007a  3830              SUBS     r0,r0,#0x30
00007c  490a              LDR      r1,|L6.168|
00007e  7d09              LDRB     r1,[r1,#0x14]  ; BT_Buffer
000080  3930              SUBS     r1,r1,#0x30
000082  eb010181          ADD      r1,r1,r1,LSL #2
000086  eb000041          ADD      r0,r0,r1,LSL #1
00008a  4908              LDR      r1,|L6.172|
00008c  7148              STRB     r0,[r1,#5]
;;;121    	RTC_Time.sec=(BT_Buffer[23]-'0')*10+(BT_Buffer[24]-'0');
00008e  4806              LDR      r0,|L6.168|
000090  7e00              LDRB     r0,[r0,#0x18]  ; BT_Buffer
000092  3830              SUBS     r0,r0,#0x30
000094  4904              LDR      r1,|L6.168|
000096  7dc9              LDRB     r1,[r1,#0x17]  ; BT_Buffer
000098  3930              SUBS     r1,r1,#0x30
00009a  eb010181          ADD      r1,r1,r1,LSL #2
00009e  eb000041          ADD      r0,r0,r1,LSL #1
0000a2  4902              LDR      r1,|L6.172|
0000a4  7188              STRB     r0,[r1,#6]
;;;122    }
0000a6  4770              BX       lr
;;;123    
                          ENDP

                  |L6.168|
                          DCD      BT_Buffer
                  |L6.172|
                          DCD      RTC_Time

                          AREA ||i.BT_STA_GET||, CODE, READONLY, ALIGN=2

                  BT_STA_GET PROC
;;;100    
;;;101    BOOLEAN BT_STA_GET(void)
000000  b510              PUSH     {r4,lr}
;;;102    {
;;;103    	if(GPIO_ReadInputDataBit(BT_STA_PORT,BT_STA_PIN))   return bTRUE;
000002  f44f7180          MOV      r1,#0x100
000006  4804              LDR      r0,|L7.24|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  b108              CBZ      r0,|L7.18|
00000e  2001              MOVS     r0,#1
                  |L7.16|
;;;104    	else return bFALSE;
;;;105    }
000010  bd10              POP      {r4,pc}
                  |L7.18|
000012  2000              MOVS     r0,#0                 ;104
000014  e7fc              B        |L7.16|
;;;106    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40011000

                          AREA ||i.BT_Task||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  BT_Task PROC
;;;261    
;;;262    void BT_Task(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;263    {
000004  b087              SUB      sp,sp,#0x1c
;;;264    	 
;;;265      
;;;266    	//if(BT_STA_GET()==bTRUE)//RMLStrcpy((BYTE *)time_sta,(BYTE *)"FAIL",4);
;;;267    	 
;;;268         
;;;269    	      printf("#SPEED:%d;#RPM:%d;#TEMPERATURE:%d;#VOLTAGE:%d;#MILEAGE:%d;#MIN:%d;#KPK:%d;#TIME_STA:%s",
000006  f7fffffe          BL       OBD_GetDrvTime
00000a  4604              MOV      r4,r0
00000c  f7fffffe          BL       OBD_GetDrvKiloMeter
000010  4681              MOV      r9,r0
000012  f7fffffe          BL       GetVoltage
000016  4607              MOV      r7,r0
000018  2200              MOVS     r2,#0
00001a  4b12              LDR      r3,|L8.100|
00001c  f7fffffe          BL       __aeabi_dmul
000020  4605              MOV      r5,r0
000022  f7fffffe          BL       __aeabi_d2iz
000026  4682              MOV      r10,r0
000028  f7fffffe          BL       OBD_GetWaterTemperature
00002c  4683              MOV      r11,r0
00002e  f7fffffe          BL       OBD_GetEngineSpeed
000032  9006              STR      r0,[sp,#0x18]
000034  f7fffffe          BL       OBD_GetCarSpeed
000038  9005              STR      r0,[sp,#0x14]
00003a  480b              LDR      r0,|L8.104|
00003c  2100              MOVS     r1,#0
00003e  465b              MOV      r3,r11
000040  e9cda900          STRD     r10,r9,[sp,#0]
000044  e9cd4102          STRD     r4,r1,[sp,#8]
000048  9004              STR      r0,[sp,#0x10]
00004a  4808              LDR      r0,|L8.108|
00004c  e9dd1205          LDRD     r1,r2,[sp,#0x14]
000050  f7fffffe          BL       __2printf
;;;270    					OBD_GetCarSpeed(),OBD_GetEngineSpeed(),OBD_GetWaterTemperature(),(int)(10*GetVoltage()),OBD_GetDrvKiloMeter(),
;;;271    				OBD_GetDrvTime(),0,time_sta);
;;;272              
;;;273                   Timer_Set(&BluethSampleTim1,100);
000054  2164              MOVS     r1,#0x64
000056  4806              LDR      r0,|L8.112|
000058  f7fffffe          BL       Timer_Set
;;;274    		 
;;;275    	
;;;276     
;;;277      
;;;278    	//}
;;;279    		/*	if(Flag_Rcv==bTRUE)
;;;280    	{
;;;281    		BT_RTC_GET();
;;;282    		Flag_Rcv=bFALSE;
;;;283    		Flag_RTC=bFALSE;
;;;284    		memset(time_sta,0,4);
;;;285    		RMLStrcpy((BYTE *)time_sta,(BYTE *)"OK",2);
;;;286    	}*/
;;;287    	 
;;;288    }
00005c  b007              ADD      sp,sp,#0x1c
00005e  e8bd8ff0          POP      {r4-r11,pc}
;;;289    
                          ENDP

000062  0000              DCW      0x0000
                  |L8.100|
                          DCD      0x40240000
                  |L8.104|
                          DCD      time_sta
                  |L8.108|
                          DCD      ||.constdata||
                  |L8.112|
                          DCD      BluethSampleTim1

                          AREA ||i.BT_UART_Enable||, CODE, READONLY, ALIGN=1

                  BT_UART_Enable PROC
;;;178       Description: 使能 接收串口 */
;;;179    void BT_UART_Enable(void)
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181    	BT_COM_INIT(9600);
000002  f44f5016          MOV      r0,#0x2580
000006  f7fffffe          BL       UART4_Init
;;;182    }
00000a  bd10              POP      {r4,pc}
;;;183    
                          ENDP


                          AREA ||i.BT_USART_ReceiveData||, CODE, READONLY, ALIGN=2

                  BT_USART_ReceiveData PROC
;;;143    
;;;144    void BT_USART_ReceiveData(char Value)
000000  283b              CMP      r0,#0x3b
;;;145    {
;;;146    	if(Value==';')
000002  d100              BNE      |L10.6|
                  |L10.4|
;;;147    	{
;;;148    		//Flag_Rcv=bTRUE;
;;;149    		return;
;;;150    	}
;;;151    	if(BT_Len>(BT_BUFFER_SIZE-1))
;;;152    	{
;;;153    		BT_Len=0;
;;;154    	}
;;;155    	BT_Buffer[BT_Len++]=Value;
;;;156    }
000004  4770              BX       lr
                  |L10.6|
000006  4908              LDR      r1,|L10.40|
000008  7809              LDRB     r1,[r1,#0]            ;151  ; BT_Len
00000a  2919              CMP      r1,#0x19              ;151
00000c  dd02              BLE      |L10.20|
00000e  2100              MOVS     r1,#0                 ;153
000010  4a05              LDR      r2,|L10.40|
000012  7011              STRB     r1,[r2,#0]            ;153
                  |L10.20|
000014  4904              LDR      r1,|L10.40|
000016  780a              LDRB     r2,[r1,#0]            ;155  ; BT_Len
000018  7809              LDRB     r1,[r1,#0]            ;155  ; BT_Len
00001a  1c49              ADDS     r1,r1,#1              ;155
00001c  4b02              LDR      r3,|L10.40|
00001e  7019              STRB     r1,[r3,#0]            ;155
000020  4902              LDR      r1,|L10.44|
000022  5488              STRB     r0,[r1,r2]            ;155
000024  bf00              NOP      
000026  e7ed              B        |L10.4|
;;;157    
                          ENDP

                  |L10.40|
                          DCD      BT_Len
                  |L10.44|
                          DCD      BT_Buffer

                          AREA ||i.Blueth_Disable_RcvIT||, CODE, READONLY, ALIGN=2

                  Blueth_Disable_RcvIT PROC
;;;193       Description: 失能 接收中断 */
;;;194    void Blueth_Disable_RcvIT(void)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196    	UART_Config_RxInterrupt(BT_COM,DISABLE);
000002  2100              MOVS     r1,#0
000004  4801              LDR      r0,|L11.12|
000006  f7fffffe          BL       UART_Config_RxInterrupt
;;;197    }
00000a  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L11.12|
                          DCD      0x40004c00

                          AREA ||i.Blueth_Enable_RcvIT||, CODE, READONLY, ALIGN=2

                  Blueth_Enable_RcvIT PROC
;;;184     
;;;185    void Blueth_Enable_RcvIT(void)
000000  b510              PUSH     {r4,lr}
;;;186    {
;;;187    	UART_Config_RxInterrupt(BT_COM,ENABLE);
000002  2101              MOVS     r1,#1
000004  4801              LDR      r0,|L12.12|
000006  f7fffffe          BL       UART_Config_RxInterrupt
;;;188    
;;;189    }
00000a  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  |L12.12|
                          DCD      0x40004c00

                          AREA ||i.Blueth_GetUsartData||, CODE, READONLY, ALIGN=2

                  Blueth_GetUsartData PROC
;;;201       Description:  中断接收      */
;;;202    void Blueth_GetUsartData(BYTE Value)
000000  491c              LDR      r1,|L13.116|
;;;203    {
;;;204    	if(BluethData_bAvail == bTRUE)    //如果已经有数据
000002  7809              LDRB     r1,[r1,#0]  ; BluethData_bAvail
000004  2901              CMP      r1,#1
000006  d100              BNE      |L13.10|
                  |L13.8|
;;;205    	{
;;;206    	    return;
;;;207    	}
;;;208    	
;;;209    	if( BluethDataLen == Blueth_DATA_BUFFER_SIZE)  // 如果缓存溢出
;;;210    	{					   
;;;211    	    OBDataLen = 0;
;;;212    	}
;;;213    	if(BluethRcvOver == bTRUE)
;;;214    	{
;;;215    		if( Value == 0x3E )      // ‘>’ 标识
;;;216    		{
;;;217    
;;;218    			BluethData[BluethDataLen++] = Value;
;;;219    			BluethData_bAvail = bTRUE;
;;;220    		}
;;;221    		else    //未找到标识，继续接收
;;;222    		{
;;;223    			BluethData[OBDataLen++] = Value;
;;;224    			BluethRcvOver = bFALSE;
;;;225    		}
;;;226    	}
;;;227    	else
;;;228    	{
;;;229    		if(Value == 0x0A)  //接收到尾
;;;230    		{
;;;231    			BluethRcvOver = bTRUE;
;;;232    		}
;;;233    		BluethData[BluethDataLen++] = Value;
;;;234    	}
;;;235    }
000008  4770              BX       lr
                  |L13.10|
00000a  491b              LDR      r1,|L13.120|
00000c  8809              LDRH     r1,[r1,#0]            ;209  ; BluethDataLen
00000e  29c8              CMP      r1,#0xc8              ;209
000010  d102              BNE      |L13.24|
000012  2100              MOVS     r1,#0                 ;211
000014  4a19              LDR      r2,|L13.124|
000016  8011              STRH     r1,[r2,#0]            ;211
                  |L13.24|
000018  4919              LDR      r1,|L13.128|
00001a  7809              LDRB     r1,[r1,#0]            ;213  ; BluethRcvOver
00001c  2901              CMP      r1,#1                 ;213
00001e  d119              BNE      |L13.84|
000020  283e              CMP      r0,#0x3e              ;215
000022  d10b              BNE      |L13.60|
000024  4914              LDR      r1,|L13.120|
000026  880a              LDRH     r2,[r1,#0]            ;218  ; BluethDataLen
000028  8809              LDRH     r1,[r1,#0]            ;218  ; BluethDataLen
00002a  1c49              ADDS     r1,r1,#1              ;218
00002c  4b12              LDR      r3,|L13.120|
00002e  8019              STRH     r1,[r3,#0]            ;218
000030  4914              LDR      r1,|L13.132|
000032  5488              STRB     r0,[r1,r2]            ;218
000034  2101              MOVS     r1,#1                 ;219
000036  4a0f              LDR      r2,|L13.116|
000038  7011              STRB     r1,[r2,#0]            ;219
00003a  e018              B        |L13.110|
                  |L13.60|
00003c  490f              LDR      r1,|L13.124|
00003e  880a              LDRH     r2,[r1,#0]            ;223  ; OBDataLen
000040  8809              LDRH     r1,[r1,#0]            ;223  ; OBDataLen
000042  1c49              ADDS     r1,r1,#1              ;223
000044  4b0d              LDR      r3,|L13.124|
000046  8019              STRH     r1,[r3,#0]            ;223
000048  490e              LDR      r1,|L13.132|
00004a  5488              STRB     r0,[r1,r2]            ;223
00004c  2100              MOVS     r1,#0                 ;224
00004e  4a0c              LDR      r2,|L13.128|
000050  7011              STRB     r1,[r2,#0]            ;224
000052  e00c              B        |L13.110|
                  |L13.84|
000054  280a              CMP      r0,#0xa               ;229
000056  d102              BNE      |L13.94|
000058  2101              MOVS     r1,#1                 ;231
00005a  4a09              LDR      r2,|L13.128|
00005c  7011              STRB     r1,[r2,#0]            ;231
                  |L13.94|
00005e  4906              LDR      r1,|L13.120|
000060  880a              LDRH     r2,[r1,#0]            ;233  ; BluethDataLen
000062  8809              LDRH     r1,[r1,#0]            ;233  ; BluethDataLen
000064  1c49              ADDS     r1,r1,#1              ;233
000066  4b04              LDR      r3,|L13.120|
000068  8019              STRH     r1,[r3,#0]            ;233
00006a  4906              LDR      r1,|L13.132|
00006c  5488              STRB     r0,[r1,r2]            ;233
                  |L13.110|
00006e  bf00              NOP      
000070  e7ca              B        |L13.8|
;;;236    
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      BluethData_bAvail
                  |L13.120|
                          DCD      BluethDataLen
                  |L13.124|
                          DCD      OBDataLen
                  |L13.128|
                          DCD      BluethRcvOver
                  |L13.132|
                          DCD      BluethData

                          AREA ||i.Blueth_RcvDataInit||, CODE, READONLY, ALIGN=2

                  Blueth_RcvDataInit PROC
;;;237    
;;;238    void Blueth_RcvDataInit(void)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240    	BluethData_bAvail = bFALSE;
000002  2000              MOVS     r0,#0
000004  4905              LDR      r1,|L14.28|
000006  7008              STRB     r0,[r1,#0]
;;;241    	BluethRcvOver = bFALSE;
000008  4905              LDR      r1,|L14.32|
00000a  7008              STRB     r0,[r1,#0]
;;;242    	BluethDataLen = 0;
00000c  4905              LDR      r1,|L14.36|
00000e  8008              STRH     r0,[r1,#0]
;;;243    	memset( BluethData , 0 , Blueth_DATA_BUFFER_SIZE);
000010  21c8              MOVS     r1,#0xc8
000012  4805              LDR      r0,|L14.40|
000014  f7fffffe          BL       __aeabi_memclr
;;;244    }
000018  bd10              POP      {r4,pc}
;;;245    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      BluethData_bAvail
                  |L14.32|
                          DCD      BluethRcvOver
                  |L14.36|
                          DCD      BluethDataLen
                  |L14.40|
                          DCD      BluethData

                          AREA ||i.Bluetooth_SendData||, CODE, READONLY, ALIGN=2

                  Bluetooth_SendData PROC
;;;246    
;;;247    void Bluetooth_SendData( BYTE * Cmd , INT8U CmdLen)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;249    	INT8U i;
;;;250    
;;;251    	OBD_RcvDataInit();	
000006  f7fffffe          BL       OBD_RcvDataInit
;;;252    	
;;;253    	for ( i = 0; i < CmdLen; i++ )
00000a  2600              MOVS     r6,#0
00000c  e00d              B        |L15.42|
                  |L15.14|
;;;254    	{
;;;255    		USART_SendData(BT_COM, *Cmd++);
00000e  f8141b01          LDRB     r1,[r4],#1
000012  4807              LDR      r0,|L15.48|
000014  f7fffffe          BL       USART_SendData
;;;256    		while(USART_GetFlagStatus(BT_COM, USART_FLAG_TXE) == RESET); //非空等待
000018  bf00              NOP      
                  |L15.26|
00001a  2180              MOVS     r1,#0x80
00001c  4804              LDR      r0,|L15.48|
00001e  f7fffffe          BL       USART_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L15.26|
000026  1c70              ADDS     r0,r6,#1              ;253
000028  b2c6              UXTB     r6,r0                 ;253
                  |L15.42|
00002a  42ae              CMP      r6,r5                 ;253
00002c  dbef              BLT      |L15.14|
;;;257    	}
;;;258    }
00002e  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP

                  |L15.48|
                          DCD      0x40004c00

                          AREA ||i.ClrBluethUartIO||, CODE, READONLY, ALIGN=2

                  ClrBluethUartIO PROC
;;;159    
;;;160    void ClrBluethUartIO(void)
000000  b508              PUSH     {r3,lr}
;;;161    {
;;;162    	GPIO_InitTypeDef GPIO_InitStructure;
;;;163    
;;;164    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_AFIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  2011              MOVS     r0,#0x11
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;165    	
;;;166    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00000a  2004              MOVS     r0,#4
00000c  f88d0003          STRB     r0,[sp,#3]
;;;167    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000010  0200              LSLS     r0,r0,#8
000012  f8ad0000          STRH     r0,[sp,#0]
;;;168    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4806              LDR      r0,|L16.52|
00001a  f7fffffe          BL       GPIO_Init
;;;169    	
;;;170    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00001e  2004              MOVS     r0,#4
000020  f88d0003          STRB     r0,[sp,#3]
;;;171    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000024  0240              LSLS     r0,r0,#9
000026  f8ad0000          STRH     r0,[sp,#0]
;;;172    	GPIO_Init(GPIOC, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4801              LDR      r0,|L16.52|
00002e  f7fffffe          BL       GPIO_Init
;;;173    
;;;174    }
000032  bd08              POP      {r3,pc}
;;;175    
                          ENDP

                  |L16.52|
                          DCD      0x40011000

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;106    
;;;107    int fputc(int ch, FILE *f)  
000000  b570              PUSH     {r4-r6,lr}
;;;108    {   
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;109    	BT_COM->DR = (u8) ch;   
000006  b2e0              UXTB     r0,r4
000008  4905              LDR      r1,|L17.32|
00000a  8008              STRH     r0,[r1,#0]
;;;110    	while(USART_GetFlagStatus(BT_COM, USART_FLAG_TXE) == RESET);
00000c  bf00              NOP      
                  |L17.14|
00000e  2180              MOVS     r1,#0x80
000010  4803              LDR      r0,|L17.32|
000012  1f00              SUBS     r0,r0,#4
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f8              BEQ      |L17.14|
;;;111    	return ch;  
00001c  4620              MOV      r0,r4
;;;112    }
00001e  bd70              POP      {r4-r6,pc}
;;;113    
                          ENDP

                  |L17.32|
                          DCD      0x40004c04

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  BT_Buffer
                          %        26
                  BluethData
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  23535045          DCB      0x23,0x53,0x50,0x45
000004  45443a25          DCB      0x45,0x44,0x3a,0x25
000008  643b2352          DCB      0x64,0x3b,0x23,0x52
00000c  504d3a25          DCB      0x50,0x4d,0x3a,0x25
000010  643b2354          DCB      0x64,0x3b,0x23,0x54
000014  454d5045          DCB      0x45,0x4d,0x50,0x45
000018  52415455          DCB      0x52,0x41,0x54,0x55
00001c  52453a25          DCB      0x52,0x45,0x3a,0x25
000020  643b2356          DCB      0x64,0x3b,0x23,0x56
000024  4f4c5441          DCB      0x4f,0x4c,0x54,0x41
000028  47453a25          DCB      0x47,0x45,0x3a,0x25
00002c  643b234d          DCB      0x64,0x3b,0x23,0x4d
000030  494c4541          DCB      0x49,0x4c,0x45,0x41
000034  47453a25          DCB      0x47,0x45,0x3a,0x25
000038  643b234d          DCB      0x64,0x3b,0x23,0x4d
00003c  494e3a25          DCB      0x49,0x4e,0x3a,0x25
000040  643b234b          DCB      0x64,0x3b,0x23,0x4b
000044  504b3a25          DCB      0x50,0x4b,0x3a,0x25
000048  643b2354          DCB      0x64,0x3b,0x23,0x54
00004c  494d455f          DCB      0x49,0x4d,0x45,0x5f
000050  5354413a          DCB      0x53,0x54,0x41,0x3a
000054  257300            DCB      0x25,0x73,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  6100              DCB      "a",0

                          AREA ||.data||, DATA, ALIGN=2

                  BT_Len
000000  00                DCB      0x00
                  time_sta
000001  4f4b00            DCB      0x4f,0x4b,0x00
000004  00                DCB      0x00
                  BluethData_sendf
000005  010000            DCB      0x01,0x00,0x00
                  BT_Cmd_Set
                          DCD      ||.conststring||
00000c  01000000          DCB      0x01,0x00,0x00,0x00
                  BluethRcvOver
000010  00                DCB      0x00
                  BluethData_bAvail
000011  00                DCB      0x00
                  Blue_AllowAct
000012  0000              DCB      0x00,0x00
                  BluethDataLen
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  BluethSampleTim1
                          %        8
                  RTC_Time
                          %        8
