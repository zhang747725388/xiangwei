; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\rtime.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\rtime.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP -I..\BSP\IWDG -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\App\Debug -I..\App\SelfCheck -I..\App\Voltage -I..\App\ATC30 -I..\App -I..\BSP\uart -I..\App\Task -I..\App\Task -IH:\gitprojecct\xiangwei\Project\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\rtime.crf ..\Kernel\rtime.c]
                          THUMB

                          AREA ||i.InputCaptureInit||, CODE, READONLY, ALIGN=1

                  InputCaptureInit PROC
;;;55     }		
;;;56     void InputCaptureInit( void )
000000  b500              PUSH     {lr}
;;;57     {
000002  b087              SUB      sp,sp,#0x1c
;;;58     	TIM_ICInitTypeDef 		TIM_ICInitStructure;
;;;59     	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
;;;60     	
;;;61        RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM2, ENABLE );
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;62     	
;;;63     	TIM_TimeBaseInitStructure.TIM_Period             = 0xffff; // 16位计数
00000c  f64f70ff          MOV      r0,#0xffff
000010  f8ad0008          STRH     r0,[sp,#8]
;;;64     	TIM_TimeBaseInitStructure.TIM_Prescaler          = 72*2-1;   // 144分频 2us
000014  208f              MOVS     r0,#0x8f
000016  f8ad0004          STRH     r0,[sp,#4]
;;;65     	TIM_TimeBaseInitStructure.TIM_ClockDivision     = 0;      // 不分割
00001a  2000              MOVS     r0,#0
00001c  f8ad000a          STRH     r0,[sp,#0xa]
;;;66     	TIM_TimeBaseInitStructure.TIM_CounterMode   = TIM_CounterMode_Up; // 上升计数
000020  f8ad0006          STRH     r0,[sp,#6]
;;;67     	TIM_TimeBaseInit( TIM2, &TIM_TimeBaseInitStructure );
000024  a901              ADD      r1,sp,#4
000026  f04f4080          MOV      r0,#0x40000000
00002a  f7fffffe          BL       TIM_TimeBaseInit
;;;68     	TIM_ITConfig( TIM2, TIM_IT_Update, DISABLE );
00002e  2200              MOVS     r2,#0
000030  2101              MOVS     r1,#1
000032  0788              LSLS     r0,r1,#30
000034  f7fffffe          BL       TIM_ITConfig
;;;69     	TIM_ClearFlag(TIM2, TIM_FLAG_Update);
000038  2101              MOVS     r1,#1
00003a  0788              LSLS     r0,r1,#30
00003c  f7fffffe          BL       TIM_ClearFlag
;;;70     	
;;;71     	TIM_ICInitStructure.TIM_Channel       = TIM_Channel_2;				// 选择通道2
000040  2004              MOVS     r0,#4
000042  f8ad0010          STRH     r0,[sp,#0x10]
;;;72     	TIM_ICInitStructure.TIM_ICPolarity     = TIM_ICPolarity_Falling;		       // 下降沿触发
000046  2002              MOVS     r0,#2
000048  f8ad0012          STRH     r0,[sp,#0x12]
;;;73     	TIM_ICInitStructure.TIM_ICPrescaler   = TIM_ICPSC_DIV1;				//
00004c  2000              MOVS     r0,#0
00004e  f8ad0016          STRH     r0,[sp,#0x16]
;;;74     	TIM_ICInitStructure.TIM_ICSelection  = TIM_ICSelection_DirectTI;
000052  2001              MOVS     r0,#1
000054  f8ad0014          STRH     r0,[sp,#0x14]
;;;75     	TIM_ICInitStructure.TIM_ICFilter        = 0x0;	
000058  2000              MOVS     r0,#0
00005a  f8ad0018          STRH     r0,[sp,#0x18]
;;;76     	TIM_ICInit( TIM2, &TIM_ICInitStructure );
00005e  a904              ADD      r1,sp,#0x10
000060  f04f4080          MOV      r0,#0x40000000
000064  f7fffffe          BL       TIM_ICInit
;;;77     	TIM_ITConfig( TIM2, TIM_IT_CC2, DISABLE );
000068  2200              MOVS     r2,#0
00006a  2104              MOVS     r1,#4
00006c  0708              LSLS     r0,r1,#28
00006e  f7fffffe          BL       TIM_ITConfig
;;;78     	TIM_ClearFlag( TIM2, TIM_FLAG_CC2 );	
000072  2104              MOVS     r1,#4
000074  0708              LSLS     r0,r1,#28
000076  f7fffffe          BL       TIM_ClearFlag
;;;79     	TIM_Cmd( TIM2, ENABLE );
00007a  2101              MOVS     r1,#1
00007c  0788              LSLS     r0,r1,#30
00007e  f7fffffe          BL       TIM_Cmd
;;;80     	TIM_ITConfig( TIM2, TIM_IT_CC2 | TIM_IT_Update, ENABLE );
000082  2201              MOVS     r2,#1
000084  2105              MOVS     r1,#5
000086  0788              LSLS     r0,r1,#30
000088  f7fffffe          BL       TIM_ITConfig
;;;81     }
00008c  b007              ADD      sp,sp,#0x1c
00008e  bd00              POP      {pc}
;;;82     
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;46     ------------------------------------------------------------------------------*/
;;;47     void SysTick_Handler(void)
000000  b500              PUSH     {lr}
;;;48     {
;;;49     	static INT32U tickcnt = 0;
;;;50     	if ( ++tickcnt >= RML_SYSTICK_TIME )
000002  4806              LDR      r0,|L2.28|
000004  6800              LDR      r0,[r0,#0]  ; tickcnt
000006  1c40              ADDS     r0,r0,#1
000008  4904              LDR      r1,|L2.28|
00000a  6008              STR      r0,[r1,#0]  ; tickcnt
00000c  280a              CMP      r0,#0xa
00000e  d303              BCC      |L2.24|
;;;51     	{
;;;52     		tickcnt = 0;
000010  2000              MOVS     r0,#0
000012  6008              STR      r0,[r1,#0]  ; tickcnt
;;;53     		Timer_TickISR();
000014  f7fffffe          BL       Timer_TickISR
                  |L2.24|
;;;54     	}
;;;55     }		
000018  bd00              POP      {pc}
;;;56     void InputCaptureInit( void )
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      tickcnt

                          AREA ||i.Systick_Init||, CODE, READONLY, ALIGN=2

                  Systick_Init PROC
;;;17     
;;;18     void Systick_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;19     {
;;;20     	INT16U systick_fac_ms = RML_SYSCLK_FREQ / 8 / 1000; 		// 1ms interval    
000002  f2423228          MOV      r2,#0x2328
;;;21     
;;;22     	/* Set reload register */
;;;23     	SysTick->LOAD  = (systick_fac_ms & SysTick_LOAD_RELOAD_Msk) - 1;
000006  1e50              SUBS     r0,r2,#1
000008  f04f21e0          MOV      r1,#0xe000e000
00000c  6148              STR      r0,[r1,#0x14]
;;;24     	
;;;25     	/* Set priority for Cortex-M3 System Interrupts */
;;;26     	NVIC_SetPriority(SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);
00000e  1748              ASRS     r0,r1,#29
000010  210f              MOVS     r1,#0xf
000012  2800              CMP      r0,#0
000014  da07              BGE      |L3.38|
000016  070b              LSLS     r3,r1,#28
000018  0e1d              LSRS     r5,r3,#24
00001a  4b09              LDR      r3,|L3.64|
00001c  f000040f          AND      r4,r0,#0xf
000020  1f24              SUBS     r4,r4,#4
000022  551d              STRB     r5,[r3,r4]
000024  e003              B        |L3.46|
                  |L3.38|
000026  070b              LSLS     r3,r1,#28
000028  0e1c              LSRS     r4,r3,#24
00002a  4b06              LDR      r3,|L3.68|
00002c  541c              STRB     r4,[r3,r0]
                  |L3.46|
00002e  bf00              NOP      
;;;27     	
;;;28     	/* Load the SysTick Counter Value */  
;;;29     	SysTick->VAL   = 0; 
000030  2000              MOVS     r0,#0
000032  f04f21e0          MOV      r1,#0xe000e000
000036  6188              STR      r0,[r1,#0x18]
;;;30     	
;;;31     	/* Enable SysTick IRQ and SysTick Timer */                                         
;;;32     	SysTick->CTRL  = //SysTick_CTRL_CLKSOURCE_Msk | 
000038  2003              MOVS     r0,#3
00003a  6108              STR      r0,[r1,#0x10]
;;;33     	               SysTick_CTRL_TICKINT_Msk   | 
;;;34     	               SysTick_CTRL_ENABLE_Msk;                   
;;;35     
;;;36     }
00003c  bd30              POP      {r4,r5,pc}
;;;37     
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      0xe000ed18
                  |L3.68|
                          DCD      0xe000e400

                          AREA ||i.Timer_Delayms||, CODE, READONLY, ALIGN=1

                  Timer_Delayms PROC
;;;154    }
;;;155    void Timer_Delayms(u32 ms)
000000  b51c              PUSH     {r2-r4,lr}
;;;156    {
000002  4604              MOV      r4,r0
;;;157    	SYSTIMER time;
;;;158    	
;;;159    	Timer_Set(&time, ms);
000004  4621              MOV      r1,r4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       Timer_Set
;;;160    	while(!Timer_GetReached(&time))
00000c  bf00              NOP      
                  |L4.14|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       Timer_GetReached
000014  2800              CMP      r0,#0
000016  d0fa              BEQ      |L4.14|
;;;161    	{}
;;;162    }
000018  bd1c              POP      {r2-r4,pc}
                          ENDP


                          AREA ||i.Timer_GetElapse||, CODE, READONLY, ALIGN=2

                  Timer_GetElapse PROC
;;;133    ------------------------------------------------------------------------------*/
;;;134    INT32U Timer_GetElapse(SYSTIMER *timer)
000000  4601              MOV      r1,r0
;;;135    {
;;;136    	return	(r_tickcnt - timer->start_cnt) * RML_SYSTICK_TIME; 
000002  4a04              LDR      r2,|L5.20|
000004  6808              LDR      r0,[r1,#0]
000006  6812              LDR      r2,[r2,#0]  ; r_tickcnt
000008  1a10              SUBS     r0,r2,r0
00000a  eb000080          ADD      r0,r0,r0,LSL #2
00000e  0040              LSLS     r0,r0,#1
;;;137    }
000010  4770              BX       lr
;;;138    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      r_tickcnt

                          AREA ||i.Timer_GetReached||, CODE, READONLY, ALIGN=1

                  Timer_GetReached PROC
;;;147    ------------------------------------------------------------------------------*/
;;;148    BOOLEAN Timer_GetReached(SYSTIMER *timer)
000000  b500              PUSH     {lr}
;;;149    {
000002  4603              MOV      r3,r0
;;;150    	if((timer -> alarm_time) != 0){
000004  6858              LDR      r0,[r3,#4]
000006  b148              CBZ      r0,|L6.28|
;;;151    		return ( Timer_GetElapse(timer) >= timer->alarm_time ) ? bTRUE : bFALSE;
000008  4618              MOV      r0,r3
00000a  f7fffffe          BL       Timer_GetElapse
00000e  6859              LDR      r1,[r3,#4]
000010  4288              CMP      r0,r1
000012  d301              BCC      |L6.24|
000014  2001              MOVS     r0,#1
                  |L6.22|
;;;152    	}
;;;153    	return (bFALSE);
;;;154    }
000016  bd00              POP      {pc}
                  |L6.24|
000018  2000              MOVS     r0,#0                 ;151
00001a  e7fc              B        |L6.22|
                  |L6.28|
00001c  2000              MOVS     r0,#0                 ;153
00001e  e7fa              B        |L6.22|
;;;155    void Timer_Delayms(u32 ms)
                          ENDP


                          AREA ||i.Timer_Reset||, CODE, READONLY, ALIGN=2

                  Timer_Reset PROC
;;;119    ------------------------------------------------------------------------------*/
;;;120    void Timer_Reset(SYSTIMER *timer)
000000  4901              LDR      r1,|L7.8|
;;;121    {
;;;122    	timer->start_cnt = r_tickcnt;
000002  6809              LDR      r1,[r1,#0]  ; r_tickcnt
000004  6001              STR      r1,[r0,#0]
;;;123    }
000006  4770              BX       lr
;;;124    
                          ENDP

                  |L7.8|
                          DCD      r_tickcnt

                          AREA ||i.Timer_Set||, CODE, READONLY, ALIGN=2

                  Timer_Set PROC
;;;104    ------------------------------------------------------------------------------*/
;;;105    void Timer_Set(SYSTIMER *timer, INT32U alarm_time)
000000  4a02              LDR      r2,|L8.12|
;;;106    {
;;;107    	timer->start_cnt = r_tickcnt;
000002  6812              LDR      r2,[r2,#0]  ; r_tickcnt
000004  6002              STR      r2,[r0,#0]
;;;108    	timer->alarm_time = alarm_time;	
000006  6041              STR      r1,[r0,#4]
;;;109    }
000008  4770              BX       lr
;;;110    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      r_tickcnt

                          AREA ||i.Timer_TickISR||, CODE, READONLY, ALIGN=2

                  Timer_TickISR PROC
;;;90     ------------------------------------------------------------------------------*/
;;;91     void Timer_TickISR(void)
000000  4802              LDR      r0,|L9.12|
;;;92     {
;;;93     	++r_tickcnt;
000002  6800              LDR      r0,[r0,#0]  ; r_tickcnt
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L9.12|
000008  6008              STR      r0,[r1,#0]  ; r_tickcnt
;;;94     }
00000a  4770              BX       lr
;;;95     
                          ENDP

                  |L9.12|
                          DCD      r_tickcnt

                          AREA ||.data||, DATA, ALIGN=2

                  r_tickcnt
                          DCD      0x00000000
                  tickcnt
                          DCD      0x00000000
