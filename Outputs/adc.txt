; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\adc.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP -I..\BSP\IWDG -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\App\Debug -I..\App\SelfCheck -I..\App\Voltage -I..\App\ATC30 -I..\App -I..\BSP\uart -I..\App\Task -I..\App\Task -IH:\gitprojecct\xiangwei\Project\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\adc.crf ..\BSP\ADC\adc.c]
                          THUMB

                          AREA ||i.ADC_GetValue||, CODE, READONLY, ALIGN=2

                  ADC_GetValue PROC
;;;45     
;;;46     INT32U ADC_GetValue(void)
000000  b510              PUSH     {r4,lr}
;;;47     {
;;;48     	if ( ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == SET )
000002  2102              MOVS     r1,#2
000004  4805              LDR      r0,|L1.28|
000006  f7fffffe          BL       ADC_GetFlagStatus
00000a  2801              CMP      r0,#1
00000c  d103              BNE      |L1.22|
;;;49     	{
;;;50     		return ADC_GetConversionValue(ADC1);
00000e  4803              LDR      r0,|L1.28|
000010  f7fffffe          BL       ADC_GetConversionValue
                  |L1.20|
;;;51     	}
;;;52     	else
;;;53     	{
;;;54     		return ADC_NOT_READY;
;;;55     	}
;;;56     }
000014  bd10              POP      {r4,pc}
                  |L1.22|
000016  f04f30ff          MOV      r0,#0xffffffff        ;54
00001a  e7fb              B        |L1.20|
;;;57     
                          ENDP

                  |L1.28|
                          DCD      0x40012400

                          AREA ||i.ADC_InitChannel||, CODE, READONLY, ALIGN=2

                  ADC_InitChannel PROC
;;;5      
;;;6      void ADC_InitChannel(void)
000000  b500              PUSH     {lr}
;;;7      {
000002  b087              SUB      sp,sp,#0x1c
;;;8      	GPIO_InitTypeDef GPIO_InitStructure;
;;;9      	ADC_InitTypeDef ADC_InitStructure;
;;;10     	
;;;11     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2402011          MOV      r0,#0x211
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;12     	
;;;13     	/* Configure PA.01 (ADC Channel 1) as analog input -------------------------*/
;;;14     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
00000e  2002              MOVS     r0,#2
000010  f8ad0018          STRH     r0,[sp,#0x18]
;;;15     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d001a          STRB     r0,[sp,#0x1a]
;;;16     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001a  2000              MOVS     r0,#0
00001c  f88d001b          STRB     r0,[sp,#0x1b]
;;;17     	GPIO_Init(GPIOC, &GPIO_InitStructure);   
000020  a906              ADD      r1,sp,#0x18
000022  481c              LDR      r0,|L2.148|
000024  f7fffffe          BL       GPIO_Init
;;;18     	
;;;19     	/* ADC1 configuration ------------------------------------------------------*/
;;;20     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	                /* 独立模式 */
000028  2000              MOVS     r0,#0
00002a  9001              STR      r0,[sp,#4]
;;;21     	ADC_InitStructure.ADC_ScanConvMode = ENABLE;			            /* 连续多通道模式 */
00002c  2001              MOVS     r0,#1
00002e  f88d0008          STRB     r0,[sp,#8]
;;;22     	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	                /* 连续转换 */
000032  f88d0009          STRB     r0,[sp,#9]
;;;23     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; /* 转换不受外界决定 */
000036  f44f2060          MOV      r0,#0xe0000
00003a  9003              STR      r0,[sp,#0xc]
;;;24     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;		        /* 右对齐 */
00003c  2000              MOVS     r0,#0
00003e  9004              STR      r0,[sp,#0x10]
;;;25     	ADC_InitStructure.ADC_NbrOfChannel = 11;					            /* 扫描通道数 */
000040  200b              MOVS     r0,#0xb
000042  f88d0014          STRB     r0,[sp,#0x14]
;;;26     	ADC_Init(ADC1, &ADC_InitStructure);
000046  a901              ADD      r1,sp,#4
000048  4813              LDR      r0,|L2.152|
00004a  f7fffffe          BL       ADC_Init
;;;27     	
;;;28     	/* ADC1 regular channel 1 configuration */ 
;;;29     	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_239Cycles5);
00004e  2307              MOVS     r3,#7
000050  2201              MOVS     r2,#1
000052  4611              MOV      r1,r2
000054  4810              LDR      r0,|L2.152|
000056  f7fffffe          BL       ADC_RegularChannelConfig
;;;30     	ADC_Cmd(ADC1, ENABLE);                                                /* Enable ADC1 */
00005a  2101              MOVS     r1,#1
00005c  480e              LDR      r0,|L2.152|
00005e  f7fffffe          BL       ADC_Cmd
;;;31     	
;;;32     	/* Enable ADC1 reset calibaration register */   
;;;33     	ADC_ResetCalibration(ADC1);
000062  480d              LDR      r0,|L2.152|
000064  f7fffffe          BL       ADC_ResetCalibration
;;;34     	/* Check the end of ADC1 reset calibration register */
;;;35     	while(ADC_GetResetCalibrationStatus(ADC1));
000068  bf00              NOP      
                  |L2.106|
00006a  480b              LDR      r0,|L2.152|
00006c  f7fffffe          BL       ADC_GetResetCalibrationStatus
000070  2800              CMP      r0,#0
000072  d1fa              BNE      |L2.106|
;;;36     	
;;;37     	/* Start ADC1 calibaration */
;;;38     	ADC_StartCalibration(ADC1);
000074  4808              LDR      r0,|L2.152|
000076  f7fffffe          BL       ADC_StartCalibration
;;;39     	/* Check the end of ADC1 calibration */
;;;40     	while(ADC_GetCalibrationStatus(ADC1));
00007a  bf00              NOP      
                  |L2.124|
00007c  4806              LDR      r0,|L2.152|
00007e  f7fffffe          BL       ADC_GetCalibrationStatus
000082  2800              CMP      r0,#0
000084  d1fa              BNE      |L2.124|
;;;41                             
;;;42     	ADC_SoftwareStartConvCmd(ADC1,ENABLE);                                /* 使能转换开始 */
000086  2101              MOVS     r1,#1
000088  4803              LDR      r0,|L2.152|
00008a  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;43     }
00008e  b007              ADD      sp,sp,#0x1c
000090  bd00              POP      {pc}
;;;44     
                          ENDP

000092  0000              DCW      0x0000
                  |L2.148|
                          DCD      0x40011000
                  |L2.152|
                          DCD      0x40012400
