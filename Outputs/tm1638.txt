; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\tm1638.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\tm1638.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP -I..\BSP\IWDG -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\App\Debug -I..\App\SelfCheck -I..\App\Voltage -I..\App\ATC30 -I..\App -I..\BSP\uart -I..\App\Task -I..\App\Task -IH:\self\2016.1.7\shumaguan\mart\Project\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\tm1638.crf ..\BSP\tm1638.c]
                          THUMB

                          AREA ||i.Key1603_Check||, CODE, READONLY, ALIGN=2

                  Key1603_Check PROC
;;;8                                 0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};
;;;9      KeyStaEnum Key1603_Check(u8 flag)
000000  b510              PUSH     {r4,lr}
;;;10     {
000002  4604              MOV      r4,r0
;;;11     	static BOOLEAN TimStart = bFALSE;
;;;12     	if( TimStart == bFALSE ){
000004  4815              LDR      r0,|L1.92|
000006  7800              LDRB     r0,[r0,#0]  ; TimStart
000008  b958              CBNZ     r0,|L1.34|
;;;13     		if(GPIO_ReadInputDataBit(KEY1_PORT,KEY1_PIN) == RESET){
00000a  2104              MOVS     r1,#4
00000c  4814              LDR      r0,|L1.96|
00000e  f7fffffe          BL       GPIO_ReadInputDataBit
000012  bb00              CBNZ     r0,|L1.86|
;;;14     			TimStart = bTRUE;
000014  2001              MOVS     r0,#1
000016  4911              LDR      r1,|L1.92|
000018  7008              STRB     r0,[r1,#0]
;;;15     			Timer_Reset(&Tm16033_Tim);
00001a  4812              LDR      r0,|L1.100|
00001c  f7fffffe          BL       Timer_Reset
000020  e019              B        |L1.86|
                  |L1.34|
;;;16     		}
;;;17     	}else{
;;;18     		if(GPIO_ReadInputDataBit(KEY1_PORT,KEY1_PIN) == SET){
000022  2104              MOVS     r1,#4
000024  480e              LDR      r0,|L1.96|
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  2801              CMP      r0,#1
00002c  d113              BNE      |L1.86|
;;;19     			TimStart = bFALSE;			
00002e  2000              MOVS     r0,#0
000030  490a              LDR      r1,|L1.92|
000032  7008              STRB     r0,[r1,#0]
;;;20     			if(Timer_GetElapse(&Tm16033_Tim) < 1000){
000034  480b              LDR      r0,|L1.100|
000036  f7fffffe          BL       Timer_GetElapse
00003a  f5b07f7a          CMP      r0,#0x3e8
00003e  d201              BCS      |L1.68|
;;;21     				return (Short);
000040  2001              MOVS     r0,#1
                  |L1.66|
;;;22     			}else if(Timer_GetElapse(&Tm16033_Tim) > 3000){
;;;23     				return (Long);
;;;24     			}
;;;25     		}		
;;;26     	}
;;;27     	
;;;28     	return (NoPut);
;;;29     
;;;30     }
000042  bd10              POP      {r4,pc}
                  |L1.68|
000044  4807              LDR      r0,|L1.100|
000046  f7fffffe          BL       Timer_GetElapse
00004a  f64031b8          MOV      r1,#0xbb8             ;22
00004e  4288              CMP      r0,r1                 ;22
000050  d901              BLS      |L1.86|
000052  2002              MOVS     r0,#2                 ;23
000054  e7f5              B        |L1.66|
                  |L1.86|
000056  2000              MOVS     r0,#0                 ;28
000058  e7f3              B        |L1.66|
;;;31      
                          ENDP

00005a  0000              DCW      0x0000
                  |L1.92|
                          DCD      TimStart
                  |L1.96|
                          DCD      0x40011000
                  |L1.100|
                          DCD      Tm16033_Tim

                          AREA ||i.Read_key||, CODE, READONLY, ALIGN=2

                  Read_key PROC
;;;87     /*k3连接了8个键*/
;;;88     unsigned char Read_key(void)
000000  b538              PUSH     {r3-r5,lr}
;;;89     {
;;;90       unsigned char c[4],i,key_value=0;
000002  2500              MOVS     r5,#0
;;;91       RESET_STB;
000004  2120              MOVS     r1,#0x20
000006  4816              LDR      r0,|L2.96|
000008  f7fffffe          BL       GPIO_ResetBits
;;;92       TM1638_Write(0x42);/*数据命令设置：读取键值命令*/
00000c  2042              MOVS     r0,#0x42
00000e  f7fffffe          BL       TM1638_Write
;;;93       for(i=0;i<4;i++)
000012  2400              MOVS     r4,#0
000014  e005              B        |L2.34|
                  |L2.22|
;;;94         c[i]=TM1638_Read();/*连续读取四个字节*/
000016  f7fffffe          BL       TM1638_Read
00001a  f80d0004          STRB     r0,[sp,r4]
00001e  1c60              ADDS     r0,r4,#1              ;93
000020  b2c4              UXTB     r4,r0                 ;93
                  |L2.34|
000022  2c04              CMP      r4,#4                 ;93
000024  dbf7              BLT      |L2.22|
;;;95       SET_STB;	
000026  2120              MOVS     r1,#0x20
000028  480d              LDR      r0,|L2.96|
00002a  f7fffffe          BL       GPIO_SetBits
;;;96       for(i=0;i<4;i++)
00002e  2400              MOVS     r4,#0
000030  e004              B        |L2.60|
                  |L2.50|
;;;97         key_value|=c[i];
000032  f81d0004          LDRB     r0,[sp,r4]
000036  4305              ORRS     r5,r5,r0
000038  1c60              ADDS     r0,r4,#1              ;96
00003a  b2c4              UXTB     r4,r0                 ;96
                  |L2.60|
00003c  2c04              CMP      r4,#4                 ;96
00003e  dbf8              BLT      |L2.50|
;;;98       for(i=0;i<4;i++)
000040  2400              MOVS     r4,#0
000042  e006              B        |L2.82|
                  |L2.68|
;;;99         if(c[i]==key_value)
000044  f81d0004          LDRB     r0,[sp,r4]
000048  42a8              CMP      r0,r5
00004a  d100              BNE      |L2.78|
;;;100          break;
00004c  e003              B        |L2.86|
                  |L2.78|
00004e  1c60              ADDS     r0,r4,#1              ;98
000050  b2c4              UXTB     r4,r0                 ;98
                  |L2.82|
000052  2c04              CMP      r4,#4                 ;98
000054  dbf6              BLT      |L2.68|
                  |L2.86|
000056  bf00              NOP      
;;;101      return (i*8+key_value);  
000058  eb0500c4          ADD      r0,r5,r4,LSL #3
00005c  b2c0              UXTB     r0,r0
;;;102    }
00005e  bd38              POP      {r3-r5,pc}
;;;103    void Write_oneLED(unsigned char num,unsigned char flag)	//单独控制一个LED函数，num为需要控制的led序号，flag为0时熄灭，不为0时点亮
                          ENDP

                  |L2.96|
                          DCD      0x40010800

                          AREA ||i.TM1638GPIO_Config||, CODE, READONLY, ALIGN=2

                  TM1638GPIO_Config PROC
;;;31      
;;;32     void TM1638GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;33     {
;;;34       
;;;35     
;;;36          GPIO_InitTypeDef GPIO_InitStructure; 
;;;37          RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;38          GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5| GPIO_Pin_6|GPIO_Pin_7; 
00000a  20e0              MOVS     r0,#0xe0
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;39          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;40          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;41          GPIO_Init(GPIOA, &GPIO_InitStructure); 
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L3.40|
000020  f7fffffe          BL       GPIO_Init
;;;42     } 
000024  bd08              POP      {r3,pc}
;;;43     void TM1638_Write(unsigned char	DATA)			//写数据函数
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40010800

                          AREA ||i.TM1638_Read||, CODE, READONLY, ALIGN=2

                  TM1638_Read PROC
;;;56     }
;;;57     unsigned char TM1638_Read(void)					//读数据函数
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
;;;59     	unsigned char i;
;;;60     	unsigned char temp=0;
000002  2400              MOVS     r4,#0
;;;61       SET_DIO;	//设置为输入
000004  2180              MOVS     r1,#0x80
000006  480e              LDR      r0,|L4.64|
000008  f7fffffe          BL       GPIO_SetBits
;;;62     	for(i=0;i<8;i++)
00000c  2500              MOVS     r5,#0
00000e  e012              B        |L4.54|
                  |L4.16|
;;;63     	{
;;;64     		temp>>=1;
000010  1064              ASRS     r4,r4,#1
;;;65     		RESET_CLK;
000012  2140              MOVS     r1,#0x40
000014  480a              LDR      r0,|L4.64|
000016  f7fffffe          BL       GPIO_ResetBits
;;;66     		if(GPIO_ReadInputDataBit(DIO_PORT,DIO_PIN) == SET)
00001a  2180              MOVS     r1,#0x80
00001c  4808              LDR      r0,|L4.64|
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  2801              CMP      r0,#1
000024  d101              BNE      |L4.42|
;;;67     			temp|=0x80;
000026  f0440480          ORR      r4,r4,#0x80
                  |L4.42|
;;;68     		SET_CLK;
00002a  2140              MOVS     r1,#0x40
00002c  4804              LDR      r0,|L4.64|
00002e  f7fffffe          BL       GPIO_SetBits
000032  1c68              ADDS     r0,r5,#1              ;62
000034  b2c5              UXTB     r5,r0                 ;62
                  |L4.54|
000036  2d08              CMP      r5,#8                 ;62
000038  dbea              BLT      |L4.16|
;;;69     	}
;;;70     	return temp;
00003a  4620              MOV      r0,r4
;;;71     }	
00003c  bd70              POP      {r4-r6,pc}
;;;72     void Write_COM(unsigned char cmd)		//发送命令字
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x40010800

                          AREA ||i.TM1638_Write||, CODE, READONLY, ALIGN=2

                  TM1638_Write PROC
;;;42     } 
;;;43     void TM1638_Write(unsigned char	DATA)			//写数据函数
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
000002  4604              MOV      r4,r0
;;;45       unsigned char i;
;;;46       for(i=0;i<8;i++)
000004  2500              MOVS     r5,#0
000006  e016              B        |L5.54|
                  |L5.8|
;;;47       {    
;;;48         RESET_CLK;
000008  2140              MOVS     r1,#0x40
00000a  480c              LDR      r0,|L5.60|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;49         if(DATA&0X01)
000010  f0040001          AND      r0,r4,#1
000014  b120              CBZ      r0,|L5.32|
;;;50           SET_DIO;
000016  2180              MOVS     r1,#0x80
000018  4808              LDR      r0,|L5.60|
00001a  f7fffffe          BL       GPIO_SetBits
00001e  e003              B        |L5.40|
                  |L5.32|
;;;51         else
;;;52           RESET_DIO;
000020  2180              MOVS     r1,#0x80
000022  4806              LDR      r0,|L5.60|
000024  f7fffffe          BL       GPIO_ResetBits
                  |L5.40|
;;;53         DATA>>=1;
000028  1064              ASRS     r4,r4,#1
;;;54         SET_CLK;
00002a  2140              MOVS     r1,#0x40
00002c  4803              LDR      r0,|L5.60|
00002e  f7fffffe          BL       GPIO_SetBits
000032  1c68              ADDS     r0,r5,#1              ;46
000034  b2c5              UXTB     r5,r0                 ;46
                  |L5.54|
000036  2d08              CMP      r5,#8                 ;46
000038  dbe6              BLT      |L5.8|
;;;55       }
;;;56     }
00003a  bd70              POP      {r4-r6,pc}
;;;57     unsigned char TM1638_Read(void)					//读数据函数
                          ENDP

                  |L5.60|
                          DCD      0x40010800

                          AREA ||i.Write_COM||, CODE, READONLY, ALIGN=2

                  Write_COM PROC
;;;71     }	
;;;72     void Write_COM(unsigned char cmd)		//发送命令字
000000  b510              PUSH     {r4,lr}
;;;73     {
000002  4604              MOV      r4,r0
;;;74       RESET_STB;
000004  2120              MOVS     r1,#0x20
000006  4805              LDR      r0,|L6.28|
000008  f7fffffe          BL       GPIO_ResetBits
;;;75       TM1638_Write(cmd);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TM1638_Write
;;;76       SET_STB;
000012  2120              MOVS     r1,#0x20
000014  4801              LDR      r0,|L6.28|
000016  f7fffffe          BL       GPIO_SetBits
;;;77     }
00001a  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  |L6.28|
                          DCD      0x40010800

                          AREA ||i.Write_DATA||, CODE, READONLY, ALIGN=2

                  Write_DATA PROC
;;;78     
;;;79     void Write_DATA(unsigned char add,unsigned char DATA)//指定地址写入数据
000000  b570              PUSH     {r4-r6,lr}
;;;80     {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;81       Write_COM(0x44);       /*数据命令设置：向固定地址处写入数据命令*/  
000006  2044              MOVS     r0,#0x44
000008  f7fffffe          BL       Write_COM
;;;82       RESET_STB;
00000c  2120              MOVS     r1,#0x20
00000e  4807              LDR      r0,|L7.44|
000010  f7fffffe          BL       GPIO_ResetBits
;;;83       TM1638_Write(0xc0|add);/*地址命令设置：设置要写入数据的寄存器地址*/
000014  f04400c0          ORR      r0,r4,#0xc0
000018  f7fffffe          BL       TM1638_Write
;;;84       TM1638_Write(DATA);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       TM1638_Write
;;;85       SET_STB;
000022  2120              MOVS     r1,#0x20
000024  4801              LDR      r0,|L7.44|
000026  f7fffffe          BL       GPIO_SetBits
;;;86     }
00002a  bd70              POP      {r4-r6,pc}
;;;87     /*k3连接了8个键*/
                          ENDP

                  |L7.44|
                          DCD      0x40010800

                          AREA ||i.Write_allLED||, CODE, READONLY, ALIGN=1

                  Write_allLED PROC
;;;109    } 	 
;;;110    void Write_allLED(unsigned char LED_flag)					//控制全部LED函数，LED_flag表示各个LED状态
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4605              MOV      r5,r0
;;;112      unsigned char i;
;;;113      for(i=0;i<8;i++)
000004  2400              MOVS     r4,#0
000006  e012              B        |L8.46|
                  |L8.8|
;;;114      {
;;;115        if(LED_flag&(1<<i))
000008  2001              MOVS     r0,#1
00000a  40a0              LSLS     r0,r0,r4
00000c  4028              ANDS     r0,r0,r5
00000e  b130              CBZ      r0,|L8.30|
;;;116          Write_DATA(2*i+1,3);
000010  0061              LSLS     r1,r4,#1
000012  1c49              ADDS     r1,r1,#1
000014  b2c8              UXTB     r0,r1
000016  2103              MOVS     r1,#3
000018  f7fffffe          BL       Write_DATA
00001c  e005              B        |L8.42|
                  |L8.30|
;;;117        else
;;;118          Write_DATA(2*i+1,0);
00001e  0061              LSLS     r1,r4,#1
000020  1c49              ADDS     r1,r1,#1
000022  b2c8              UXTB     r0,r1
000024  2100              MOVS     r1,#0
000026  f7fffffe          BL       Write_DATA
                  |L8.42|
00002a  1c60              ADDS     r0,r4,#1              ;113
00002c  b2c4              UXTB     r4,r0                 ;113
                  |L8.46|
00002e  2c08              CMP      r4,#8                 ;113
000030  dbea              BLT      |L8.8|
;;;119    		}
;;;120    }
000032  bd70              POP      {r4-r6,pc}
;;;121    void init_TM1638(void)
                          ENDP


                          AREA ||i.Write_oneLED||, CODE, READONLY, ALIGN=1

                  Write_oneLED PROC
;;;102    }
;;;103    void Write_oneLED(unsigned char num,unsigned char flag)	//单独控制一个LED函数，num为需要控制的led序号，flag为0时熄灭，不为0时点亮
000000  b570              PUSH     {r4-r6,lr}
;;;104    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;105      if(flag)
000006  b135              CBZ      r5,|L9.22|
;;;106        Write_DATA(2*num+1,1);
000008  0061              LSLS     r1,r4,#1
00000a  1c49              ADDS     r1,r1,#1
00000c  b2c8              UXTB     r0,r1
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       Write_DATA
000014  e005              B        |L9.34|
                  |L9.22|
;;;107      else
;;;108        Write_DATA(2*num+1,0);
000016  0061              LSLS     r1,r4,#1
000018  1c49              ADDS     r1,r1,#1
00001a  b2c8              UXTB     r0,r1
00001c  2100              MOVS     r1,#0
00001e  f7fffffe          BL       Write_DATA
                  |L9.34|
;;;109    } 	 
000022  bd70              POP      {r4-r6,pc}
;;;110    void Write_allLED(unsigned char LED_flag)					//控制全部LED函数，LED_flag表示各个LED状态
                          ENDP


                          AREA ||i.init_TM1638||, CODE, READONLY, ALIGN=2

                  init_TM1638 PROC
;;;120    }
;;;121    void init_TM1638(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123      unsigned char i;
;;;124      TM1638GPIO_Config();
000002  f7fffffe          BL       TM1638GPIO_Config
;;;125      Write_COM(0x8F); /*显示控制命令设置：消光数量控制和显示开关设置*/
000006  208f              MOVS     r0,#0x8f
000008  f7fffffe          BL       Write_COM
;;;126      Write_COM(0x40); /*写数据命令设置：向显示寄存器写数据且地址自动增加*/
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       Write_COM
;;;127    
;;;128    	TM1638_Write(0xc0);//写地址命令
000012  20c0              MOVS     r0,#0xc0
000014  f7fffffe          BL       TM1638_Write
;;;129    	for(i=0;i<16;i++)
000018  2400              MOVS     r4,#0
00001a  e005              B        |L10.40|
                  |L10.28|
;;;130    		TM1638_Write(ledtab[0]);	
00001c  4906              LDR      r1,|L10.56|
00001e  7808              LDRB     r0,[r1,#0]  ; ledtab
000020  f7fffffe          BL       TM1638_Write
000024  1c60              ADDS     r0,r4,#1              ;129
000026  b2c4              UXTB     r4,r0                 ;129
                  |L10.40|
000028  2c10              CMP      r4,#0x10              ;129
00002a  dbf7              BLT      |L10.28|
;;;131    	SET_STB;
00002c  2120              MOVS     r1,#0x20
00002e  4803              LDR      r0,|L10.60|
000030  f7fffffe          BL       GPIO_SetBits
;;;132    
;;;133    }
000034  bd10              POP      {r4,pc}
;;;134    //============================================================================//
                          ENDP

000036  0000              DCW      0x0000
                  |L10.56|
                          DCD      ledtab
                  |L10.60|
                          DCD      0x40010800

                          AREA ||i.key_scan||, CODE, READONLY, ALIGN=2

                  key_scan PROC
;;;134    //============================================================================//
;;;135    void key_scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
;;;137      u8 i=0,keyvalue=0,keytemp=0;  
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;138      keyvalue=Read_key();
000008  f7fffffe          BL       Read_key
00000c  4605              MOV      r5,r0
;;;139      if(keyvalue!=0)
00000e  2d00              CMP      r5,#0
000010  d04f              BEQ      |L11.178|
;;;140      {
;;;141      for(i=0;i<8;i++)
000012  bf00              NOP      
000014  e007              B        |L11.38|
                  |L11.22|
;;;142      {
;;;143        if( keyvalue==key_tab1[i])
000016  4827              LDR      r0,|L11.180|
000018  5d00              LDRB     r0,[r0,r4]
00001a  42a8              CMP      r0,r5
00001c  d101              BNE      |L11.34|
;;;144        {keytemp=i;break;}
00001e  4626              MOV      r6,r4
000020  e003              B        |L11.42|
                  |L11.34|
000022  1c60              ADDS     r0,r4,#1              ;141
000024  b2c4              UXTB     r4,r0                 ;141
                  |L11.38|
000026  2c08              CMP      r4,#8                 ;141
000028  dbf5              BLT      |L11.22|
                  |L11.42|
00002a  bf00              NOP      
;;;145      } 
;;;146      switch(keytemp)
00002c  2e08              CMP      r6,#8
00002e  d23e              BCS      |L11.174|
000030  e8dff006          TBB      [pc,r6]
000034  04050d19          DCB      0x04,0x05,0x0d,0x19
000038  21293137          DCB      0x21,0x29,0x31,0x37
;;;147      {
;;;148        case 0: 
;;;149    //				   if(ModeMainFlag<2){
;;;150    //           
;;;151    //    
;;;152    // 		    ModeMainFlag=3;
;;;153    //          }
;;;154    					
;;;155              
;;;156               break;
00003c  e038              B        |L11.176|
;;;157        case 1: 
;;;158      		
;;;159    			LCD_Clear();  LCD_WriteString_en(30,0,"2"); 
00003e  f7fffffe          BL       LCD_Clear
000042  a21d              ADR      r2,|L11.184|
000044  2100              MOVS     r1,#0
000046  201e              MOVS     r0,#0x1e
000048  f7fffffe          BL       LCD_WriteString_en
;;;160     
;;;161    	 
;;;162              break;
00004c  e030              B        |L11.176|
;;;163        case 2:  		 	LCD_Clear(); 
00004e  f7fffffe          BL       LCD_Clear
;;;164                  		LCD_WriteString_en(30,0,"3");
000052  a21a              ADR      r2,|L11.188|
000054  2100              MOVS     r1,#0
000056  201e              MOVS     r0,#0x1e
000058  f7fffffe          BL       LCD_WriteString_en
;;;165    					        Write_oneLED(0,0);
00005c  2100              MOVS     r1,#0
00005e  4608              MOV      r0,r1
000060  f7fffffe          BL       Write_oneLED
;;;166               break;
000064  e024              B        |L11.176|
;;;167        case 3: 	LCD_Clear();
000066  f7fffffe          BL       LCD_Clear
;;;168                 	LCD_WriteString_en(30,0,"4");
00006a  a215              ADR      r2,|L11.192|
00006c  2100              MOVS     r1,#0
00006e  201e              MOVS     r0,#0x1e
000070  f7fffffe          BL       LCD_WriteString_en
;;;169               break;
000074  e01c              B        |L11.176|
;;;170        case 4: 	LCD_Clear();
000076  f7fffffe          BL       LCD_Clear
;;;171    			  	LCD_WriteString_en(30,0,"5");
00007a  a212              ADR      r2,|L11.196|
00007c  2100              MOVS     r1,#0
00007e  201e              MOVS     r0,#0x1e
000080  f7fffffe          BL       LCD_WriteString_en
;;;172               break;
000084  e014              B        |L11.176|
;;;173        case 5:  
;;;174    			LCD_Clear();
000086  f7fffffe          BL       LCD_Clear
;;;175    			LCD_WriteString_en(30,0,"6");
00008a  a20f              ADR      r2,|L11.200|
00008c  2100              MOVS     r1,#0
00008e  201e              MOVS     r0,#0x1e
000090  f7fffffe          BL       LCD_WriteString_en
;;;176    			break;
000094  e00c              B        |L11.176|
;;;177        case 6:  	LCD_WriteString_en(30,0,"7");
000096  a20d              ADR      r2,|L11.204|
000098  2100              MOVS     r1,#0
00009a  201e              MOVS     r0,#0x1e
00009c  f7fffffe          BL       LCD_WriteString_en
;;;178    			break;
0000a0  e006              B        |L11.176|
;;;179        case 7:  	LCD_WriteString_en(30,0,"8");
0000a2  a20b              ADR      r2,|L11.208|
0000a4  2100              MOVS     r1,#0
0000a6  201e              MOVS     r0,#0x1e
0000a8  f7fffffe          BL       LCD_WriteString_en
;;;180    			break;    
0000ac  e000              B        |L11.176|
                  |L11.174|
;;;181        default:break;
0000ae  bf00              NOP      
                  |L11.176|
0000b0  bf00              NOP                            ;156
                  |L11.178|
;;;182      }
;;;183      }  
;;;184    }
0000b2  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L11.180|
                          DCD      key_tab1
                  |L11.184|
0000b8  3200              DCB      "2",0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L11.188|
0000bc  3300              DCB      "3",0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L11.192|
0000c0  3400              DCB      "4",0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L11.196|
0000c4  3500              DCB      "5",0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L11.200|
0000c8  3600              DCB      "6",0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L11.204|
0000cc  3700              DCB      "7",0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L11.208|
0000d0  3800              DCB      "8",0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  Tm16033_Tim
                          %        8
                  key_tab1
000008  01091119          DCB      0x01,0x09,0x11,0x19
00000c  10182028          DCB      0x10,0x18,0x20,0x28
                  ledtab
000010  003f065b          DCB      0x00,0x3f,0x06,0x5b
000014  4f666d7d          DCB      0x4f,0x66,0x6d,0x7d
000018  077f6f77          DCB      0x07,0x7f,0x6f,0x77
00001c  7c395e79          DCB      0x7c,0x39,0x5e,0x79
000020  71                DCB      0x71
                  TimStart
000021  00                DCB      0x00
