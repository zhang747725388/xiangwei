; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\outputs\pbdata.o --asm_dir=..\Outputs\ --list_dir=..\Outputs\ --depend=..\outputs\pbdata.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\CMSIS -I..\Library\inc -I..\Library\STM32_USB-FS-Device_Driver\inc -I..\Kernel -I..\BSP\Basic -I..\BSP\GPS -I..\BSP\Sim900A -I..\BSP -I..\BSP\IWDG -I..\BSP\BlueTooth -I..\BSP\Led -I..\BSP\Key -I..\BSP\ADC -I..\BSP\Adxl345 -I..\BSP\TL718 -I..\BSP\PAM8403 -I..\BSP\W25X16 -I..\BSP\USB -I..\App\Debug -I..\App\SelfCheck -I..\App\GPSTask -I..\App\OBD -I..\App\Mems -I..\App\Voltage -I..\App\LKClient -I..\App\Paramlist -I..\App\ATC30 -I..\App -I..\BSP\mpu6050 -I..\App\mid-proc -I..\App\mpu6050Task -I..\BSP\dmp -I..\BSP\Bluetooth -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210C_EVAL -DHXZ_RELEASE_VERSION --omf_browse=..\outputs\pbdata.crf ..\BSP\mpu6050\pbdata.c]
                          THUMB

                          AREA ||i.RCC_HSE_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_HSE_Configuration PROC
;;;5      
;;;6      void RCC_HSE_Configuration(void) //HSE作为PLL时钟，PLL作为SYSCLK 
000000  b510              PUSH     {r4,lr}
;;;7      { 
;;;8         RCC_DeInit(); /*将外设RCC寄存器重设为缺省值 */ 
000002  f7fffffe          BL       RCC_DeInit
;;;9         RCC_HSEConfig(RCC_HSE_ON); 	 /*设置外部高速晶振（HSE） HSE晶振打开(ON)*/ 
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;10     
;;;11        if(RCC_WaitForHSEStartUp() == SUCCESS) {  /*等待HSE起振,  SUCCESS：HSE晶振稳定且就绪*/  
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  2801              CMP      r0,#1
000014  d120              BNE      |L1.88|
;;;12     
;;;13        RCC_HCLKConfig(RCC_SYSCLK_Div1);/*设置AHB时钟(HCLK)RCC_SYSCLK_Div1――AHB时钟 = 系统时*/  
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       RCC_HCLKConfig
;;;14        RCC_PCLK2Config(RCC_HCLK_Div1); /*设置高速AHB时钟(PCLK2)RCC_HCLK_Div1――APB2时钟 = HCLK*/     
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       RCC_PCLK2Config
;;;15        RCC_PCLK1Config(RCC_HCLK_Div2); /*设置低速AHB时钟(PCLK1)RCC_HCLK_Div2――APB1时钟 = HCLK / 2*/      
000022  f44f6080          MOV      r0,#0x400
000026  f7fffffe          BL       RCC_PCLK1Config
;;;16     
;;;17        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);/*设置PLL时钟源及倍频系数*/    
00002a  f44f11e0          MOV      r1,#0x1c0000
00002e  f44f3080          MOV      r0,#0x10000
000032  f7fffffe          BL       RCC_PLLConfig
;;;18        RCC_PLLCmd(ENABLE); 	 /*使能PLL */ 
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       RCC_PLLCmd
;;;19        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) ; /*检查指定的RCC标志位(PLL准备好标志)设置与否*/ 
00003c  bf00              NOP      
                  |L1.62|
00003e  2039              MOVS     r0,#0x39
000040  f7fffffe          BL       RCC_GetFlagStatus
000044  2800              CMP      r0,#0
000046  d0fa              BEQ      |L1.62|
;;;20         
;;;21        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);  /*设置系统时钟（SYSCLK） */  
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       RCC_SYSCLKConfig
;;;22        while(RCC_GetSYSCLKSource() != 0x08);     /*0x08：PLL作为系统时钟 */	    
00004e  bf00              NOP      
                  |L1.80|
000050  f7fffffe          BL       RCC_GetSYSCLKSource
000054  2808              CMP      r0,#8
000056  d1fb              BNE      |L1.80|
                  |L1.88|
;;;23      } 
;;;24     } 
000058  bd10              POP      {r4,pc}
;;;25     
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;25     
;;;26     void delay(u32 nCount)
000000  e000              B        |L2.4|
                  |L2.2|
;;;27     {
;;;28     	for(;nCount!=0;nCount--);
000002  1e40              SUBS     r0,r0,#1
                  |L2.4|
000004  2800              CMP      r0,#0
000006  d1fc              BNE      |L2.2|
;;;29     }
000008  4770              BX       lr
;;;30     
                          ENDP


                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=1

                  delay_ms PROC
;;;61     ****************************************************************************/ 
;;;62     void delay_ms(u16 nms)
000000  4601              MOV      r1,r0
;;;63     {
;;;64          //注意 delay_ms函数输入范围是1-1863
;;;65     	 //所以最大延时为1.8秒
;;;66     
;;;67     	 u32 temp;
;;;68     	 SysTick->LOAD = 9000*nms;
000002  f2423228          MOV      r2,#0x2328
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;69     	 SysTick->VAL=0X00;//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;70     	 SysTick->CTRL=0X01;//使能，减到零是无动作，采用外部时钟源
000012  2201              MOVS     r2,#1
000014  611a              STR      r2,[r3,#0x10]
;;;71     	 do
000016  bf00              NOP      
                  |L3.24|
;;;72     	 {
;;;73     	  temp=SysTick->CTRL;//读取当前倒计数值
000018  f04f22e0          MOV      r2,#0xe000e000
00001c  6910              LDR      r0,[r2,#0x10]
;;;74     	 }while((temp&0x01)&&(!(temp&(1<<16))));//等待时间到达
00001e  f0100f01          TST      r0,#1
000022  d002              BEQ      |L3.42|
000024  f4103f80          TST      r0,#0x10000
000028  d0f6              BEQ      |L3.24|
                  |L3.42|
;;;75     	 SysTick->CTRL=0x00; //关闭计数器
00002a  2200              MOVS     r2,#0
00002c  f04f23e0          MOV      r3,#0xe000e000
000030  611a              STR      r2,[r3,#0x10]
;;;76     	 SysTick->VAL =0X00; //清空计数器
000032  619a              STR      r2,[r3,#0x18]
;;;77     }
000034  4770              BX       lr
;;;78     
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=1

                  delay_us PROC
;;;38     ****************************************************************************/ 
;;;39     void delay_us(u32 nus)
000000  4601              MOV      r1,r0
;;;40     {
;;;41     	 u32 temp;
;;;42     	 SysTick->LOAD = 9*nus;
000002  eb0102c1          ADD      r2,r1,r1,LSL #3
000006  f04f23e0          MOV      r3,#0xe000e000
00000a  615a              STR      r2,[r3,#0x14]
;;;43     	 SysTick->VAL=0X00;//清空计数器
00000c  2200              MOVS     r2,#0
00000e  619a              STR      r2,[r3,#0x18]
;;;44     	 SysTick->CTRL=0X01;//使能，减到零是无动作，采用外部时钟源
000010  2201              MOVS     r2,#1
000012  611a              STR      r2,[r3,#0x10]
;;;45     	 do
000014  bf00              NOP      
                  |L4.22|
;;;46     	 {
;;;47     	  temp=SysTick->CTRL;//读取当前倒计数值
000016  f04f22e0          MOV      r2,#0xe000e000
00001a  6910              LDR      r0,[r2,#0x10]
;;;48     	 }while((temp&0x01)&&(!(temp&(1<<16))));//等待时间到达
00001c  f0100f01          TST      r0,#1
000020  d002              BEQ      |L4.40|
000022  f4103f80          TST      r0,#0x10000
000026  d0f6              BEQ      |L4.22|
                  |L4.40|
;;;49     	 
;;;50     	 SysTick->CTRL=0x00; //关闭计数器
000028  2200              MOVS     r2,#0
00002a  f04f23e0          MOV      r3,#0xe000e000
00002e  611a              STR      r2,[r3,#0x10]
;;;51     	 SysTick->VAL =0X00; //清空计数器
000030  619a              STR      r2,[r3,#0x18]
;;;52     }
000032  4770              BX       lr
;;;53     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  ||dt||
000000  00                DCB      0x00
